def byte_compile(py_files, optimize=0, force=0, prefix=None, base_dir=None, verbose=1, dry_run=0, direct=None):
    'Byte-compile a collection of Python source files to either .pyc\n    or .pyo files in the same directory.  \'py_files\' is a list of files\n    to compile; any files that don\'t end in ".py" are silently skipped.\n    \'optimize\' must be one of the following:\n      0 - don\'t optimize (generate .pyc)\n      1 - normal optimization (like "python -O")\n      2 - extra optimization (like "python -OO")\n    If \'force\' is true, all files are recompiled regardless of\n    timestamps.\n\n    The source filename encoded in each bytecode file defaults to the\n    filenames listed in \'py_files\'; you can modify these with \'prefix\' and\n    \'basedir\'.  \'prefix\' is a string that will be stripped off of each\n    source filename, and \'base_dir\' is a directory name that will be\n    prepended (after \'prefix\' is stripped).  You can supply either or both\n    (or neither) of \'prefix\' and \'base_dir\', as you wish.\n\n    If \'dry_run\' is true, doesn\'t actually do anything that would\n    affect the filesystem.\n\n    Byte-compilation is either done directly in this interpreter process\n    with the standard py_compile module, or indirectly by writing a\n    temporary script and executing it.  Normally, you should let\n    \'byte_compile()\' figure out to use direct compilation or not (see\n    the source for details).  The \'direct\' flag is used by the script\n    generated in indirect mode; unless you know what you\'re doing, leave\n    it set to None.\n    '
    if (direct is None):
        direct = (__debug__ and (optimize == 0))
    if (not direct):
        try:
            from tempfile import mkstemp
            (script_fd, script_name) = mkstemp('.py')
        except ImportError:
            from tempfile import mktemp
            (script_fd, script_name) = (None, mktemp('.py'))
        log.info("writing byte-compilation script '%s'", script_name)
        if (not dry_run):
            if (script_fd is not None):
                script = os.fdopen(script_fd, 'w')
            else:
                script = open(script_name, 'w')
            script.write('from distutils.util import byte_compile\nfiles = [\n')
            script.write((string.join(map(repr, py_files), ',\n') + ']\n'))
            script.write(('\nbyte_compile(files, optimize=%r, force=%r,\n             prefix=%r, base_dir=%r,\n             verbose=%r, dry_run=0,\n             direct=1)\n' % (optimize, force, prefix, base_dir, verbose)))
            script.close()
        cmd = [sys.executable, script_name]
        if (optimize == 1):
            cmd.insert(1, '-O')
        elif (optimize == 2):
            cmd.insert(1, '-OO')
        spawn(cmd, dry_run=dry_run)
        execute(os.remove, (script_name,), ('removing %s' % script_name), dry_run=dry_run)
    else:
        from py_compile import compile
        for file in py_files:
            if (file[(-3):] != '.py'):
                continue
            if sys.platform.startswith('java'):
                cfile = (file[:(-3)] + '$py.class')
            else:
                cfile = (file + ((__debug__ and 'c') or 'o'))
            dfile = file
            if prefix:
                if (file[:len(prefix)] != prefix):
                    raise ValueError, ("invalid prefix: filename %r doesn't start with %r" % (file, prefix))
                dfile = dfile[len(prefix):]
            if base_dir:
                dfile = os.path.join(base_dir, dfile)
            cfile_base = os.path.basename(cfile)
            if direct:
                if (force or newer(file, cfile)):
                    log.info('byte-compiling %s to %s', file, cfile_base)
                    if (not dry_run):
                        compile(file, cfile, dfile)
                else:
                    log.debug('skipping byte-compilation of %s to %s', file, cfile_base)
