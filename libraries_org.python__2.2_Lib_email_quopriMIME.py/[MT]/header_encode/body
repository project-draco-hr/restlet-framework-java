def header_encode(header, charset='iso-8859-1', keep_eols=False, maxlinelen=76, eol=NL):
    'Encode a single header line with quoted-printable (like) encoding.\n\n    Defined in RFC 2045, this `Q\' encoding is similar to quoted-printable, but\n    used specifically for email header fields to allow charsets with mostly 7\n    bit characters (and some 8 bit) to remain more or less readable in non-RFC\n    2045 aware mail clients.\n\n    charset names the character set to use to encode the header.  It defaults\n    to iso-8859-1.\n\n    The resulting string will be in the form:\n\n    "=?charset?q?I_f=E2rt_in_your_g=E8n=E8ral_dire=E7tion?\\n\n      =?charset?q?Silly_=C8nglish_Kn=EEghts?="\n\n    with each line wrapped safely at, at most, maxlinelen characters (defaults\n    to 76 characters).  If maxlinelen is None, the entire string is encoded in\n    one chunk with no splitting.\n\n    End-of-line characters (\\r, \\n, \\r\\n) will be automatically converted\n    to the canonical email line separator \\r\\n unless the keep_eols\n    parameter is True (the default is False).\n\n    Each line of the header will be terminated in the value of eol, which\n    defaults to "\\n".  Set this to "\\r\\n" if you are using the result of\n    this function directly in email.\n    '
    if (not header):
        return header
    if (not keep_eols):
        header = fix_eols(header)
    quoted = []
    if (maxlinelen is None):
        max_encoded = 100000
    else:
        max_encoded = (((maxlinelen - len(charset)) - MISC_LEN) - 1)
    for c in header:
        if (c == ' '):
            _max_append(quoted, '_', max_encoded)
        elif (not hqre.match(c)):
            _max_append(quoted, c, max_encoded)
        else:
            _max_append(quoted, ('=%02X' % ord(c)), max_encoded)
    joiner = (eol + ' ')
    return joiner.join([('=?%s?q?%s?=' % (charset, line)) for line in quoted])
