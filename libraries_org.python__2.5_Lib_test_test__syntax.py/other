'This module tests SyntaxErrors.\n\nHere\'s an example of the sort of thing that is tested.\n\n>>> def f(x):\n...     global x\nTraceback (most recent call last):\nSyntaxError: name \'x\' is local and global\n\nThe tests are all raise SyntaxErrors.  They were created by checking\neach C call that raises SyntaxError.  There are several modules that\nraise these exceptions-- ast.c, compile.c, future.c, pythonrun.c, and\nsymtable.c.\n\nThe parser itself outlaws a lot of invalid syntax.  None of these\nerrors are tested here at the moment.  We should add some tests; since\nthere are infinitely many programs with invalid syntax, we would need\nto be judicious in selecting some.\n\nThe compiler generates a synthetic module name for code executed by\ndoctest.  Since all the code comes from the same module, a suffix like\n[1] is appended to the module name, As a consequence, changing the\norder of tests in this module means renumbering all the errors after\nit.  (Maybe we should enable the ellipsis option for these tests.)\n\nIn ast.c, syntax errors are raised by calling ast_error().\n\nErrors from set_context():\n\nTODO(jhylton): "assignment to None" is inconsistent with other messages\n\n#XXX: None as a dotted name is specifically allowed in Jython for Java compatibility.\n#>>> obj.None = 1\n#Traceback (most recent call last):\n#SyntaxError: assignment to None (<doctest test.test_syntax[1]>, line 1)\n\n>>> None = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: assignment to None (<doctest test.test_syntax[2]>, line 1)\n\nIt\'s a syntax error to assign to the empty tuple.  Why isn\'t it an\nerror to assign to the empty list?  It will always raise some error at\nruntime.\n\n>>> () = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to () (<doctest test.test_syntax[3]>, line 1)\n\n>>> f() = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to function call (<doctest test.test_syntax[4]>, line 1)\n\n>>> del f() #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t delete function call (<doctest test.test_syntax[5]>, line 1)\n\n>>> a + 1 = 2 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to operator (<doctest test.test_syntax[6]>, line 1)\n\n>>> (x for x in x) = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to generator expression (<doctest test.test_syntax[7]>, line 1)\n\n>>> 1 = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to literal (<doctest test.test_syntax[8]>, line 1)\n\n>>> "abc" = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to literal (<doctest test.test_syntax[9]>, line 1)\n\n>>> `1` = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to repr (<doctest test.test_syntax[10]>, line 1)\n\nIf the left-hand side of an assignment is a list or tuple, an illegal\nexpression inside that contain should still cause a syntax error.\nThis test just checks a couple of cases rather than enumerating all of\nthem.\n\n>>> (a, "b", c) = (1, 2, 3) #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to literal (<doctest test.test_syntax[11]>, line 1)\n\n>>> [a, b, c + 1] = [1, 2, 3] #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to operator (<doctest test.test_syntax[12]>, line 1)\n\n>>> a if 1 else b = 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: can\'t assign to conditional expression (<doctest test.test_syntax[13]>, line 1)\n\nFrom compiler_complex_args():\n\n>>> def f(None=1): #doctest: +IGNORE_EXCEPTION_DETAIL\n...     pass\nTraceback (most recent call last):\nSyntaxError: assignment to None (<doctest test.test_syntax[14]>, line 1)\n\n\nFrom ast_for_arguments():\n\n>>> def f(x, y=1, z): #doctest: +IGNORE_EXCEPTION_DETAIL\n...     pass\nTraceback (most recent call last):\nSyntaxError: non-default argument follows default argument (<doctest test.test_syntax[15]>, line 1)\n\n>>> def f(x, None): #doctest: +IGNORE_EXCEPTION_DETAIL\n...     pass\nTraceback (most recent call last):\nSyntaxError: assignment to None (<doctest test.test_syntax[16]>, line 1)\n\n>>> def f(*None): #doctest: +IGNORE_EXCEPTION_DETAIL\n...     pass\nTraceback (most recent call last):\nSyntaxError: assignment to None (<doctest test.test_syntax[17]>, line 1)\n\n>>> def f(**None): #doctest: +IGNORE_EXCEPTION_DETAIL\n...     pass\nTraceback (most recent call last):\nSyntaxError: assignment to None (<doctest test.test_syntax[18]>, line 1)\n\n\nFrom ast_for_funcdef(): #doctest: +IGNORE_EXCEPTION_DETAIL\n\n>>> def None(x): #doctest: +IGNORE_EXCEPTION_DETAIL\n...     pass\nTraceback (most recent call last):\nSyntaxError: assignment to None (<doctest test.test_syntax[19]>, line 1)\n\n\nFrom ast_for_call():\n\n>>> def f(it, *varargs):\n...     return list(it)\n>>> L = range(10)\n>>> f(x for x in L)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> f(x for x in L, 1) #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: Generator expression must be parenthesized if not sole argument (<doctest test.test_syntax[23]>, line 1)\n>>> f((x for x in L), 1)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n### XXX: commented out -- jython lacks this limit -- should it have it?\n#>>> f(i0,  i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10,  i11,\n#...   i12,  i13,  i14,  i15,  i16,  i17,  i18,  i19,  i20,  i21,  i22,\n#...   i23,  i24,  i25,  i26,  i27,  i28,  i29,  i30,  i31,  i32,  i33,\n#...   i34,  i35,  i36,  i37,  i38,  i39,  i40,  i41,  i42,  i43,  i44,\n#...   i45,  i46,  i47,  i48,  i49,  i50,  i51,  i52,  i53,  i54,  i55,\n#...   i56,  i57,  i58,  i59,  i60,  i61,  i62,  i63,  i64,  i65,  i66,\n#...   i67,  i68,  i69,  i70,  i71,  i72,  i73,  i74,  i75,  i76,  i77,\n#...   i78,  i79,  i80,  i81,  i82,  i83,  i84,  i85,  i86,  i87,  i88,\n#...   i89,  i90,  i91,  i92,  i93,  i94,  i95,  i96,  i97,  i98,  i99,\n#...   i100,  i101,  i102,  i103,  i104,  i105,  i106,  i107,  i108,\n#...   i109,  i110,  i111,  i112,  i113,  i114,  i115,  i116,  i117,\n#...   i118,  i119,  i120,  i121,  i122,  i123,  i124,  i125,  i126,\n#...   i127,  i128,  i129,  i130,  i131,  i132,  i133,  i134,  i135,\n#...   i136,  i137,  i138,  i139,  i140,  i141,  i142,  i143,  i144,\n#...   i145,  i146,  i147,  i148,  i149,  i150,  i151,  i152,  i153,\n#...   i154,  i155,  i156,  i157,  i158,  i159,  i160,  i161,  i162,\n#...   i163,  i164,  i165,  i166,  i167,  i168,  i169,  i170,  i171,\n#...   i172,  i173,  i174,  i175,  i176,  i177,  i178,  i179,  i180,\n#...   i181,  i182,  i183,  i184,  i185,  i186,  i187,  i188,  i189,\n#...   i190,  i191,  i192,  i193,  i194,  i195,  i196,  i197,  i198,\n#...   i199,  i200,  i201,  i202,  i203,  i204,  i205,  i206,  i207,\n#...   i208,  i209,  i210,  i211,  i212,  i213,  i214,  i215,  i216,\n#...   i217,  i218,  i219,  i220,  i221,  i222,  i223,  i224,  i225,\n#...   i226,  i227,  i228,  i229,  i230,  i231,  i232,  i233,  i234,\n#...   i235,  i236,  i237,  i238,  i239,  i240,  i241,  i242,  i243,\n#...   i244,  i245,  i246,  i247,  i248,  i249,  i250,  i251,  i252,\n#...   i253,  i254,  i255)\n#Traceback (most recent call last):\n#SyntaxError: more than 255 arguments (<doctest test.test_syntax[25]>, line 1)\n\nThe actual error cases counts positional arguments, keyword arguments,\nand generator expression arguments separately.  This test combines the\nthree.\n\n### XXX: commented out -- jython lacks this limit -- should it have it?\n#>>> f(i0,  i1,  i2,  i3,  i4,  i5,  i6,  i7,  i8,  i9,  i10,  i11,\n#...   i12,  i13,  i14,  i15,  i16,  i17,  i18,  i19,  i20,  i21,  i22,\n#...   i23,  i24,  i25,  i26,  i27,  i28,  i29,  i30,  i31,  i32,  i33,\n#...   i34,  i35,  i36,  i37,  i38,  i39,  i40,  i41,  i42,  i43,  i44,\n#...   i45,  i46,  i47,  i48,  i49,  i50,  i51,  i52,  i53,  i54,  i55,\n#...   i56,  i57,  i58,  i59,  i60,  i61,  i62,  i63,  i64,  i65,  i66,\n#...   i67,  i68,  i69,  i70,  i71,  i72,  i73,  i74,  i75,  i76,  i77,\n#...   i78,  i79,  i80,  i81,  i82,  i83,  i84,  i85,  i86,  i87,  i88,\n#...   i89,  i90,  i91,  i92,  i93,  i94,  i95,  i96,  i97,  i98,  i99,\n#...   i100,  i101,  i102,  i103,  i104,  i105,  i106,  i107,  i108,\n#...   i109,  i110,  i111,  i112,  i113,  i114,  i115,  i116,  i117,\n#...   i118,  i119,  i120,  i121,  i122,  i123,  i124,  i125,  i126,\n#...   i127,  i128,  i129,  i130,  i131,  i132,  i133,  i134,  i135,\n#...   i136,  i137,  i138,  i139,  i140,  i141,  i142,  i143,  i144,\n#...   i145,  i146,  i147,  i148,  i149,  i150,  i151,  i152,  i153,\n#...   i154,  i155,  i156,  i157,  i158,  i159,  i160,  i161,  i162,\n#...   i163,  i164,  i165,  i166,  i167,  i168,  i169,  i170,  i171,\n#...   i172,  i173,  i174,  i175,  i176,  i177,  i178,  i179,  i180,\n#...   i181,  i182,  i183,  i184,  i185,  i186,  i187,  i188,  i189,\n#...   i190,  i191,  i192,  i193,  i194,  i195,  i196,  i197,  i198,\n#...   i199,  i200,  i201,  i202,  i203,  i204,  i205,  i206,  i207,\n#...   i208,  i209,  i210,  i211,  i212,  i213,  i214,  i215,  i216,\n#...   i217,  i218,  i219,  i220,  i221,  i222,  i223,  i224,  i225,\n#...   i226,  i227,  i228,  i229,  i230,  i231,  i232,  i233,  i234,\n#...   i235, i236,  i237,  i238,  i239,  i240,  i241,  i242,  i243,\n#...   (x for x in i244),  i245,  i246,  i247,  i248,  i249,  i250,  i251,\n#...    i252=1, i253=1,  i254=1,  i255=1)\n#Traceback (most recent call last):\n#SyntaxError: more than 255 arguments (<doctest test.test_syntax[26]>, line 1)\n\n>>> f(lambda x: x[0] = 3) #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: lambda cannot contain assignment (<doctest test.test_syntax[27]>, line 1)\n\nThe grammar accepts any test (basically, any expression) in the\nkeyword slot of a call site.  Test a few different options.\n\n>>> f(x()=2) #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: keyword can\'t be an expression (<doctest test.test_syntax[28]>, line 1)\n>>> f(a or b=1) #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: keyword can\'t be an expression (<doctest test.test_syntax[29]>, line 1)\n>>> f(x.y=1) #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: keyword can\'t be an expression (<doctest test.test_syntax[30]>, line 1)\n\n\nFrom ast_for_expr_stmt():\n\n>>> (x for x in x) += 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: augmented assignment to generator expression not possible (<doctest test.test_syntax[31]>, line 1)\n>>> None += 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: assignment to None (<doctest test.test_syntax[32]>, line 1)\n>>> f() += 1 #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nSyntaxError: illegal expression for augmented assignment (<doctest test.test_syntax[33]>, line 1)\n\n\nTest continue in finally in weird combinations.\n\ncontinue in for loop under finally shouuld be ok.\n\n    >>> def test():\n    ...     try:\n    ...         pass\n    ...     finally:\n    ...         for abc in range(10):\n    ...             continue\n    ...     print abc\n    >>> test()\n    9\n\nStart simple, a continue in a finally should not be allowed.\n\n    >>> def test(): #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...    for abc in range(10):\n    ...        try:\n    ...            pass\n    ...        finally:\n    ...            continue\n    ...\n    Traceback (most recent call last):\n      ...\n    SyntaxError: \'continue\' not supported inside \'finally\' clause (<doctest test.test_syntax[36]>, line 6)\n\nThis is essentially a continue in a finally which should not be allowed.\n\n    >>> def test(): #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...    for abc in range(10):\n    ...        try:\n    ...            pass\n    ...        finally:\n    ...            try:\n    ...                continue\n    ...            except:\n    ...                pass\n    Traceback (most recent call last):\n      ...\n    SyntaxError: \'continue\' not supported inside \'finally\' clause (<doctest test.test_syntax[37]>, line 7)\n\n    >>> def foo(): #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...   try:\n    ...     pass\n    ...   finally:\n    ...     continue\n    Traceback (most recent call last):\n      ...\n    SyntaxError: \'continue\' not supported inside \'finally\' clause (<doctest test.test_syntax[38]>, line 5)\n\n    >>> def foo(): #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...   for a in ():\n    ...     try: pass\n    ...     finally: continue\n    Traceback (most recent call last):\n      ...\n    SyntaxError: \'continue\' not supported inside \'finally\' clause (<doctest test.test_syntax[39]>, line 4)\n\n    >>> def foo(): #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...  for a in ():\n    ...   try: pass\n    ...   finally:\n    ...    try:\n    ...     continue\n    ...    finally: pass\n    Traceback (most recent call last):\n      ...\n    SyntaxError: \'continue\' not supported inside \'finally\' clause (<doctest test.test_syntax[40]>, line 6)\n\n    >>> def foo(): #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...  for a in ():\n    ...   try: pass\n    ...   finally:\n    ...    try:\n    ...     pass\n    ...    except:\n    ...     continue\n    Traceback (most recent call last):\n      ...\n    SyntaxError: \'continue\' not supported inside \'finally\' clause (<doctest test.test_syntax[41]>, line 8)\n\nThere is one test for a break that is not in a loop.  The compiler\nuses a single data structure to keep track of try-finally and loops,\nso we need to be sure that a break is actually inside a loop.  If it\nisn\'t, there should be a syntax error.\n\n   >>> try: #doctest: +IGNORE_EXCEPTION_DETAIL\n   ...     print 1\n   ...     break\n   ...     print 2\n   ... finally:\n   ...     print 3\n   Traceback (most recent call last):\n     ...\n   SyntaxError: \'break\' outside loop (<doctest test.test_syntax[42]>, line 3)\n\nThis should probably raise a better error than a SystemError (or none at all).\nIn 2.5 there was a missing exception and an assert was triggered in a debug\nbuild.  The number of blocks must be greater than CO_MAXBLOCKS.  SF #1565514\n\n### XXX: commented out -- jython lacks this limit -- should it have it?\n#   >>> while 1:\n#   ...  while 2:\n#   ...   while 3:\n#   ...    while 4:\n#   ...     while 5:\n#   ...      while 6:\n#   ...       while 8:\n#   ...        while 9:\n#   ...         while 10:\n#   ...          while 11:\n#   ...           while 12:\n#   ...            while 13:\n#   ...             while 14:\n#   ...              while 15:\n#   ...               while 16:\n#   ...                while 17:\n#   ...                 while 18:\n#   ...                  while 19:\n#   ...                   while 20:\n#   ...                    while 21:\n#   ...                     while 22:\n#   ...                      break\n#   Traceback (most recent call last):\n#     ...\n#   SystemError: too many statically nested blocks\n\nThis tests assignment-context; there was a bug in Python 2.5 where compiling\na complex \'if\' (one with \'elif\') would fail to notice an invalid suite,\nleading to spurious errors.\n\n   >>> if 1: #doctest: +IGNORE_EXCEPTION_DETAIL\n   ...   x() = 1\n   ... elif 1:\n   ...   pass\n   Traceback (most recent call last):\n     ...\n   SyntaxError: can\'t assign to function call (<doctest test.test_syntax[44]>, line 2)\n\n   >>> if 1: #doctest: +IGNORE_EXCEPTION_DETAIL\n   ...   pass\n   ... elif 1:\n   ...   x() = 1\n   Traceback (most recent call last):\n     ...\n   SyntaxError: can\'t assign to function call (<doctest test.test_syntax[45]>, line 4)\n\n   >>> if 1: #doctest: +IGNORE_EXCEPTION_DETAIL\n   ...   x() = 1\n   ... elif 1:\n   ...   pass\n   ... else:\n   ...   pass\n   Traceback (most recent call last):\n     ...\n   SyntaxError: can\'t assign to function call (<doctest test.test_syntax[46]>, line 2)\n\n   >>> if 1: #doctest: +IGNORE_EXCEPTION_DETAIL\n   ...   pass\n   ... elif 1:\n   ...   x() = 1\n   ... else:\n   ...   pass\n   Traceback (most recent call last):\n     ...\n   SyntaxError: can\'t assign to function call (<doctest test.test_syntax[47]>, line 4)\n\n   >>> if 1: #doctest: +IGNORE_EXCEPTION_DETAIL\n   ...   pass\n   ... elif 1:\n   ...   pass\n   ... else:\n   ...   x() = 1\n   Traceback (most recent call last):\n     ...\n   SyntaxError: can\'t assign to function call (<doctest test.test_syntax[48]>, line 6)\n\n'
import re
import unittest
import warnings
from test import test_support
if (__name__ == '__main__'):
    test_main()
