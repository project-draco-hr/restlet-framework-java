def uu_encode(input, errors='strict', filename='<data>', mode=438):
    " Encodes the object input and returns a tuple (output\n        object, length consumed).\n\n        errors defines the error handling to apply. It defaults to\n        'strict' handling which is the only currently supported\n        error handling for this codec.\n\n    "
    assert (errors == 'strict')
    from cStringIO import StringIO
    from binascii import b2a_uu
    infile = StringIO(input)
    outfile = StringIO()
    read = infile.read
    write = outfile.write
    write(('begin %o %s\n' % ((mode & 511), filename)))
    chunk = read(45)
    while chunk:
        write(b2a_uu(chunk))
        chunk = read(45)
    write(' \nend\n')
    return (outfile.getvalue(), len(input))
