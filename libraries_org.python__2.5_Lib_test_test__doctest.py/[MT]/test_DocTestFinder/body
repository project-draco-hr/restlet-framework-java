def test_DocTestFinder():
    "\nUnit tests for the `DocTestFinder` class.\n\nDocTestFinder is used to extract DocTests from an object's docstring\nand the docstrings of its contained objects.  It can be used with\nmodules, functions, classes, methods, staticmethods, classmethods, and\nproperties.\n\nFinding Tests in Functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~\nFor a function whose docstring contains examples, DocTestFinder.find()\nwill return a single test (for that function's docstring):\n\n    >>> finder = doctest.DocTestFinder()\n\nWe'll simulate a __file__ attr that ends in pyc:\n\n    >>> import test.test_doctest\n    >>> old = test.test_doctest.__file__\n    >>> test.test_doctest.__file__ = 'test_doctest.pyc'\n\n    >>> tests = finder.find(sample_func)\n\n    >>> print tests  # doctest: +ELLIPSIS\n    [<DocTest sample_func from ...:13 (1 example)>]\n\nThe exact name depends on how test_doctest was invoked, so allow for\nleading path components.\n\n    >>> tests[0].filename # doctest: +ELLIPSIS\n    '...test_doctest.py'\n\n    >>> test.test_doctest.__file__ = old\n\n\n    >>> e = tests[0].examples[0]\n    >>> (e.source, e.want, e.lineno)\n    ('print sample_func(22)\\n', '44\\n', 3)\n\nBy default, tests are created for objects with no docstring:\n\n    >>> def no_docstring(v):\n    ...     pass\n    >>> finder.find(no_docstring)\n    []\n\nHowever, the optional argument `exclude_empty` to the DocTestFinder\nconstructor can be used to exclude tests for objects with empty\ndocstrings:\n\n    >>> def no_docstring(v):\n    ...     pass\n    >>> excl_empty_finder = doctest.DocTestFinder(exclude_empty=True)\n    >>> excl_empty_finder.find(no_docstring)\n    []\n\nIf the function has a docstring with no examples, then a test with no\nexamples is returned.  (This lets `DocTestRunner` collect statistics\nabout which functions have no tests -- but is that useful?  And should\nan empty test also be created when there's no docstring?)\n\n    >>> def no_examples(v):\n    ...     ''' no doctest examples '''\n    >>> finder.find(no_examples) # doctest: +ELLIPSIS\n    [<DocTest no_examples from ...:1 (no examples)>]\n\nFinding Tests in Classes\n~~~~~~~~~~~~~~~~~~~~~~~~\nFor a class, DocTestFinder will create a test for the class's\ndocstring, and will recursively explore its contents, including\nmethods, classmethods, staticmethods, properties, and nested classes.\n\n    >>> finder = doctest.DocTestFinder()\n    >>> tests = finder.find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nNew-style classes are also supported:\n\n    >>> tests = finder.find(SampleNewStyleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     1  SampleNewStyleClass\n     1  SampleNewStyleClass.__init__\n     1  SampleNewStyleClass.double\n     1  SampleNewStyleClass.get\n\nFinding Tests in Modules\n~~~~~~~~~~~~~~~~~~~~~~~~\nFor a module, DocTestFinder will create a test for the class's\ndocstring, and will recursively explore its contents, including\nfunctions, classes, and the `__test__` dictionary, if it exists:\n\n    >>> # A module\n    >>> import new\n    >>> m = new.module('some_module')\n    >>> def triple(val):\n    ...     '''\n    ...     >>> print triple(11)\n    ...     33\n    ...     '''\n    ...     return val*3\n    >>> m.__dict__.update({\n    ...     'sample_func': sample_func,\n    ...     'SampleClass': SampleClass,\n    ...     '__doc__': '''\n    ...         Module docstring.\n    ...             >>> print 'module'\n    ...             module\n    ...         ''',\n    ...     '__test__': {\n    ...         'd': '>>> print 6\\n6\\n>>> print 7\\n7\\n',\n    ...         'c': triple}})\n\n    >>> finder = doctest.DocTestFinder()\n    >>> # Use module=test.test_doctest, to prevent doctest from\n    >>> # ignoring the objects since they weren't defined in m.\n    >>> import test.test_doctest\n    >>> tests = finder.find(m, module=test.test_doctest)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     1  some_module\n     3  some_module.SampleClass\n     3  some_module.SampleClass.NestedClass\n     1  some_module.SampleClass.NestedClass.__init__\n     1  some_module.SampleClass.__init__\n     2  some_module.SampleClass.a_classmethod\n     1  some_module.SampleClass.a_property\n     1  some_module.SampleClass.a_staticmethod\n     1  some_module.SampleClass.double\n     1  some_module.SampleClass.get\n     1  some_module.__test__.c\n     2  some_module.__test__.d\n     1  some_module.sample_func\n\nDuplicate Removal\n~~~~~~~~~~~~~~~~~\nIf a single object is listed twice (under different names), then tests\nwill only be generated for it once:\n\n    >>> from test import doctest_aliases\n    >>> tests = excl_empty_finder.find(doctest_aliases)\n    >>> print len(tests)\n    2\n    >>> print tests[0].name\n    test.doctest_aliases.TwoNames\n\n    TwoNames.f and TwoNames.g are bound to the same object.\n    We can't guess which will be found in doctest's traversal of\n    TwoNames.__dict__ first, so we have to allow for either.\n\n    >>> tests[1].name.split('.')[-1] in ['f', 'g']\n    True\n\nEmpty Tests\n~~~~~~~~~~~\nBy default, an object with no doctests doesn't create any tests:\n\n    >>> tests = doctest.DocTestFinder().find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nBy default, that excluded objects with no doctests.  exclude_empty=False\ntells it to include (empty) tests for objects with no doctests.  This feature\nis really to support backward compatibility in what doctest.master.summarize()\ndisplays.\n\n    >>> tests = doctest.DocTestFinder(exclude_empty=False).find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     0  SampleClass.NestedClass.get\n     0  SampleClass.NestedClass.square\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nTurning off Recursion\n~~~~~~~~~~~~~~~~~~~~~\nDocTestFinder can be told not to look for tests in contained objects\nusing the `recurse` flag:\n\n    >>> tests = doctest.DocTestFinder(recurse=False).find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n\nLine numbers\n~~~~~~~~~~~~\nDocTestFinder finds the line number of each example:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...\n    ...     some text\n    ...\n    ...     >>> # examples are not created for comments & bare prompts.\n    ...     >>>\n    ...     ...\n    ...\n    ...     >>> for x in range(10):\n    ...     ...     print x,\n    ...     0 1 2 3 4 5 6 7 8 9\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> [e.lineno for e in test.examples]\n    [1, 9, 12]\n"
