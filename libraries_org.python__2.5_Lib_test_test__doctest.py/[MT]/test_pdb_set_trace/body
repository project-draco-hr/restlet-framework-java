def test_pdb_set_trace():
    'Using pdb.set_trace from a doctest.\n\n    You can use pdb.set_trace from a doctest.  To do so, you must\n    retrieve the set_trace function from the pdb module at the time\n    you use it.  The doctest module changes sys.stdout so that it can\n    capture program output.  It also temporarily replaces pdb.set_trace\n    with a version that restores stdout.  This is necessary for you to\n    see debugger output.\n\n      >>> doc = \'\'\'\n      ... >>> x = 42\n      ... >>> import pdb; pdb.set_trace()\n      ... \'\'\'\n      >>> parser = doctest.DocTestParser()\n      >>> test = parser.get_doctest(doc, {}, "foo", "foo.py", 0)\n      >>> runner = doctest.DocTestRunner(verbose=False)\n\n    To demonstrate this, we\'ll create a fake standard input that\n    captures our debugger input:\n\n      >>> import tempfile\n      >>> real_stdin = sys.stdin\n      >>> sys.stdin = _FakeInput([\n      ...    \'print x\',  # print data defined by the example\n      ...    \'continue\', # stop debugging\n      ...    \'\'])\n\n      >>> try: runner.run(test)\n      ... finally: sys.stdin = real_stdin\n      --Return--\n      > <doctest foo[1]>(1)<module>()->None\n      -> import pdb; pdb.set_trace()\n      (Pdb) print x\n      42\n      (Pdb) continue\n      (0, 2)\n\n      You can also put pdb.set_trace in a function called from a test:\n\n      >>> def calls_set_trace():\n      ...    y=2\n      ...    import pdb; pdb.set_trace()\n\n      >>> doc = \'\'\'\n      ... >>> x=1\n      ... >>> calls_set_trace()\n      ... \'\'\'\n      >>> test = parser.get_doctest(doc, globals(), "foo", "foo.py", 0)\n      >>> real_stdin = sys.stdin\n      >>> sys.stdin = _FakeInput([\n      ...    \'print y\',  # print data defined in the function\n      ...    \'up\',       # out of function\n      ...    \'print x\',  # print data defined by the example\n      ...    \'continue\', # stop debugging\n      ...    \'\'])\n\n      >>> try:\n      ...     runner.run(test)\n      ... finally:\n      ...     sys.stdin = real_stdin\n      --Return--\n      > <doctest test.test_doctest.test_pdb_set_trace[8]>(3)calls_set_trace()->None\n      -> import pdb; pdb.set_trace()\n      (Pdb) print y\n      2\n      (Pdb) up\n      > <doctest foo[1]>(1)<module>()\n      -> calls_set_trace()\n      (Pdb) print x\n      1\n      (Pdb) continue\n      (0, 2)\n\n    During interactive debugging, source code is shown, even for\n    doctest examples:\n\n      >>> doc = \'\'\'\n      ... >>> def f(x):\n      ... ...     g(x*2)\n      ... >>> def g(x):\n      ... ...     print x+3\n      ... ...     import pdb; pdb.set_trace()\n      ... >>> f(3)\n      ... \'\'\'\n      >>> test = parser.get_doctest(doc, globals(), "foo", "foo.py", 0)\n      >>> real_stdin = sys.stdin\n      >>> sys.stdin = _FakeInput([\n      ...    \'list\',     # list source from example 2\n      ...    \'next\',     # return from g()\n      ...    \'list\',     # list source from example 1\n      ...    \'next\',     # return from f()\n      ...    \'list\',     # list source from example 3\n      ...    \'continue\', # stop debugging\n      ...    \'\'])\n      >>> try: runner.run(test)\n      ... finally: sys.stdin = real_stdin\n      ... # doctest: +NORMALIZE_WHITESPACE\n      --Return--\n      > <doctest foo[1]>(3)g()->None\n      -> import pdb; pdb.set_trace()\n      (Pdb) list\n        1     def g(x):\n        2         print x+3\n        3  ->     import pdb; pdb.set_trace()\n      [EOF]\n      (Pdb) next\n      --Return--\n      > <doctest foo[0]>(2)f()->None\n      -> g(x*2)\n      (Pdb) list\n        1     def f(x):\n        2  ->     g(x*2)\n      [EOF]\n      (Pdb) next\n      --Return--\n      > <doctest foo[2]>(1)<module>()->None\n      -> f(3)\n      (Pdb) list\n        1  -> f(3)\n      [EOF]\n      (Pdb) continue\n      **********************************************************************\n      File "foo.py", line 7, in foo\n      Failed example:\n          f(3)\n      Expected nothing\n      Got:\n          9\n      (1, 3)\n      '
