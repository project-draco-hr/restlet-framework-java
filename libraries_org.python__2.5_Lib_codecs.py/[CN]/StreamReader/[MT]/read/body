def read(self, size=(-1), chars=(-1), firstline=False):
    ' Decodes data from the stream self.stream and returns the\n            resulting object.\n\n            chars indicates the number of characters to read from the\n            stream. read() will never return more than chars\n            characters, but it might return less, if there are not enough\n            characters available.\n\n            size indicates the approximate maximum number of bytes to\n            read from the stream for decoding purposes. The decoder\n            can modify this setting as appropriate. The default value\n            -1 indicates to read and decode as much as possible.  size\n            is intended to prevent having to decode huge files in one\n            step.\n\n            If firstline is true, and a UnicodeDecodeError happens\n            after the first line terminator in the input only the first line\n            will be returned, the rest of the input will be kept until the\n            next call to read().\n\n            The method should use a greedy read strategy meaning that\n            it should read as much data as is allowed within the\n            definition of the encoding and the given size, e.g.  if\n            optional encoding endings or state markers are available\n            on the stream, these should be read too.\n        '
    if self.linebuffer:
        self.charbuffer = ''.join(self.linebuffer)
        self.linebuffer = None
    while True:
        if (chars < 0):
            if (size < 0):
                if self.charbuffer:
                    break
            elif (len(self.charbuffer) >= size):
                break
        elif (len(self.charbuffer) >= chars):
            break
        if (size < 0):
            newdata = self.stream.read()
        else:
            newdata = self.stream.read(size)
        data = (self.bytebuffer + newdata)
        try:
            (newchars, decodedbytes) = self.decode(data, self.errors)
        except UnicodeDecodeError as exc:
            if firstline:
                (newchars, decodedbytes) = self.decode(data[:exc.start], self.errors)
                lines = newchars.splitlines(True)
                if (len(lines) <= 1):
                    raise
            else:
                raise
        self.bytebuffer = data[decodedbytes:]
        self.charbuffer += newchars
        if (not newdata):
            break
    if (chars < 0):
        result = self.charbuffer
        self.charbuffer = ''
    else:
        result = self.charbuffer[:chars]
        self.charbuffer = self.charbuffer[chars:]
    return result
