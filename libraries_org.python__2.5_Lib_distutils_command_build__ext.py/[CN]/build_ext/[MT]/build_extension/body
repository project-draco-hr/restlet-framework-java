def build_extension(self, ext):
    sources = ext.sources
    if ((sources is None) or (type(sources) not in (ListType, TupleType))):
        raise DistutilsSetupError, ((("in 'ext_modules' option (extension '%s'), " + "'sources' must be present and must be ") + 'a list of source filenames') % ext.name)
    sources = list(sources)
    fullname = self.get_ext_fullname(ext.name)
    if self.inplace:
        modpath = string.split(fullname, '.')
        package = string.join(modpath[0:(-1)], '.')
        base = modpath[(-1)]
        build_py = self.get_finalized_command('build_py')
        package_dir = build_py.get_package_dir(package)
        ext_filename = os.path.join(package_dir, self.get_ext_filename(base))
    else:
        ext_filename = os.path.join(self.build_lib, self.get_ext_filename(fullname))
    depends = (sources + ext.depends)
    if (not (self.force or newer_group(depends, ext_filename, 'newer'))):
        log.debug("skipping '%s' extension (up-to-date)", ext.name)
        return
    else:
        log.info("building '%s' extension", ext.name)
    sources = self.swig_sources(sources, ext)
    extra_args = (ext.extra_compile_args or [])
    macros = ext.define_macros[:]
    for undef in ext.undef_macros:
        macros.append((undef,))
    objects = self.compiler.compile(sources, output_dir=self.build_temp, macros=macros, include_dirs=ext.include_dirs, debug=self.debug, extra_postargs=extra_args, depends=ext.depends)
    self._built_objects = objects[:]
    if ext.extra_objects:
        objects.extend(ext.extra_objects)
    extra_args = (ext.extra_link_args or [])
    language = (ext.language or self.compiler.detect_language(sources))
    self.compiler.link_shared_object(objects, ext_filename, libraries=self.get_libraries(ext), library_dirs=ext.library_dirs, runtime_library_dirs=ext.runtime_library_dirs, extra_postargs=extra_args, export_symbols=self.get_export_symbols(ext), debug=self.debug, build_temp=self.build_temp, target_lang=language)
