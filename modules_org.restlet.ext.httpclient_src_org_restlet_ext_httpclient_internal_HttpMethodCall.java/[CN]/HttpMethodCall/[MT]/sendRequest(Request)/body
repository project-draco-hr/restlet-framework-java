{
  Status result=null;
  try {
    final Representation entity=request.getEntity();
    for (    Parameter header : getRequestHeaders()) {
      if (!header.getName().equals(HttpConstants.HEADER_CONTENT_LENGTH)) {
        getHttpRequest().addHeader(header.getName(),header.getValue());
      }
    }
    if ((entity != null) && (getHttpRequest() instanceof HttpEntityEnclosingRequestBase)) {
      final HttpEntityEnclosingRequestBase eem=(HttpEntityEnclosingRequestBase)getHttpRequest();
      eem.setEntity(new AbstractHttpEntity(){
        public long getContentLength(){
          return entity.getSize();
        }
        public Header getContentType(){
          return new BasicHeader(HttpConstants.HEADER_CONTENT_TYPE,(entity.getMediaType() != null) ? entity.getMediaType().toString() : null);
        }
        public InputStream getContent() throws IOException, IllegalStateException {
          return entity.getStream();
        }
        public boolean isStreaming(){
          return (entity.getSize() == Representation.UNKNOWN_SIZE);
        }
        public void writeTo(        OutputStream os) throws IOException {
          entity.write(os);
        }
        public boolean isRepeatable(){
          return !entity.isTransient();
        }
      }
);
    }
    this.httpResponse=this.clientHelper.getHttpClient().execute(getHttpRequest());
    result=new Status(getStatusCode(),null,getReasonPhrase(),null);
  }
 catch (  IOException ioe) {
    this.clientHelper.getLogger().log(Level.WARNING,"An error occurred during the communication with the remote HTTP server.",ioe);
    result=new Status(Status.CONNECTOR_ERROR_COMMUNICATION,ioe);
    getHttpRequest().abort();
  }
  return result;
}
