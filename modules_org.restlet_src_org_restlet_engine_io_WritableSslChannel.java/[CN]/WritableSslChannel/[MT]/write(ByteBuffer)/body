{
  int result=0;
  flush();
  if (getPacketBufferState() == BufferState.FILLING) {
    int srcSize=src.remaining();
    if (srcSize > 0) {
      SSLEngineResult sslResult=getManager().getEngine().wrap(src,getPacketBuffer());
      if (Context.getCurrentLogger().isLoggable(Level.INFO)) {
        Context.getCurrentLogger().log(Level.INFO,"SSL I/O result" + sslResult);
      }
      result=srcSize - src.remaining();
      getPacketBuffer().flip();
      int remaining=getPacketBuffer().remaining();
      if (remaining > 0) {
        setPacketBufferState(BufferState.DRAINING);
        flush();
      }
 else {
        getPacketBuffer().clear();
      }
switch (sslResult.getStatus()) {
case BUFFER_OVERFLOW:
        break;
case BUFFER_UNDERFLOW:
      break;
case CLOSED:
    break;
case OK:
switch (sslResult.getHandshakeStatus()) {
case FINISHED:
    break;
case NEED_TASK:
  break;
case NEED_UNWRAP:
getConnection().getOutboundWay().setIoState(IoState.IDLE);
getConnection().getInboundWay().setIoState(IoState.INTEREST);
break;
case NEED_WRAP:
break;
case NOT_HANDSHAKING:
break;
}
break;
}
}
}
return result;
}
