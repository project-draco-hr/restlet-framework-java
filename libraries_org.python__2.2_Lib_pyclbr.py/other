"Parse a Python file and retrieve classes and methods.\n\nParse enough of a Python file to recognize class and method\ndefinitions and to find out the superclasses of a class.\n\nThe interface consists of a single function:\n        readmodule(module, path)\nmodule is the name of a Python module, path is an optional list of\ndirectories where the module is to be searched.  If present, path is\nprepended to the system search path sys.path.\nThe return value is a dictionary.  The keys of the dictionary are\nthe names of the classes defined in the module (including classes\nthat are defined via the from XXX import YYY construct).  The values\nare class instances of the class Class defined here.\n\nA class is described by the class Class in this module.  Instances\nof this class have the following instance variables:\n        name -- the name of the class\n        super -- a list of super classes (Class instances)\n        methods -- a dictionary of methods\n        file -- the file in which the class was defined\n        lineno -- the line in the file on which the class statement occurred\nThe dictionary of methods uses the method names as keys and the line\nnumbers on which the method was defined as values.\nIf the name of a super class is not recognized, the corresponding\nentry in the list of super classes is not a class instance but a\nstring giving the name of the super class.  Since import statements\nare recognized and imported modules are scanned as well, this\nshouldn't happen often.\n\nBUGS\n- Continuation lines are not dealt with at all, except inside strings.\n- Nested classes and functions can confuse it.\n- Code that doesn't pass tabnanny or python -t will confuse it, unless\n  you set the module TABWIDTH vrbl (default 8) to the correct tab width\n  for the file.\n\nPACKAGE RELATED BUGS\n- If you have a package and a module inside that or another package\n  with the same name, module caching doesn't work properly since the\n  key is the base name of the module/package.\n- The only entry that is returned when you readmodule a package is a\n  __path__ whose value is a list which confuses certain class browsers.\n- When code does:\n  from package import subpackage\n  class MyClass(subpackage.SuperClass):\n    ...\n  It can't locate the parent.  It probably needs to have the same\n  hairy logic that the import locator already does.  (This logic\n  exists coded in Python in the freeze package.)\n"
import sys
import imp
import re
import string
__all__ = ['readmodule']
TABWIDTH = 8
_getnext = re.compile('\n    (?P<String>\n       \\""" [^"\\\\]* (?:\n                        (?: \\\\. | "(?!"") )\n                        [^"\\\\]*\n                    )*\n       \\"""\n\n    |   \'\'\' [^\'\\\\]* (?:\n                        (?: \\\\. | \'(?!\'\') )\n                        [^\'\\\\]*\n                    )*\n        \'\'\'\n\n    |   " [^"\\\\\\n]* (?: \\\\. [^"\\\\\\n]*)* "\n\n    |   \' [^\'\\\\\\n]* (?: \\\\. [^\'\\\\\\n]*)* \'\n    )\n\n|   (?P<Method>\n        ^\n        (?P<MethodIndent> [ \\t]* )\n        def [ \\t]+\n        (?P<MethodName> [a-zA-Z_] \\w* )\n        [ \\t]* \\(\n    )\n\n|   (?P<Class>\n        ^\n        (?P<ClassIndent> [ \\t]* )\n        class [ \\t]+\n        (?P<ClassName> [a-zA-Z_] \\w* )\n        [ \\t]*\n        (?P<ClassSupers> \\( [^)\\n]* \\) )?\n        [ \\t]* :\n    )\n\n|   (?P<Import>\n        ^ import [ \\t]+\n        (?P<ImportList> [^#;\\n]+ )\n    )\n\n|   (?P<ImportFrom>\n        ^ from [ \\t]+\n        (?P<ImportFromPath>\n            [a-zA-Z_] \\w*\n            (?:\n                [ \\t]* \\. [ \\t]* [a-zA-Z_] \\w*\n            )*\n        )\n        [ \\t]+\n        import [ \\t]+\n        (?P<ImportFromList> [^#;\\n]+ )\n    )\n', ((re.VERBOSE | re.DOTALL) | re.MULTILINE)).search
_modules = {}
