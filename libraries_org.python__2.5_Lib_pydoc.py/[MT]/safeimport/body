def safeimport(path, forceload=0, cache={}):
    "Import a module; handle errors; return None if the module isn't found.\n\n    If the module *is* found but an exception occurs, it's wrapped in an\n    ErrorDuringImport exception and reraised.  Unlike __import__, if a\n    package path is specified, the module at the end of the path is returned,\n    not the package at the beginning.  If the optional 'forceload' argument\n    is 1, we reload the module from disk (unless it's a dynamic extension)."
    try:
        if (forceload and (path in sys.modules)):
            if (path not in sys.builtin_module_names):
                subs = [m for m in sys.modules if m.startswith((path + '.'))]
                for key in ([path] + subs):
                    cache[key] = sys.modules[key]
                    del sys.modules[key]
        module = __import__(path)
    except:
        (exc, value, tb) = info = sys.exc_info()
        if (path in sys.modules):
            raise ErrorDuringImport(sys.modules[path].__file__, info)
        elif (exc is SyntaxError):
            raise ErrorDuringImport(value.filename, info)
        elif ((exc is ImportError) and (split(lower(str(value)))[:2] == ['no', 'module'])):
            return None
        else:
            raise ErrorDuringImport(path, sys.exc_info())
    for part in split(path, '.')[1:]:
        try:
            module = getattr(module, part)
        except AttributeError:
            return None
    return module
