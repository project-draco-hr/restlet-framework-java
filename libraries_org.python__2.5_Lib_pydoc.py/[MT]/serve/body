def serve(port, callback=None, completer=None):
    import BaseHTTPServer, mimetools, select


    class Message(mimetools.Message):

        def __init__(self, fp, seekable=1):
            Message = self.__class__
            Message.__bases__[0].__bases__[0].__init__(self, fp, seekable)
            self.encodingheader = self.getheader('content-transfer-encoding')
            self.typeheader = self.getheader('content-type')
            self.parsetype()
            self.parseplist()


    class DocHandler(BaseHTTPServer.BaseHTTPRequestHandler):

        def send_document(self, title, contents):
            try:
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.end_headers()
                self.wfile.write(html.page(title, contents))
            except IOError:
                pass

        def do_GET(self):
            path = self.path
            if (path[(-5):] == '.html'):
                path = path[:(-5)]
            if (path[:1] == '/'):
                path = path[1:]
            if (path and (path != '.')):
                try:
                    obj = locate(path, forceload=1)
                except ErrorDuringImport as value:
                    self.send_document(path, html.escape(str(value)))
                    return
                if obj:
                    self.send_document(describe(obj), html.document(obj, path))
                else:
                    self.send_document(path, ('no Python documentation found for %s' % repr(path)))
            else:
                heading = html.heading('<big><big><strong>Python: Index of Modules</strong></big></big>', '#ffffff', '#7799ee')

                def bltinlink(name):
                    return ('<a href="%s.html">%s</a>' % (name, name))
                names = filter((lambda x: (x != '__main__')), sys.builtin_module_names)
                contents = html.multicolumn(names, bltinlink)
                indices = [('<p>' + html.bigsection('Built-in Modules', '#ffffff', '#ee77aa', contents))]
                seen = {}
                for dir in sys.path:
                    indices.append(html.index(dir, seen))
                contents = ((heading + join(indices)) + '<p align=right>\n<font color="#909090" face="helvetica, arial"><strong>\npydoc</strong> by Ka-Ping Yee &lt;ping@lfw.org&gt;</font>')
                self.send_document('Index of Modules', contents)

        def log_message(self, *args):
            pass


    class DocServer(BaseHTTPServer.HTTPServer):

        def __init__(self, port, callback):
            host = (((sys.platform == 'mac') and '127.0.0.1') or 'localhost')
            self.address = ('', port)
            self.url = ('http://%s:%d/' % (host, port))
            self.callback = callback
            self.base.__init__(self, self.address, self.handler)

        def serve_until_quit(self):
            import sys
            if sys.platform.startswith('java'):
                from select import cpython_compatible_select as select
            else:
                from select import select
            self.quit = False
            while (not self.quit):
                (rd, wr, ex) = select([self.socket], [], [], 1)
                if rd:
                    self.handle_request()

        def server_activate(self):
            self.base.server_activate(self)
            if self.callback:
                self.callback(self)
    DocServer.base = BaseHTTPServer.HTTPServer
    DocServer.handler = DocHandler
    DocHandler.MessageClass = Message
    try:
        try:
            DocServer(port, callback).serve_until_quit()
        except (KeyboardInterrupt, select.error):
            pass
    finally:
        if completer:
            completer()
