def parse_starttag(self, i):
    self.__starttag_text = None
    endpos = self.check_for_whole_start_tag(i)
    if (endpos < 0):
        return endpos
    rawdata = self.rawdata
    self.__starttag_text = rawdata[i:endpos]
    attrs = []
    match = tagfind.match(rawdata, (i + 1))
    assert match, 'unexpected call to parse_starttag()'
    k = match.end()
    self.lasttag = tag = rawdata[(i + 1):k].lower()
    while (k < endpos):
        m = attrfind.match(rawdata, k)
        if (not m):
            break
        (attrname, rest, attrvalue) = m.group(1, 2, 3)
        if (not rest):
            attrvalue = None
        elif ((attrvalue[:1] == "'" == attrvalue[(-1):]) or (attrvalue[:1] == '"' == attrvalue[(-1):])):
            attrvalue = attrvalue[1:(-1)]
            attrvalue = self.unescape(attrvalue)
        attrs.append((attrname.lower(), attrvalue))
        k = m.end()
    end = rawdata[k:endpos].strip()
    if (end not in ('>', '/>')):
        (lineno, offset) = self.getpos()
        if ('\n' in self.__starttag_text):
            lineno = (lineno + self.__starttag_text.count('\n'))
            offset = (len(self.__starttag_text) - self.__starttag_text.rfind('\n'))
        else:
            offset = (offset + len(self.__starttag_text))
        self.error(('junk characters in start tag: %s' % `rawdata[k:endpos][:20]`))
    if end.endswith('/>'):
        self.handle_startendtag(tag, attrs)
    else:
        self.handle_starttag(tag, attrs)
        if (tag in self.CDATA_CONTENT_ELEMENTS):
            self.set_cdata_mode()
    return endpos
