{
  int result=0;
  boolean tryAgain=true;
  while (tryAgain) {
    if (Context.getCurrentLogger().isLoggable(Level.FINER)) {
      Context.getCurrentLogger().log(Level.FINER,"Chunk state: " + this.chunkState);
    }
switch (this.chunkState) {
case SIZE:
      if (refill()) {
        try {
          int length=getLineBuilder().length();
          if (length == 0) {
            throw new IOException("An empty chunk size line was detected");
          }
          int index=getLineBuilder().indexOf(";");
          index=(index == -1) ? getLineBuilder().length() : index;
          this.remainingChunkSize=Long.parseLong(getLineBuilder().substring(0,index).trim(),16);
          if (Context.getCurrentLogger().isLoggable(Level.FINER)) {
            Context.getCurrentLogger().log(Level.FINER,"New chunk detected. Size: " + this.remainingChunkSize);
          }
        }
 catch (        NumberFormatException ex) {
          throw new IOException("\"" + getLineBuilder() + "\" has an invalid chunk size");
        }
 finally {
          clearLineBuilder();
        }
        if (this.remainingChunkSize == 0) {
          this.chunkState=ChunkState.TRAILER;
        }
 else {
          this.chunkState=ChunkState.DATA;
        }
      }
 else {
        tryAgain=false;
      }
    break;
case DATA:
  if (this.remainingChunkSize > 0) {
    if (this.remainingChunkSize < dst.remaining()) {
      dst.limit((int)(this.remainingChunkSize + dst.position()));
    }
    result=getWrappedChannel().read(dst);
    tryAgain=false;
    if (result > 0) {
      this.remainingChunkSize-=result;
    }
 else {
      if (Context.getCurrentLogger().isLoggable(Level.FINE)) {
        Context.getCurrentLogger().fine("No chunk data read");
      }
    }
  }
 else   if (this.remainingChunkSize == 0) {
    if (refill()) {
      clearLineBuilder();
      this.chunkState=ChunkState.SIZE;
    }
 else {
      tryAgain=false;
    }
  }
break;
case TRAILER:
this.chunkState=ChunkState.END;
break;
case END:
if (refill()) {
if (getLineBuilder().length() != 0) {
Context.getCurrentLogger().log(Level.FINE,"The last chunk line had a non empty line");
}
tryAgain=false;
result=-1;
}
 else {
tryAgain=false;
}
break;
}
}
if ((result == -1) && (getWrappedChannel() instanceof ReadableBufferedChannel)) {
((ReadableBufferedChannel)getWrappedChannel()).onCompleted(false);
}
return result;
}
