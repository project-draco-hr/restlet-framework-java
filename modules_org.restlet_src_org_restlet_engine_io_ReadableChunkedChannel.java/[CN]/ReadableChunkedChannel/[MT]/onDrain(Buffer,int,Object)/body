{
  int result=0;
  ByteBuffer targetBuffer=(ByteBuffer)args[0];
  boolean doLoop=true;
  while (doLoop) {
    if (Context.getCurrentLogger().isLoggable(Level.FINER)) {
      Context.getCurrentLogger().log(Level.FINER,"Chunk state: " + getChunkState());
    }
switch (getChunkState()) {
case SIZE:
      setLineBuilderState(buffer.drain(getLineBuilder(),getLineBuilderState()));
    if (getLineBuilderState() == BufferState.DRAINING) {
      int length=getLineBuilder().length();
      if (length == 0) {
        throw new IOException("An empty chunk size line was detected");
      }
      int index=getLineBuilder().indexOf(";");
      index=(index == -1) ? getLineBuilder().length() : index;
      try {
        setRemainingChunkSize(Integer.parseInt(getLineBuilder().substring(0,index).trim(),16));
        if (Context.getCurrentLogger().isLoggable(Level.FINER)) {
          Context.getCurrentLogger().log(Level.FINER,"New chunk detected. Size: " + this.remainingChunkSize);
        }
      }
 catch (      NumberFormatException ex) {
        throw new IOException("\"" + getLineBuilder() + "\" has an invalid chunk size");
      }
 finally {
        clearLineBuilder();
      }
      if (getRemainingChunkSize() == 0) {
        setChunkState(ChunkState.TRAILER);
      }
 else {
        setChunkState(ChunkState.DATA);
      }
      break;
    }
 else {
      doLoop=false;
    }
  break;
case DATA:
int read=0;
if (getRemainingChunkSize() > 0) {
read=super.onDrain(buffer,this.remainingChunkSize,targetBuffer);
result+=read;
if (read > 0) {
  setRemainingChunkSize(getRemainingChunkSize() - read);
}
 else {
  if (Context.getCurrentLogger().isLoggable(Level.FINER)) {
    Context.getCurrentLogger().finer("No chunk data read");
  }
}
}
if (getRemainingChunkSize() == 0) {
setLineBuilderState(buffer.drain(getLineBuilder(),getLineBuilderState()));
if (getLineBuilderState() == BufferState.DRAINING) {
setChunkState(ChunkState.SIZE);
clearLineBuilder();
}
 else {
doLoop=false;
}
}
 else {
doLoop=false;
}
break;
case TRAILER:
setChunkState(ChunkState.END);
break;
case END:
setLineBuilderState(buffer.drain(getLineBuilder(),getLineBuilderState()));
if (getLineBuilderState() == BufferState.DRAINING) {
if (getLineBuilder().length() != 0) {
Context.getCurrentLogger().log(Level.FINE,"The last chunk line had a non empty line");
}
setEndReached(true);
result=-1;
doLoop=false;
}
 else {
doLoop=false;
}
break;
}
}
return result;
}
