from test.test_support import TestFailed, verbose, verify, vereq, is_jython
import test.test_support
import struct
import array
import warnings
if is_jython:

    def buffer(s):
        return str(s)
import sys
ISBIGENDIAN = (sys.byteorder == 'big')
del sys
verify(((struct.pack('=i', 1)[0] == chr(0)) == ISBIGENDIAN), 'bigendian determination appears wrong')
try:
    import _struct
except ImportError:
    PY_STRUCT_RANGE_CHECKING = 0
    PY_STRUCT_OVERFLOW_MASKING = 1
    PY_STRUCT_FLOAT_COERCE = 2
else:
    PY_STRUCT_RANGE_CHECKING = getattr(_struct, '_PY_STRUCT_RANGE_CHECKING', 0)
    PY_STRUCT_OVERFLOW_MASKING = getattr(_struct, '_PY_STRUCT_OVERFLOW_MASKING', 0)
    PY_STRUCT_FLOAT_COERCE = getattr(_struct, '_PY_STRUCT_FLOAT_COERCE', 0)
deprecated_err = with_warning_restore(deprecated_err)
simple_err(struct.calcsize, 'Z')
sz = struct.calcsize('i')
if ((sz * 3) != struct.calcsize('iii')):
    raise TestFailed, 'inconsistent sizes'
fmt = 'cbxxxxxxhhhhiillffd'
fmt3 = '3c3b18x12h6i6l6f3d'
sz = struct.calcsize(fmt)
sz3 = struct.calcsize(fmt3)
if ((sz * 3) != sz3):
    raise TestFailed, ('inconsistent sizes (3*%r -> 3*%d = %d, %r -> %d)' % (fmt, sz, (3 * sz), fmt3, sz3))
simple_err(struct.pack, 'iii', 3)
simple_err(struct.pack, 'i', 3, 3, 3)
simple_err(struct.pack, 'i', 'foo')
simple_err(struct.pack, 'P', 'foo')
simple_err(struct.unpack, 'd', 'flap')
s = struct.pack('ii', 1, 2)
simple_err(struct.unpack, 'iii', s)
simple_err(struct.unpack, 'i', s)
c = 'a'
b = 1
h = 255
i = 65535
l = 65536
f = 3.1415
d = 3.1415
for prefix in ('', '@', '<', '>', '=', '!'):
    for format in ('xcbhilfd', 'xcBHILfd'):
        format = (prefix + format)
        if verbose:
            print 'trying:', format
        s = struct.pack(format, c, b, h, i, l, f, d)
        (cp, bp, hp, ip, lp, fp, dp) = struct.unpack(format, s)
        if ((cp != c) or (bp != b) or (hp != h) or (ip != i) or (lp != l) or (int((100 * fp)) != int((100 * f))) or (int((100 * dp)) != int((100 * d)))):
            raise TestFailed, ('unpack/pack not transitive (%s, %s)' % (str(format), str((cp, bp, hp, ip, lp, fp, dp))))
tests = [('c', 'a', 'a', 'a', 0), ('xc', 'a', '\x00a', '\x00a', 0), ('cx', 'a', 'a\x00', 'a\x00', 0), ('s', 'a', 'a', 'a', 0), ('0s', 'helloworld', '', '', 1), ('1s', 'helloworld', 'h', 'h', 1), ('9s', 'helloworld', 'helloworl', 'helloworl', 1), ('10s', 'helloworld', 'helloworld', 'helloworld', 0), ('11s', 'helloworld', 'helloworld\x00', 'helloworld\x00', 1), ('20s', 'helloworld', ('helloworld' + (10 * '\x00')), ('helloworld' + (10 * '\x00')), 1), ('b', 7, '\x07', '\x07', 0), ('b', (-7), '\xf9', '\xf9', 0), ('B', 7, '\x07', '\x07', 0), ('B', 249, '\xf9', '\xf9', 0), ('h', 700, '\x02\xbc', '\xbc\x02', 0), ('h', (-700), '\xfdD', 'D\xfd', 0), ('H', 700, '\x02\xbc', '\xbc\x02', 0), ('H', (65536 - 700), '\xfdD', 'D\xfd', 0), ('i', 70000000, '\x04,\x1d\x80', '\x80\x1d,\x04', 0), ('i', (-70000000), '\xfb\xd3\xe2\x80', '\x80\xe2\xd3\xfb', 0), ('I', 70000000L, '\x04,\x1d\x80', '\x80\x1d,\x04', 0), ('I', (4294967296L - 70000000), '\xfb\xd3\xe2\x80', '\x80\xe2\xd3\xfb', 0), ('l', 70000000, '\x04,\x1d\x80', '\x80\x1d,\x04', 0), ('l', (-70000000), '\xfb\xd3\xe2\x80', '\x80\xe2\xd3\xfb', 0), ('L', 70000000L, '\x04,\x1d\x80', '\x80\x1d,\x04', 0), ('L', (4294967296L - 70000000), '\xfb\xd3\xe2\x80', '\x80\xe2\xd3\xfb', 0), ('f', 2.0, '@\x00\x00\x00', '\x00\x00\x00@', 0), ('d', 2.0, '@\x00\x00\x00\x00\x00\x00\x00', '\x00\x00\x00\x00\x00\x00\x00@', 0), ('f', (-2.0), '\xc0\x00\x00\x00', '\x00\x00\x00\xc0', 0), ('d', (-2.0), '\xc0\x00\x00\x00\x00\x00\x00\x00', '\x00\x00\x00\x00\x00\x00\x00\xc0', 0)]
for (fmt, arg, big, lil, asy) in tests:
    if verbose:
        print ('%r %r %r %r' % (fmt, arg, big, lil))
    for (xfmt, exp) in [(('>' + fmt), big), (('!' + fmt), big), (('<' + fmt), lil), (('=' + fmt), ((ISBIGENDIAN and big) or lil))]:
        res = struct.pack(xfmt, arg)
        if (res != exp):
            raise TestFailed, ('pack(%r, %r) -> %r # expected %r' % (fmt, arg, res, exp))
        n = struct.calcsize(xfmt)
        if (n != len(res)):
            raise TestFailed, ('calcsize(%r) -> %d # expected %d' % (xfmt, n, len(res)))
        rev = struct.unpack(xfmt, res)[0]
        if ((rev != arg) and (not asy)):
            raise TestFailed, ('unpack(%r, %r) -> (%r,) # expected (%r,)' % (fmt, res, rev, arg))
has_native_qQ = 1
try:
    struct.pack('q', 5)
except struct.error:
    has_native_qQ = 0
if verbose:
    print 'Platform has native q/Q?', ((has_native_qQ and 'Yes.') or 'No.')
any_err(struct.pack, 'Q', (-1))
simple_err(struct.pack, 'q', 'a')
simple_err(struct.pack, 'Q', 'a')
if has_native_qQ:
    test_native_qQ()
import binascii
for args in [('bB', 1), ('hH', 2), ('iI', 4), ('lL', 4), ('qQ', 8)]:
    t = IntTester(*args)
    t.run()
test_p_code()
test_705836()
if PY_STRUCT_RANGE_CHECKING:
    test_1229380()
check_float_coerce = with_warning_restore(deprecated_err)
test_1530559()
test_unpack_from()
test_pack_into()
test_pack_into_fn()
test_unpack_with_buffer()
