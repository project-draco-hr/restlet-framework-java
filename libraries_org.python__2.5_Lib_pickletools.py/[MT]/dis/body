def dis(pickle, out=None, memo=None, indentlevel=4):
    'Produce a symbolic disassembly of a pickle.\n\n    \'pickle\' is a file-like object, or string, containing a (at least one)\n    pickle.  The pickle is disassembled from the current position, through\n    the first STOP opcode encountered.\n\n    Optional arg \'out\' is a file-like object to which the disassembly is\n    printed.  It defaults to sys.stdout.\n\n    Optional arg \'memo\' is a Python dict, used as the pickle\'s memo.  It\n    may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.\n    Passing the same memo object to another dis() call then allows disassembly\n    to proceed across multiple pickles that were all created by the same\n    pickler with the same memo.  Ordinarily you don\'t need to worry about this.\n\n    Optional arg indentlevel is the number of blanks by which to indent\n    a new MARK level.  It defaults to 4.\n\n    In addition to printing the disassembly, some sanity checks are made:\n\n    + All embedded opcode arguments "make sense".\n\n    + Explicit and implicit pop operations have enough items on the stack.\n\n    + When an opcode implicitly refers to a markobject, a markobject is\n      actually on the stack.\n\n    + A memo entry isn\'t referenced before it\'s defined.\n\n    + The markobject isn\'t stored in the memo.\n\n    + A memo entry isn\'t redefined.\n    '
    stack = []
    if (memo is None):
        memo = {}
    maxproto = (-1)
    markstack = []
    indentchunk = (' ' * indentlevel)
    errormsg = None
    for (opcode, arg, pos) in genops(pickle):
        if (pos is not None):
            print  >> out, ('%5d:' % pos),
        line = ('%-4s %s%s' % (repr(opcode.code)[1:(-1)], (indentchunk * len(markstack)), opcode.name))
        maxproto = max(maxproto, opcode.proto)
        before = opcode.stack_before
        after = opcode.stack_after
        numtopop = len(before)
        markmsg = None
        if ((markobject in before) or ((opcode.name == 'POP') and stack and (stack[(-1)] is markobject))):
            assert (markobject not in after)
            if __debug__:
                if (markobject in before):
                    assert (before[(-1)] is stackslice)
            if markstack:
                markpos = markstack.pop()
                if (markpos is None):
                    markmsg = '(MARK at unknown opcode offset)'
                else:
                    markmsg = ('(MARK at %d)' % markpos)
                while (stack[(-1)] is not markobject):
                    stack.pop()
                stack.pop()
                try:
                    numtopop = before.index(markobject)
                except ValueError:
                    assert (opcode.name == 'POP')
                    numtopop = 0
            else:
                errormsg = markmsg = 'no MARK exists on stack'
        if (opcode.name in ('PUT', 'BINPUT', 'LONG_BINPUT')):
            assert (arg is not None)
            if (arg in memo):
                errormsg = ('memo key %r already defined' % arg)
            elif (not stack):
                errormsg = "stack is empty -- can't store into memo"
            elif (stack[(-1)] is markobject):
                errormsg = "can't store markobject in the memo"
            else:
                memo[arg] = stack[(-1)]
        elif (opcode.name in ('GET', 'BINGET', 'LONG_BINGET')):
            if (arg in memo):
                assert (len(after) == 1)
                after = [memo[arg]]
            else:
                errormsg = ('memo key %r has never been stored into' % arg)
        if ((arg is not None) or markmsg):
            line += (' ' * (10 - len(opcode.name)))
            if (arg is not None):
                line += (' ' + repr(arg))
            if markmsg:
                line += (' ' + markmsg)
        print  >> out, line
        if errormsg:
            raise ValueError(errormsg)
        if (len(stack) < numtopop):
            raise ValueError(('tries to pop %d items from stack with only %d items' % (numtopop, len(stack))))
        if numtopop:
            del stack[(- numtopop):]
        if (markobject in after):
            assert (markobject not in before)
            markstack.append(pos)
        stack.extend(after)
    print  >> out, 'highest protocol among opcodes =', maxproto
    if stack:
        raise ValueError(('stack not empty after STOP: %r' % stack))
