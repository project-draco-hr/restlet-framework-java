'Word completion for GNU readline 2.0.\n\nThis requires the latest extension to the readline module. The completer\ncompletes keywords, built-ins and globals in a selectable namespace (which\ndefaults to __main__); when completing NAME.NAME..., it evaluates (!) the\nexpression up to the last dot and completes its attributes.\n\nIt\'s very cool to do "import sys" type "sys.", hit the\ncompletion key (twice), and see the list of names defined by the\nsys module!\n\nTip: to use the tab key as the completion key, call\n\n    readline.parse_and_bind("tab: complete")\n\nNotes:\n\n- Exceptions raised by the completer function are *ignored* (and\ngenerally cause the completion to fail).  This is a feature -- since\nreadline sets the tty device in raw (or cbreak) mode, printing a\ntraceback wouldn\'t work well without some complicated hoopla to save,\nreset and restore the tty state.\n\n- The evaluation of the NAME.NAME... form may cause arbitrary\napplication defined code to be executed if an object with a\n__getattr__ hook is found.  Since it is the responsibility of the\napplication (or the user) to enable this feature, I consider this an\nacceptable risk.  More complicated expressions (e.g. function calls or\nindexing operations) are *not* evaluated.\n\n- GNU readline is also used by the built-in functions input() and\nraw_input(), and thus these also benefit/suffer from the completer\nfeatures.  Clearly an interactive application can benefit by\nspecifying its own completer function and using raw_input() for all\nits input.\n\n- When the original stdin is not a tty device, GNU readline is never\nused, and this module (and the readline module) are silently inactive.\n\n'
import __builtin__
import __main__
__all__ = ['Completer']
try:
    import readline
except ImportError:
    pass
else:
    readline.set_completer(Completer().complete)
