def get_matching_blocks(self):
    'Return list of triples describing matching subsequences.\n\n        Each triple is of the form (i, j, n), and means that\n        a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in\n        i and in j.  New in Python 2.5, it\'s also guaranteed that if\n        (i, j, n) and (i\', j\', n\') are adjacent triples in the list, and\n        the second is not the last triple in the list, then i+n != i\' or\n        j+n != j\'.  IOW, adjacent triples never describe adjacent equal\n        blocks.\n\n        The last triple is a dummy, (len(a), len(b), 0), and is the only\n        triple with n==0.\n\n        >>> s = SequenceMatcher(None, "abxcd", "abcd")\n        >>> s.get_matching_blocks()\n        [(0, 0, 2), (3, 2, 2), (5, 4, 0)]\n        '
    if (self.matching_blocks is not None):
        return self.matching_blocks
    (la, lb) = (len(self.a), len(self.b))
    queue = [(0, la, 0, lb)]
    matching_blocks = []
    while queue:
        (alo, ahi, blo, bhi) = queue.pop()
        (i, j, k) = x = self.find_longest_match(alo, ahi, blo, bhi)
        if k:
            matching_blocks.append(x)
            if ((alo < i) and (blo < j)):
                queue.append((alo, i, blo, j))
            if (((i + k) < ahi) and ((j + k) < bhi)):
                queue.append(((i + k), ahi, (j + k), bhi))
    matching_blocks.sort()
    i1 = j1 = k1 = 0
    non_adjacent = []
    for (i2, j2, k2) in matching_blocks:
        if (((i1 + k1) == i2) and ((j1 + k1) == j2)):
            k1 += k2
        else:
            if k1:
                non_adjacent.append((i1, j1, k1))
            (i1, j1, k1) = (i2, j2, k2)
    if k1:
        non_adjacent.append((i1, j1, k1))
    non_adjacent.append((la, lb, 0))
    self.matching_blocks = non_adjacent
    return self.matching_blocks
