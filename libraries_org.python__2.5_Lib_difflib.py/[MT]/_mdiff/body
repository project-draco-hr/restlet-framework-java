def _mdiff(fromlines, tolines, context=None, linejunk=None, charjunk=IS_CHARACTER_JUNK):
    'Returns generator yielding marked up from/to side by side differences.\n\n    Arguments:\n    fromlines -- list of text lines to compared to tolines\n    tolines -- list of text lines to be compared to fromlines\n    context -- number of context lines to display on each side of difference,\n               if None, all from/to text lines will be generated.\n    linejunk -- passed on to ndiff (see ndiff documentation)\n    charjunk -- passed on to ndiff (see ndiff documentation)\n\n    This function returns an interator which returns a tuple:\n    (from line tuple, to line tuple, boolean flag)\n\n    from/to line tuple -- (line num, line text)\n        line num -- integer or None (to indicate a context seperation)\n        line text -- original line text with following markers inserted:\n            \'\\0+\' -- marks start of added text\n            \'\\0-\' -- marks start of deleted text\n            \'\\0^\' -- marks start of changed text\n            \'\\1\' -- marks end of added/deleted/changed text\n\n    boolean flag -- None indicates context separation, True indicates\n        either "from" or "to" line contains a change, otherwise False.\n\n    This function/iterator was originally developed to generate side by side\n    file difference for making HTML pages (see HtmlDiff class for example\n    usage).\n\n    Note, this function utilizes the ndiff function to generate the side by\n    side difference markup.  Optional ndiff arguments may be passed to this\n    function and they in turn will be passed to ndiff.\n    '
    import re
    change_re = re.compile('(\\++|\\-+|\\^+)')
    diff_lines_iterator = ndiff(fromlines, tolines, linejunk, charjunk)

    def _make_line(lines, format_key, side, num_lines=[0, 0]):
        'Returns line of text with user\'s change markup and line formatting.\n\n        lines -- list of lines from the ndiff generator to produce a line of\n                 text from.  When producing the line of text to return, the\n                 lines used are removed from this list.\n        format_key -- \'+\' return first line in list with "add" markup around\n                          the entire line.\n                      \'-\' return first line in list with "delete" markup around\n                          the entire line.\n                      \'?\' return first line in list with add/delete/change\n                          intraline markup (indices obtained from second line)\n                      None return first line in list with no markup\n        side -- indice into the num_lines list (0=from,1=to)\n        num_lines -- from/to current line number.  This is NOT intended to be a\n                     passed parameter.  It is present as a keyword argument to\n                     maintain memory of the current line numbers between calls\n                     of this function.\n\n        Note, this function is purposefully not defined at the module scope so\n        that data it needs from its parent function (within whose context it\n        is defined) does not need to be of module scope.\n        '
        num_lines[side] += 1
        if (format_key is None):
            return (num_lines[side], lines.pop(0)[2:])
        if (format_key == '?'):
            (text, markers) = (lines.pop(0), lines.pop(0))
            sub_info = []

            def record_sub_info(match_object, sub_info=sub_info):
                sub_info.append([match_object.group(1)[0], match_object.span()])
                return match_object.group(1)
            change_re.sub(record_sub_info, markers)
            for (key, (begin, end)) in sub_info[::(-1)]:
                text = (((((text[0:begin] + '\x00') + key) + text[begin:end]) + '\x01') + text[end:])
            text = text[2:]
        else:
            text = lines.pop(0)[2:]
            if (not text):
                text = ' '
            text = ((('\x00' + format_key) + text) + '\x01')
        return (num_lines[side], text)

    def _line_iterator():
        'Yields from/to lines of text with a change indication.\n\n        This function is an iterator.  It itself pulls lines from a\n        differencing iterator, processes them and yields them.  When it can\n        it yields both a "from" and a "to" line, otherwise it will yield one\n        or the other.  In addition to yielding the lines of from/to text, a\n        boolean flag is yielded to indicate if the text line(s) have\n        differences in them.\n\n        Note, this function is purposefully not defined at the module scope so\n        that data it needs from its parent function (within whose context it\n        is defined) does not need to be of module scope.\n        '
        lines = []
        (num_blanks_pending, num_blanks_to_yield) = (0, 0)
        while True:
            while (len(lines) < 4):
                try:
                    lines.append(diff_lines_iterator.next())
                except StopIteration:
                    lines.append('X')
            s = ''.join([line[0] for line in lines])
            if s.startswith('X'):
                num_blanks_to_yield = num_blanks_pending
            elif s.startswith('-?+?'):
                yield (_make_line(lines, '?', 0), _make_line(lines, '?', 1), True)
                continue
            elif s.startswith('--++'):
                num_blanks_pending -= 1
                yield (_make_line(lines, '-', 0), None, True)
                continue
            elif s.startswith(('--?+', '--+', '- ')):
                (from_line, to_line) = (_make_line(lines, '-', 0), None)
                (num_blanks_to_yield, num_blanks_pending) = ((num_blanks_pending - 1), 0)
            elif s.startswith('-+?'):
                yield (_make_line(lines, None, 0), _make_line(lines, '?', 1), True)
                continue
            elif s.startswith('-?+'):
                yield (_make_line(lines, '?', 0), _make_line(lines, None, 1), True)
                continue
            elif s.startswith('-'):
                num_blanks_pending -= 1
                yield (_make_line(lines, '-', 0), None, True)
                continue
            elif s.startswith('+--'):
                num_blanks_pending += 1
                yield (None, _make_line(lines, '+', 1), True)
                continue
            elif s.startswith(('+ ', '+-')):
                (from_line, to_line) = (None, _make_line(lines, '+', 1))
                (num_blanks_to_yield, num_blanks_pending) = ((num_blanks_pending + 1), 0)
            elif s.startswith('+'):
                num_blanks_pending += 1
                yield (None, _make_line(lines, '+', 1), True)
                continue
            elif s.startswith(' '):
                yield (_make_line(lines[:], None, 0), _make_line(lines, None, 1), False)
                continue
            while (num_blanks_to_yield < 0):
                num_blanks_to_yield += 1
                yield (None, ('', '\n'), True)
            while (num_blanks_to_yield > 0):
                num_blanks_to_yield -= 1
                yield (('', '\n'), None, True)
            if s.startswith('X'):
                raise StopIteration
            else:
                yield (from_line, to_line, True)

    def _line_pair_iterator():
        'Yields from/to lines of text with a change indication.\n\n        This function is an iterator.  It itself pulls lines from the line\n        iterator.  Its difference from that iterator is that this function\n        always yields a pair of from/to text lines (with the change\n        indication).  If necessary it will collect single from/to lines\n        until it has a matching pair from/to pair to yield.\n\n        Note, this function is purposefully not defined at the module scope so\n        that data it needs from its parent function (within whose context it\n        is defined) does not need to be of module scope.\n        '
        line_iterator = _line_iterator()
        (fromlines, tolines) = ([], [])
        while True:
            while ((len(fromlines) == 0) or (len(tolines) == 0)):
                (from_line, to_line, found_diff) = line_iterator.next()
                if (from_line is not None):
                    fromlines.append((from_line, found_diff))
                if (to_line is not None):
                    tolines.append((to_line, found_diff))
            (from_line, fromDiff) = fromlines.pop(0)
            (to_line, to_diff) = tolines.pop(0)
            yield (from_line, to_line, (fromDiff or to_diff))
    line_pair_iterator = _line_pair_iterator()
    if (context is None):
        while True:
            yield line_pair_iterator.next()
    else:
        context += 1
        lines_to_write = 0
        while True:
            (index, contextLines) = (0, ([None] * context))
            found_diff = False
            while (found_diff is False):
                (from_line, to_line, found_diff) = line_pair_iterator.next()
                i = (index % context)
                contextLines[i] = (from_line, to_line, found_diff)
                index += 1
            if (index > context):
                yield (None, None, None)
                lines_to_write = context
            else:
                lines_to_write = index
                index = 0
            while lines_to_write:
                i = (index % context)
                index += 1
                yield contextLines[i]
                lines_to_write -= 1
            lines_to_write = (context - 1)
            while lines_to_write:
                (from_line, to_line, found_diff) = line_pair_iterator.next()
                if found_diff:
                    lines_to_write = (context - 1)
                else:
                    lines_to_write -= 1
                yield (from_line, to_line, found_diff)
