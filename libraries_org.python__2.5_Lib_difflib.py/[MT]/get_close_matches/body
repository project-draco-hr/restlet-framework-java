def get_close_matches(word, possibilities, n=3, cutoff=0.6):
    'Use SequenceMatcher to return list of the best "good enough" matches.\n\n    word is a sequence for which close matches are desired (typically a\n    string).\n\n    possibilities is a list of sequences against which to match word\n    (typically a list of strings).\n\n    Optional arg n (default 3) is the maximum number of close matches to\n    return.  n must be > 0.\n\n    Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities\n    that don\'t score at least that similar to word are ignored.\n\n    The best (no more than n) matches among the possibilities are returned\n    in a list, sorted by similarity score, most similar first.\n\n    >>> get_close_matches("appel", ["ape", "apple", "peach", "puppy"])\n    [\'apple\', \'ape\']\n    >>> import keyword as _keyword\n    >>> get_close_matches("wheel", _keyword.kwlist)\n    [\'while\']\n    >>> get_close_matches("apple", _keyword.kwlist)\n    []\n    >>> get_close_matches("accept", _keyword.kwlist)\n    [\'except\']\n    '
    if (not (n > 0)):
        raise ValueError(('n must be > 0: %r' % (n,)))
    if (not (0.0 <= cutoff <= 1.0)):
        raise ValueError(('cutoff must be in [0.0, 1.0]: %r' % (cutoff,)))
    result = []
    s = SequenceMatcher()
    s.set_seq2(word)
    for x in possibilities:
        s.set_seq1(x)
        if ((s.real_quick_ratio() >= cutoff) and (s.quick_ratio() >= cutoff) and (s.ratio() >= cutoff)):
            result.append((s.ratio(), x))
    result = heapq.nlargest(n, result)
    return [x for (score, x) in result]
