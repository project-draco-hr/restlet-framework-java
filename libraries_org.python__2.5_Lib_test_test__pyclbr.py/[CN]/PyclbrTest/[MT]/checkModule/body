def checkModule(self, moduleName, module=None, ignore=()):
    ' succeed iff pyclbr.readmodule_ex(modulename) corresponds\n            to the actual module object, module.  Any identifiers in\n            ignore are ignored.   If no module is provided, the appropriate\n            module is loaded with __import__.'
    if (module == None):
        module = __import__(moduleName, globals(), {}, ['<silly>'])
    dict = pyclbr.readmodule_ex(moduleName)

    def ismethod(oclass, obj, name):
        classdict = oclass.__dict__
        if isinstance(obj, FunctionType):
            if (not isinstance(classdict[name], StaticMethodType)):
                return False
        else:
            if (not isinstance(obj, MethodType)):
                return False
            if (obj.im_self is not None):
                if ((not isinstance(classdict[name], ClassMethodType)) or (obj.im_self is not oclass)):
                    return False
            elif (not isinstance(classdict[name], FunctionType)):
                return False
        objname = obj.__name__
        if (objname.startswith('__') and (not objname.endswith('__'))):
            objname = ('_%s%s' % (obj.im_class.__name__, objname))
        return (objname == name)
    for (name, value) in dict.items():
        if (name in ignore):
            continue
        self.assertHasattr(module, name, ignore)
        py_item = getattr(module, name)
        if isinstance(value, pyclbr.Function):
            self.assert_(isinstance(py_item, (FunctionType, BuiltinFunctionType)))
            if (py_item.__module__ != moduleName):
                continue
            self.assertEquals(py_item.__module__, value.module)
        else:
            self.failUnless(isinstance(py_item, (ClassType, type)))
            if (py_item.__module__ != moduleName):
                continue
            real_bases = [base.__name__ for base in py_item.__bases__]
            pyclbr_bases = [getattr(base, 'name', base) for base in value.super]
            try:
                self.assertListEq(real_bases, pyclbr_bases, ignore)
            except:
                print  >> sys.stderr, ('class=%s' % py_item)
                raise
            actualMethods = []
            for m in py_item.__dict__.keys():
                if ismethod(py_item, getattr(py_item, m), m):
                    actualMethods.append(m)
            foundMethods = []
            for m in value.methods.keys():
                if ((m[:2] == '__') and (m[(-2):] != '__')):
                    foundMethods.append((('_' + name) + m))
                else:
                    foundMethods.append(m)
            try:
                self.assertListEq(foundMethods, actualMethods, ignore)
                self.assertEquals(py_item.__module__, value.module)
                self.assertEqualsOrIgnored(py_item.__name__, value.name, ignore)
            except:
                print  >> sys.stderr, ('class=%s' % py_item)
                raise

    def defined_in(item, module):
        if isinstance(item, ClassType):
            return (item.__module__ == module.__name__)
        if isinstance(item, FunctionType):
            return (item.func_globals is module.__dict__)
        return False
    for name in dir(module):
        item = getattr(module, name)
        if isinstance(item, (ClassType, FunctionType)):
            if defined_in(item, module):
                self.assertHaskey(dict, name, ignore)
