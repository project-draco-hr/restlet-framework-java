def _lock_file(f, dotlock=True):
    'Lock file f using lockf and dot locking.'
    dotlock_done = False
    try:
        if fcntl:
            try:
                fcntl.lockf(f, (fcntl.LOCK_EX | fcntl.LOCK_NB))
            except IOError as e:
                if (e.errno in (errno.EAGAIN, errno.EACCES)):
                    raise ExternalClashError(('lockf: lock unavailable: %s' % f.name))
                else:
                    raise
        if dotlock:
            try:
                pre_lock = _create_temporary((f.name + '.lock'))
                pre_lock.close()
            except IOError as e:
                if (e.errno == errno.EACCES):
                    return
                else:
                    raise
            try:
                if hasattr(os, 'link'):
                    os.link(pre_lock.name, (f.name + '.lock'))
                    dotlock_done = True
                    os.unlink(pre_lock.name)
                else:
                    os.rename(pre_lock.name, (f.name + '.lock'))
                    dotlock_done = True
            except OSError as e:
                if ((e.errno == errno.EEXIST) or ((os.name == 'os2') and (e.errno == errno.EACCES))):
                    os.remove(pre_lock.name)
                    raise ExternalClashError(('dot lock unavailable: %s' % f.name))
                else:
                    raise
    except:
        if fcntl:
            fcntl.lockf(f, fcntl.LOCK_UN)
        if dotlock_done:
            os.remove((f.name + '.lock'))
        raise
