def html((etype, evalue, etb), context=5):
    'Return a nice HTML document describing a given traceback.'
    import os, types, time, traceback, linecache, inspect, pydoc
    if (type(etype) is types.ClassType):
        etype = etype.__name__
    pyver = ((('Python ' + sys.version.split()[0]) + ': ') + sys.executable)
    date = time.ctime(time.time())
    head = (('<body bgcolor="#f0f0f8">' + pydoc.html.heading(('<big><big>%s</big></big>' % strong(pydoc.html.escape(str(etype)))), '#ffffff', '#6622aa', ((pyver + '<br>') + date))) + '\n<p>A problem occurred in a Python script.  Here is the sequence of\nfunction calls leading up to the error, in the order they occurred.</p>')
    indent = (('<tt>' + small(('&nbsp;' * 5))) + '&nbsp;</tt>')
    frames = []
    records = inspect.getinnerframes(etb, context)
    for (frame, file, lnum, func, lines, index) in records:
        if file:
            file = os.path.abspath(file)
            link = ('<a href="file://%s">%s</a>' % (file, pydoc.html.escape(file)))
        else:
            file = link = '?'
        (args, varargs, varkw, locals) = inspect.getargvalues(frame)
        call = ''
        if (func != '?'):
            call = (('in ' + strong(func)) + inspect.formatargvalues(args, varargs, varkw, locals, formatvalue=(lambda value: ('=' + pydoc.html.repr(value)))))
        highlight = {}

        def reader(lnum=[lnum]):
            highlight[lnum[0]] = 1
            try:
                return linecache.getline(file, lnum[0])
            finally:
                lnum[0] += 1
        vars = scanvars(reader, frame, locals)
        rows = [('<tr><td bgcolor="#d8bbff">%s%s %s</td></tr>' % ('<big>&nbsp;</big>', link, call))]
        if (index is not None):
            i = (lnum - index)
            for line in lines:
                num = (small((('&nbsp;' * (5 - len(str(i)))) + str(i))) + '&nbsp;')
                line = ('<tt>%s%s</tt>' % (num, pydoc.html.preformat(line)))
                if (i in highlight):
                    rows.append(('<tr><td bgcolor="#ffccee">%s</td></tr>' % line))
                else:
                    rows.append(('<tr><td>%s</td></tr>' % grey(line)))
                i += 1
        (done, dump) = ({}, [])
        for (name, where, value) in vars:
            if (name in done):
                continue
            done[name] = 1
            if (value is not __UNDEF__):
                if (where in ('global', 'builtin')):
                    name = (('<em>%s</em> ' % where) + strong(name))
                elif (where == 'local'):
                    name = strong(name)
                else:
                    name = (where + strong(name.split('.')[(-1)]))
                dump.append(('%s&nbsp;= %s' % (name, pydoc.html.repr(value))))
            else:
                dump.append((name + ' <em>undefined</em>'))
        rows.append(('<tr><td>%s</td></tr>' % small(grey(', '.join(dump)))))
        frames.append(('\n<table width="100%%" cellspacing=0 cellpadding=0 border=0>\n%s</table>' % '\n'.join(rows)))
    exception = [('<p>%s: %s' % (strong(pydoc.html.escape(str(etype))), pydoc.html.escape(str(evalue))))]
    if isinstance(evalue, BaseException):
        for name in dir(evalue):
            if (name[:1] == '_'):
                continue
            value = pydoc.html.repr(getattr(evalue, name))
            exception.append(('\n<br>%s%s&nbsp;=\n%s' % (indent, name, value)))
    import traceback
    return (((head + ''.join(frames)) + ''.join(exception)) + ("\n\n\n<!-- The above is a description of an error in a Python program, formatted\n     for a Web browser because the 'cgitb' module was enabled.  In case you\n     are not reading this in a Web browser, here is the original traceback:\n\n%s\n-->\n" % pydoc.html.escape(''.join(traceback.format_exception(etype, evalue, etb)))))
