def __init__(self, hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None):
    "Create a UUID from either a string of 32 hexadecimal digits,\n        a string of 16 bytes as the 'bytes' argument, a string of 16 bytes\n        in little-endian order as the 'bytes_le' argument, a tuple of six\n        integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version,\n        8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as\n        the 'fields' argument, or a single 128-bit integer as the 'int'\n        argument.  When a string of hex digits is given, curly braces,\n        hyphens, and a URN prefix are all optional.  For example, these\n        expressions all yield the same UUID:\n\n        UUID('{12345678-1234-5678-1234-567812345678}')\n        UUID('12345678123456781234567812345678')\n        UUID('urn:uuid:12345678-1234-5678-1234-567812345678')\n        UUID(bytes='\\x12\\x34\\x56\\x78'*4)\n        UUID(bytes_le='\\x78\\x56\\x34\\x12\\x34\\x12\\x78\\x56' +\n                      '\\x12\\x34\\x56\\x78\\x12\\x34\\x56\\x78')\n        UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))\n        UUID(int=0x12345678123456781234567812345678)\n\n        Exactly one of 'hex', 'bytes', 'bytes_le', 'fields', or 'int' must\n        be given.  The 'version' argument is optional; if given, the resulting\n        UUID will have its variant and version set according to RFC 4122,\n        overriding the given 'hex', 'bytes', 'bytes_le', 'fields', or 'int'.\n        "
    if ([hex, bytes, bytes_le, fields, int].count(None) != 4):
        raise TypeError('need one of hex, bytes, bytes_le, fields, or int')
    if (hex is not None):
        hex = hex.replace('urn:', '').replace('uuid:', '')
        hex = hex.strip('{}').replace('-', '')
        if (len(hex) != 32):
            raise ValueError('badly formed hexadecimal UUID string')
        int = long(hex, 16)
    if (bytes_le is not None):
        if (len(bytes_le) != 16):
            raise ValueError('bytes_le is not a 16-char string')
        bytes = ((((((((bytes_le[3] + bytes_le[2]) + bytes_le[1]) + bytes_le[0]) + bytes_le[5]) + bytes_le[4]) + bytes_le[7]) + bytes_le[6]) + bytes_le[8:])
    if (bytes is not None):
        if (len(bytes) != 16):
            raise ValueError('bytes is not a 16-char string')
        int = long((('%02x' * 16) % tuple(map(ord, bytes))), 16)
    if (fields is not None):
        if (len(fields) != 6):
            raise ValueError('fields is not a 6-tuple')
        (time_low, time_mid, time_hi_version, clock_seq_hi_variant, clock_seq_low, node) = fields
        if (not (0 <= time_low < (1 << 32L))):
            raise ValueError('field 1 out of range (need a 32-bit value)')
        if (not (0 <= time_mid < (1 << 16L))):
            raise ValueError('field 2 out of range (need a 16-bit value)')
        if (not (0 <= time_hi_version < (1 << 16L))):
            raise ValueError('field 3 out of range (need a 16-bit value)')
        if (not (0 <= clock_seq_hi_variant < (1 << 8L))):
            raise ValueError('field 4 out of range (need an 8-bit value)')
        if (not (0 <= clock_seq_low < (1 << 8L))):
            raise ValueError('field 5 out of range (need an 8-bit value)')
        if (not (0 <= node < (1 << 48L))):
            raise ValueError('field 6 out of range (need a 48-bit value)')
        clock_seq = ((clock_seq_hi_variant << 8L) | clock_seq_low)
        int = (((((time_low << 96L) | (time_mid << 80L)) | (time_hi_version << 64L)) | (clock_seq << 48L)) | node)
    if (int is not None):
        if (not (0 <= int < (1 << 128L))):
            raise ValueError('int is out of range (need a 128-bit value)')
    if (version is not None):
        if (not (1 <= version <= 5)):
            raise ValueError('illegal version number')
        int &= (~ (49152 << 48L))
        int |= (32768 << 48L)
        int &= (~ (61440 << 64L))
        int |= (version << 76L)
    self.__dict__['int'] = int
