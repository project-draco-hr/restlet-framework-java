import pyexpat
from xml.parsers import expat
from test.test_support import sortdict, TestFailed
out = Outputter()
parser = expat.ParserCreate(namespace_separator='!')
parser.returns_unicode = 0
confirm((parser.returns_unicode == 0))
parser.returns_unicode = 1
confirm((parser.returns_unicode == 1))
parser.returns_unicode = 2
confirm((parser.returns_unicode == 1))
parser.returns_unicode = 0
confirm((parser.returns_unicode == 0))
parser.ordered_attributes = 0
confirm((parser.ordered_attributes == 0))
parser.ordered_attributes = 1
confirm((parser.ordered_attributes == 1))
parser.ordered_attributes = 2
confirm((parser.ordered_attributes == 1))
parser.ordered_attributes = 0
confirm((parser.ordered_attributes == 0))
parser.specified_attributes = 0
confirm((parser.specified_attributes == 0))
parser.specified_attributes = 1
confirm((parser.specified_attributes == 1))
parser.specified_attributes = 2
confirm((parser.specified_attributes == 1))
parser.specified_attributes = 0
confirm((parser.specified_attributes == 0))
HANDLER_NAMES = ['StartElementHandler', 'EndElementHandler', 'CharacterDataHandler', 'ProcessingInstructionHandler', 'UnparsedEntityDeclHandler', 'NotationDeclHandler', 'StartNamespaceDeclHandler', 'EndNamespaceDeclHandler', 'CommentHandler', 'StartCdataSectionHandler', 'EndCdataSectionHandler', 'DefaultHandler', 'DefaultHandlerExpand', 'ExternalEntityRefHandler']
for name in HANDLER_NAMES:
    setattr(parser, name, getattr(out, name))
data = '<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>\n<?xml-stylesheet href="stylesheet.css"?>\n<!-- comment data -->\n<!DOCTYPE quotations SYSTEM "quotations.dtd" [\n<!ELEMENT root ANY>\n<!NOTATION notation SYSTEM "notation.jpeg">\n<!ENTITY acirc "&#226;">\n<!ENTITY external_entity SYSTEM "entity.file">\n<!ENTITY unparsed_entity SYSTEM "entity.file" NDATA notation>\n%unparsed_entity;\n]>\n\n<root attr1="value1" attr2="value2&#8000;">\n<myns:subelement xmlns:myns="http://www.python.org/namespace">\n     Contents of subelements\n</myns:subelement>\n<sub2><![CDATA[contents of CDATA section]]></sub2>\n&external_entity;\n</root>\n'
parser.returns_unicode = 0
try:
    parser.Parse(data, 1)
except expat.error:
    print '** Error', parser.ErrorCode, expat.ErrorString(parser.ErrorCode)
    print '** Line', parser.ErrorLineNumber
    print '** Column', parser.ErrorColumnNumber
    print '** Byte', parser.ErrorByteIndex
parser = expat.ParserCreate(namespace_separator='!')
parser.returns_unicode = 1
for name in HANDLER_NAMES:
    setattr(parser, name, getattr(out, name))
try:
    parser.Parse(data, 1)
except expat.error:
    print '** Error', parser.ErrorCode, expat.ErrorString(parser.ErrorCode)
    print '** Line', parser.ErrorLineNumber
    print '** Column', parser.ErrorColumnNumber
    print '** Byte', parser.ErrorByteIndex
parser = expat.ParserCreate(namespace_separator='!')
parser.returns_unicode = 1
for name in HANDLER_NAMES:
    setattr(parser, name, getattr(out, name))
import StringIO
file = StringIO.StringIO(data)
try:
    parser.ParseFile(file)
except expat.error:
    print '** Error', parser.ErrorCode, expat.ErrorString(parser.ErrorCode)
    print '** Line', parser.ErrorLineNumber
    print '** Column', parser.ErrorColumnNumber
    print '** Byte', parser.ErrorByteIndex
print 
print 'Testing constructor for proper handling of namespace_separator values:'
expat.ParserCreate()
expat.ParserCreate(namespace_separator=None)
expat.ParserCreate(namespace_separator=' ')
print 'Legal values tested o.k.'
try:
    expat.ParserCreate(namespace_separator=42)
except TypeError as e:
    print 'Caught expected TypeError:'
    print e
else:
    print 'Failed to catch expected TypeError.'
try:
    expat.ParserCreate(namespace_separator='too long')
except ValueError as e:
    print 'Caught expected ValueError:'
    print e
else:
    print 'Failed to catch expected ValueError.'
expat.ParserCreate(namespace_separator='')
p = expat.ParserCreate()
L = []
p.StartElementHandler = collector
p.EndElementHandler = collector
p.Parse('<e> <e/> <e></e> </e>', 1)
tag = L[0]
if (len(L) != 6):
    print 'L should only contain 6 entries; found', len(L)
for entry in L:
    if (tag is not entry):
        print 'expected L to contain many references to the same string',
        print "(it didn't)"
        print 'L =', repr(L)
        break
import sys
(parser, handler) = setup()
require(parser.buffer_text, 'text buffering either not acknowledged or not enabled')
parser.Parse('<a>1<b/>2<c/>3</a>', 1)
handler.check(['123'], 'buffered text not properly collapsed')
(parser, handler) = setup(['StartElementHandler'])
parser.Parse("<a>1<b buffer-text='no'/>2\n3<c buffer-text='yes'/>4\n5</a>", 1)
handler.check(['<a>', '1', '<b>', '2', '\n', '3', '<c>', '4\n5'], 'buffering control not reacting as expected')
(parser, handler) = setup()
parser.Parse('<a>1<b/>&lt;2&gt;<c/>&#32;\n&#x20;3</a>', 1)
handler.check(['1<2> \n 3'], 'buffered text not properly collapsed')
(parser, handler) = setup(['StartElementHandler'])
parser.Parse('<a>1<b/>2<c/>3</a>', 1)
handler.check(['<a>', '1', '<b>', '2', '<c>', '3'], 'buffered text not properly split')
(parser, handler) = setup(['StartElementHandler', 'EndElementHandler'])
parser.CharacterDataHandler = None
parser.Parse('<a>1<b/>2<c/>3</a>', 1)
handler.check(['<a>', '<b>', '</b>', '<c>', '</c>', '</a>'], 'huh?')
(parser, handler) = setup(['StartElementHandler', 'EndElementHandler'])
parser.Parse('<a>1<b></b>2<c/>3</a>', 1)
handler.check(['<a>', '1', '<b>', '</b>', '2', '<c>', '</c>', '3', '</a>'], 'huh?')
(parser, handler) = setup(['CommentHandler', 'EndElementHandler', 'StartElementHandler'])
parser.Parse('<a>1<b/>2<c></c>345</a> ', 1)
handler.check(['<a>', '1', '<b>', '</b>', '2', '<c>', '</c>', '345', '</a>'], 'buffered text not properly split')
(parser, handler) = setup(['CommentHandler', 'EndElementHandler', 'StartElementHandler'])
parser.Parse('<a>1<b/>2<c></c>3<!--abc-->4<!--def-->5</a> ', 1)
handler.check(['<a>', '1', '<b>', '</b>', '2', '<c>', '</c>', '3', '<!--abc-->', '4', '<!--def-->', '5', '</a>'], 'buffered text not properly split')
parser = expat.ParserCreate()
parser.StartElementHandler = StartElementHandler
try:
    parser.Parse('<a><b><c/></b></a>', 1)
except RuntimeError as e:
    if (e.args[0] != 'a'):
        print ("Expected RuntimeError for element 'a'; found %r" % e.args[0])
else:
    print "Expected RuntimeError for 'a'"
parser = expat.ParserCreate()
handler = PositionTest([('s', 0, 1, 0), ('s', 5, 2, 1), ('s', 11, 3, 2), ('e', 15, 3, 6), ('e', 17, 4, 1), ('e', 22, 5, 0)], parser)
parser.Parse('<a>\n <b>\n  <c/>\n </b>\n</a>', 1)
test_parse_only_xml_data()
