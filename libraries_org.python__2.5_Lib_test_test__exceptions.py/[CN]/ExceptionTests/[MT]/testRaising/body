def testRaising(self):
    self.raise_catch(AttributeError, 'AttributeError')
    self.assertRaises(AttributeError, getattr, sys, 'undefined_attribute')
    self.raise_catch(EOFError, 'EOFError')
    fp = open(TESTFN, 'w')
    fp.close()
    fp = open(TESTFN, 'r')
    savestdin = sys.stdin
    try:
        try:
            sys.stdin = fp
            x = raw_input()
        except EOFError:
            pass
    finally:
        sys.stdin = savestdin
        fp.close()
        unlink(TESTFN)
    self.raise_catch(IOError, 'IOError')
    self.assertRaises(IOError, open, 'this file does not exist', 'r')
    self.raise_catch(ImportError, 'ImportError')
    self.assertRaises(ImportError, __import__, 'undefined_module')
    self.raise_catch(IndexError, 'IndexError')
    x = []
    self.assertRaises(IndexError, x.__getitem__, 10)
    self.raise_catch(KeyError, 'KeyError')
    x = {}
    self.assertRaises(KeyError, x.__getitem__, 'key')
    self.raise_catch(KeyboardInterrupt, 'KeyboardInterrupt')
    self.raise_catch(MemoryError, 'MemoryError')
    self.raise_catch(NameError, 'NameError')
    try:
        x = undefined_variable
    except NameError:
        pass
    self.raise_catch(OverflowError, 'OverflowError')
    x = 1
    for dummy in range(128):
        x += x
    self.raise_catch(RuntimeError, 'RuntimeError')
    self.raise_catch(SyntaxError, 'SyntaxError')
    try:
        exec '/\n'
    except SyntaxError:
        pass
    self.raise_catch(IndentationError, 'IndentationError')
    self.raise_catch(TabError, 'TabError')
    self.raise_catch(SystemError, 'SystemError')
    self.raise_catch(SystemExit, 'SystemExit')
    self.assertRaises(SystemExit, sys.exit, 0)
    self.raise_catch(TypeError, 'TypeError')
    try:
        ([] + ())
    except TypeError:
        pass
    self.raise_catch(ValueError, 'ValueError')
    self.assertRaises(ValueError, chr, 10000)
    self.raise_catch(ZeroDivisionError, 'ZeroDivisionError')
    try:
        x = (1 / 0)
    except ZeroDivisionError:
        pass
    self.raise_catch(Exception, 'Exception')
    try:
        x = (1 / 0)
    except Exception as e:
        pass
