"OS routines for Java, with some attempts to support NT, and Posix\nfunctionality.\n\nThis exports:\n  - all functions from posix, nt, dos, os2, mac, or ce, e.g. unlink, stat, etc.\n  - os.path is one of the modules posixpath, ntpath, macpath, or dospath\n  - os.name is 'posix', 'nt', 'dos', 'os2', 'mac', 'ce' or 'riscos'\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).\n"
__all__ = ['altsep', 'curdir', 'pardir', 'sep', 'pathsep', 'linesep', 'defpath', 'name', 'path', 'SEEK_SET', 'SEEK_CUR', 'SEEK_END']
__all__.extend(['EX_OK', 'F_OK', 'O_APPEND', 'O_CREAT', 'O_EXCL', 'O_RDONLY', 'O_RDWR', 'O_SYNC', 'O_TRUNC', 'O_WRONLY', 'R_OK', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET', 'W_OK', 'X_OK', '_exit', 'access', 'altsep', 'chdir', 'chmod', 'close', 'curdir', 'defpath', 'environ', 'error', 'fdopen', 'fsync', 'getcwd', 'getcwdu', 'getenv', 'getpid', 'isatty', 'linesep', 'listdir', 'lseek', 'lstat', 'makedirs', 'mkdir', 'name', 'open', 'pardir', 'path', 'pathsep', 'popen', 'popen2', 'popen3', 'popen4', 'putenv', 'read', 'remove', 'removedirs', 'rename', 'renames', 'rmdir', 'sep', 'stat', 'stat_result', 'strerror', 'system', 'unlink', 'unsetenv', 'utime', 'walk', 'write'])
import errno
import jarray
import java.lang.System
import time
import stat as _stat
import sys
from java.io import File
from org.python.core.io import FileDescriptors, FileIO, IOBase
from org.python.core.Py import newString as asPyString
try:
    from org.python.constantine.platform import Errno
except ImportError:
    from com.kenai.constantine.platform import Errno
_os_map = dict(nt=[['Windows'], [['cmd.exe', '/c'], ['command.com', '/c']]], posix=[[], [['/bin/sh', '-c']]])
name = 'java'
_name = get_os_type()
try:
    from org.python.posix import JavaPOSIX, POSIXHandler, POSIXFactory
except ImportError:
    from org.jruby.ext.posix import JavaPOSIX, POSIXHandler, POSIXFactory
_posix = POSIXFactory.getPOSIX(PythonPOSIXHandler(), True)
_native_posix = (not isinstance(_posix, JavaPOSIX))
if (_name == 'nt'):
    import ntpath as path
else:
    import posixpath as path
sys.modules['os.path'] = _path = path
from os.path import curdir, pardir, sep, pathsep, defpath, extsep, altsep, devnull
linesep = java.lang.System.getProperty('line.separator')
O_RDONLY = 0
O_WRONLY = 1
O_RDWR = 2
O_APPEND = 8
O_SYNC = 128
O_CREAT = 512
O_TRUNC = 1024
O_EXCL = 2048
SEEK_SET = 0
SEEK_CUR = 1
SEEK_END = 2
F_OK = 0
X_OK = (1 << 0)
W_OK = (1 << 1)
R_OK = (1 << 2)
EX_OK = 0
_time_t = None
error = OSError
unlink = remove
__all__.extend(['makedirs', 'renames', 'removedirs'])
__all__.append('walk')
environ = sys.getEnviron()
if (_name in ('os2', 'nt')):
    import UserDict


    class _Environ(UserDict.IterableUserDict):

        def __init__(self, environ):
            UserDict.UserDict.__init__(self)
            data = self.data
            for (k, v) in environ.items():
                data[k.upper()] = v

        def __setitem__(self, key, item):
            self.data[key.upper()] = item

        def __getitem__(self, key):
            return self.data[key.upper()]

        def __delitem__(self, key):
            del self.data[key.upper()]

        def has_key(self, key):
            return (key.upper() in self.data)

        def __contains__(self, key):
            return (key.upper() in self.data)

        def get(self, key, failobj=None):
            return self.data.get(key.upper(), failobj)

        def update(self, dict=None, **kwargs):
            if dict:
                try:
                    keys = dict.keys()
                except AttributeError:
                    for (k, v) in dict:
                        self[k] = v
                else:
                    for k in keys:
                        self[k] = dict[k]
            if kwargs:
                self.update(kwargs)

        def copy(self):
            return dict(self)
    environ = _Environ(environ)
if (_name == 'posix'):

    def link(src, dst):
        'link(src, dst)\n\n        Create a hard link to a file.\n        '
        _posix.link(sys.getPath(src), sys.getPath(dst))

    def symlink(src, dst):
        'symlink(src, dst)\n\n        Create a symbolic link pointing to src named dst.\n        '
        _posix.symlink(src, sys.getPath(dst))

    def readlink(path):
        'readlink(path) -> path\n\n        Return a string representing the path to which the symbolic link\n        points.\n        '
        return _posix.readlink(sys.getPath(path))

    def getegid():
        "getegid() -> egid\n\n        Return the current process's effective group id."
        return _posix.getegid()

    def geteuid():
        "geteuid() -> euid\n\n        Return the current process's effective user id."
        return _posix.geteuid()

    def getgid():
        "getgid() -> gid\n\n        Return the current process's group id."
        return _posix.getgid()

    def getlogin():
        'getlogin() -> string\n\n        Return the actual login name.'
        return _posix.getlogin()

    def getpgrp():
        'getpgrp() -> pgrp\n\n        Return the current process group id.'
        return _posix.getpgrp()

    def getppid():
        "getppid() -> ppid\n\n        Return the parent's process id."
        return _posix.getppid()

    def getuid():
        "getuid() -> uid\n\n        Return the current process's user id."
        return _posix.getuid()

    def setpgrp():
        'setpgrp()\n\n        Make this process a session leader.'
        return _posix.setpgrp()

    def setsid():
        'setsid()\n\n        Call the system call setsid().'
        return _posix.setsid()

    def kill(pid, sig):
        'kill(pid, sig)\n\n        Kill a process with a signal.'
        return _posix.kill(pid, sig)

    def wait():
        'wait() -> (pid, status)\n\n        Wait for completion of a child process.'
        status = jarray.zeros(1, 'i')
        res_pid = _posix.wait(status)
        if (res_pid == (-1)):
            raise OSError(status[0], strerror(status[0]))
        return (res_pid, status[0])

    def waitpid(pid, options):
        'waitpid(pid, options) -> (pid, status)\n\n        Wait for completion of a given child process.'
        status = jarray.zeros(1, 'i')
        res_pid = _posix.waitpid(pid, status, options)
        if (res_pid == (-1)):
            raise OSError(status[0], strerror(status[0]))
        return (res_pid, status[0])

    def fdatasync(fd):
        'fdatasync(fildes)\n\n        force write of file with filedescriptor to disk.\n        does not force update of metadata.\n        '
        _fsync(fd, False)
    __all__.extend(['link', 'symlink', 'readlink', 'getegid', 'geteuid', 'getgid', 'getlogin', 'getpgrp', 'getppid', 'getuid', 'setpgrp', 'setsid', 'kill', 'wait', 'waitpid', 'fdatasync'])
from java.security import SecureRandom
urandom_source = None
