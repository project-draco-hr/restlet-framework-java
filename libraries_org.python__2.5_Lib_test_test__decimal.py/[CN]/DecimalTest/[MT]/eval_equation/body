def eval_equation(self, s):
    if ((not TEST_ALL) and (random.random() < 0.9)):
        return
    try:
        Sides = s.split('->')
        L = Sides[0].strip().split()
        id = L[0]
        if DEBUG:
            print 'Test ', id,
        funct = L[1].lower()
        valstemp = L[2:]
        L = Sides[1].strip().split()
        ans = L[0]
        exceptions = L[1:]
    except (TypeError, AttributeError, IndexError):
        raise InvalidOperation

    def FixQuotes(val):
        val = val.replace("''", 'SingleQuote').replace('""', 'DoubleQuote')
        val = val.replace("'", '').replace('"', '')
        val = val.replace('SingleQuote', "'").replace('DoubleQuote', '"')
        return val
    fname = nameAdapter.get(funct, funct)
    if (fname == 'rescale'):
        return
    funct = getattr(self.context, fname)
    vals = []
    conglomerate = ''
    quote = 0
    theirexceptions = [ErrorNames[x.lower()] for x in exceptions]
    for exception in Signals:
        self.context.traps[exception] = 1
    for exception in theirexceptions:
        self.context.traps[exception] = 0
    for (i, val) in enumerate(valstemp):
        if ((val.count("'") % 2) == 1):
            quote = (1 - quote)
        if quote:
            conglomerate = ((conglomerate + ' ') + val)
            continue
        else:
            val = (conglomerate + val)
            conglomerate = ''
        v = FixQuotes(val)
        if (fname in ('to_sci_string', 'to_eng_string')):
            if EXTENDEDERRORTEST:
                for error in theirexceptions:
                    self.context.traps[error] = 1
                    try:
                        funct(self.context.create_decimal(v))
                    except error:
                        pass
                    except Signals as e:
                        self.fail(('Raised %s in %s when %s disabled' % (e, s, error)))
                    else:
                        self.fail(('Did not raise %s in %s' % (error, s)))
                    self.context.traps[error] = 0
            v = self.context.create_decimal(v)
        else:
            v = Decimal(v, self.context)
        vals.append(v)
    ans = FixQuotes(ans)
    if (fname in decNumberRestricted):
        if (fname == 'power'):
            if (not (vals[1]._isinteger() and ((-1999999997) <= vals[1] <= 999999999))):
                if (outside_decNumber_bounds(vals[0], self.context) or outside_decNumber_bounds(vals[1], self.context)):
                    return
        elif outside_decNumber_bounds(vals[0], self.context):
            return
    if (EXTENDEDERRORTEST and (fname not in ('to_sci_string', 'to_eng_string'))):
        for error in theirexceptions:
            self.context.traps[error] = 1
            try:
                funct(*vals)
            except error:
                pass
            except Signals as e:
                self.fail(('Raised %s in %s when %s disabled' % (e, s, error)))
            else:
                self.fail(('Did not raise %s in %s' % (error, s)))
            self.context.traps[error] = 0
    if DEBUG:
        print '--', self.context
    try:
        result = str(funct(*vals))
        if (fname in LOGICAL_FUNCTIONS):
            result = str(int(eval(result)))
    except Signals as error:
        self.fail(('Raised %s in %s' % (error, s)))
    except:
        print 'ERROR:', s
        raise
    myexceptions = self.getexceptions()
    self.context.clear_flags()
    myexceptions.sort()
    theirexceptions.sort()
    self.assertEqual(result, ans, ((('Incorrect answer for ' + s) + ' -- got ') + result))
    self.assertEqual(myexceptions, theirexceptions, ((('Incorrect flags set in ' + s) + ' -- got ') + str(myexceptions)))
    return
