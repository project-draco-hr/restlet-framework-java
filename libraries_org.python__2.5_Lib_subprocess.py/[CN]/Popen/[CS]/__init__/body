def __init__(self, args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0):
    'Create new Popen instance.'
    _cleanup()
    self._child_created = False
    if (not isinstance(bufsize, (int, long))):
        raise TypeError('bufsize must be an integer')
    if mswindows:
        if (preexec_fn is not None):
            raise ValueError('preexec_fn is not supported on Windows platforms')
        if (close_fds and ((stdin is not None) or (stdout is not None) or (stderr is not None))):
            raise ValueError('close_fds is not supported on Windows platforms if you redirect stdin/stdout/stderr')
    else:
        if (startupinfo is not None):
            raise ValueError('startupinfo is only supported on Windows platforms')
        if (creationflags != 0):
            raise ValueError('creationflags is only supported on Windows platforms')
    if jython:
        if (preexec_fn is not None):
            raise ValueError('preexec_fn is not supported on the Jython platform')
    self.stdin = None
    self.stdout = None
    self.stderr = None
    self.pid = None
    self.returncode = None
    self.universal_newlines = universal_newlines
    (p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    self._execute_child(args, executable, preexec_fn, close_fds, cwd, env, universal_newlines, startupinfo, creationflags, shell, p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite)
    if mswindows:
        if ((stdin is None) and (p2cwrite is not None)):
            os.close(p2cwrite)
            p2cwrite = None
        if ((stdout is None) and (c2pread is not None)):
            os.close(c2pread)
            c2pread = None
        if ((stderr is None) and (errread is not None)):
            os.close(errread)
            errread = None
    if jython:
        self._stdin_thread = None
        self._stdout_thread = None
        self._stderr_thread = None
        proc = self._process
        ct2cwrite = org.python.core.io.StreamIO(proc.getOutputStream(), True)
        c2ctread = org.python.core.io.StreamIO(proc.getInputStream(), True)
        cterrread = org.python.core.io.StreamIO(proc.getErrorStream(), True)
        if (p2cwrite == PIPE):
            p2cwrite = ct2cwrite
        elif (p2cread is None):
            pass
        else:
            self._stdin_thread = self._coupler_thread('stdin', p2cread.readinto, ct2cwrite.write, ct2cwrite.close)
            self._stdin_thread.start()
        if (c2pread == PIPE):
            c2pread = c2ctread
        else:
            if (c2pwrite is None):
                c2pwrite = org.python.core.io.StreamIO(java.lang.System.out, False)
            self._stdout_thread = self._coupler_thread('stdout', c2ctread.readinto, c2pwrite.write)
            self._stdout_thread.start()
        if (errread == PIPE):
            errread = cterrread
        elif (not self._stderr_is_stdout(errwrite, c2pwrite)):
            if (errwrite is None):
                errwrite = org.python.core.io.StreamIO(java.lang.System.err, False)
            self._stderr_thread = self._coupler_thread('stderr', cterrread.readinto, errwrite.write)
            self._stderr_thread.start()
    if (p2cwrite is not None):
        self.stdin = os.fdopen(p2cwrite, 'wb', bufsize)
    if (c2pread is not None):
        if universal_newlines:
            self.stdout = os.fdopen(c2pread, 'rU', bufsize)
        else:
            self.stdout = os.fdopen(c2pread, 'rb', bufsize)
    if (errread is not None):
        if universal_newlines:
            self.stderr = os.fdopen(errread, 'rU', bufsize)
        else:
            self.stderr = os.fdopen(errread, 'rb', bufsize)
