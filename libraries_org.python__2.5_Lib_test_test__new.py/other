from test.test_support import verbose, verify, TestFailed
import sys
import new
print 'new.module()'
m = new.module('Spam')
if verbose:
    print m
m.Eggs = Eggs
sys.modules['Spam'] = m
import Spam
print 'new.classobj()'
C = new.classobj('Spam', (Spam.Eggs,), {'get_more_yolks': get_more_yolks, })
if verbose:
    print C
print 'new.instance()'
c = new.instance(C, {'yolks': 3, })
if verbose:
    print c
o = new.instance(C)
verify((o.__dict__ == {}), 'new __dict__ should be empty')
del o
o = new.instance(C, None)
verify((o.__dict__ == {}), 'new __dict__ should be empty')
del o
print 'new.instancemethod()'
im = new.instancemethod(break_yolks, c, C)
if verbose:
    print im
verify(((c.get_yolks() == 3) and (c.get_more_yolks() == 6)), 'Broken call of hand-crafted class instance')
im()
verify(((c.get_yolks() == 1) and (c.get_more_yolks() == 4)), 'Broken call of hand-crafted instance method')
im = new.instancemethod(break_yolks, c)
im()
verify((c.get_yolks() == (-1)))
try:
    new.instancemethod(break_yolks, None)
except TypeError:
    pass
else:
    raise TestFailed, 'dangerous instance method creation allowed'
try:
    new.instancemethod(break_yolks, c, kw=1)
except TypeError:
    pass
else:
    raise TestFailed, "instancemethod shouldn't accept keyword args"
codestr = '\nglobal c\na = 1\nb = 2\nc = a + b\n'
ccode = compile(codestr, '<string>', 'exec')
import __builtin__
g = {'c': 0, '__builtins__': __builtin__, }
print 'new.function()'
func = new.function(ccode, g)
if verbose:
    print func
func()
verify((g['c'] == 3), 'Could not create a proper function object')
g = f(4)
new.function(f.func_code, {}, 'blah')
g2 = new.function(g.func_code, {}, 'blah', (2,), g.func_closure)
verify((g2() == 6))
g3 = new.function(g.func_code, {}, 'blah', None, g.func_closure)
verify((g3(5) == 9))
test_closure(g, None, TypeError)
test_closure(g, (1,), TypeError)
test_closure(g, (1, 1), ValueError)
test_closure(f, g.func_closure, ValueError)
print 'new.code()'
if (hasattr(new, 'code') and (not sys.platform.startswith('java'))):

    def f(a):
        pass
    c = f.func_code
    argcount = c.co_argcount
    nlocals = c.co_nlocals
    stacksize = c.co_stacksize
    flags = c.co_flags
    codestring = c.co_code
    constants = c.co_consts
    names = c.co_names
    varnames = c.co_varnames
    filename = c.co_filename
    name = c.co_name
    firstlineno = c.co_firstlineno
    lnotab = c.co_lnotab
    freevars = c.co_freevars
    cellvars = c.co_cellvars
    d = new.code(argcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, firstlineno, lnotab, freevars, cellvars)
    d = new.code(argcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, firstlineno, lnotab)
    try:
        d = new.code((- argcount), nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, firstlineno, lnotab)
    except ValueError:
        pass
    else:
        raise TestFailed, "negative co_argcount didn't trigger an exception"
    try:
        d = new.code(argcount, (- nlocals), stacksize, flags, codestring, constants, names, varnames, filename, name, firstlineno, lnotab)
    except ValueError:
        pass
    else:
        raise TestFailed, "negative co_nlocals didn't trigger an exception"
    try:
        d = new.code(argcount, nlocals, stacksize, flags, codestring, constants, (5,), varnames, filename, name, firstlineno, lnotab)
    except TypeError:
        pass
    else:
        raise TestFailed, "non-string co_name didn't trigger an exception"


    class S(str):
        pass
    t = (S('ab'),)
    d = new.code(argcount, nlocals, stacksize, flags, codestring, constants, t, varnames, filename, name, firstlineno, lnotab)
    verify((type(t[0]) is S), 'eek, tuple changed under us!')
    if verbose:
        print d
