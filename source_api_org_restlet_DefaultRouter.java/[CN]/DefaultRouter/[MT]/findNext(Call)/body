{
  Scorer result=null;
  if (this.options != null) {
    for (int i=0; (result == null) && (i < getMaxAttempts()); i++) {
      if (i > 0) {
        try {
          Thread.sleep(getRetryDelay());
        }
 catch (        InterruptedException e) {
        }
      }
      Scorer att;
switch (getMode()) {
case BEST_MATCH:
        float bestScore=0F;
      float score;
    for (    Scorer current : getOptions()) {
      score=current.score(call);
      if ((score > bestScore) && (score >= getRequiredScore())) {
        bestScore=score;
        result=current;
      }
    }
  break;
case FIRST_MATCH:
for (int j=0; (result == null) && (j < getOptions().size()); j++) {
  att=getOptions().get(j);
  if (att.score(call) >= getRequiredScore())   result=att;
}
break;
case LAST_MATCH:
for (int j=(getOptions().size() - 1); (result == null) && (j >= 0); j--) {
att=getOptions().get(j);
if (att.score(call) >= getRequiredScore()) result=att;
}
break;
case RANDOM:
int j=new Random().nextInt(getOptions().size());
att=getOptions().get(j);
if (att.score(call) >= getRequiredScore()) result=att;
break;
case ROUND_ROBIN:
synchronized (this) {
lastIndex++;
if (lastIndex >= getOptions().size()) {
lastIndex=0;
}
for (int k=lastIndex; (result == null) && (k < getOptions().size()); k++) {
att=getOptions().get(k);
if (att.score(call) >= getRequiredScore()) result=att;
}
}
break;
}
}
}
if (result == null) {
call.setStatus(Statuses.CLIENT_ERROR_NOT_FOUND);
}
return result;
}
