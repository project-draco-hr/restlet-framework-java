def sample(self, population, k):
    'Chooses k unique random elements from a population sequence.\n\n        Returns a new list containing elements from the population while\n        leaving the original population unchanged.  The resulting list is\n        in selection order so that all sub-slices will also be valid random\n        samples.  This allows raffle winners (the sample) to be partitioned\n        into grand prize and second place winners (the subslices).\n\n        Members of the population need not be hashable or unique.  If the\n        population contains repeats, then each occurrence is a possible\n        selection in the sample.\n\n        To choose a sample in a range of integers, use xrange as an argument.\n        This is especially fast and space efficient for sampling from a\n        large population:   sample(xrange(10000000), 60)\n        '
    n = len(population)
    if (not (0 <= k <= n)):
        raise ValueError, 'sample larger than population'
    random = self.random
    _int = int
    result = ([None] * k)
    setsize = 21
    if (k > 5):
        setsize += (4 ** _ceil(_log((k * 3), 4)))
    if ((n <= setsize) or hasattr(population, 'keys')):
        pool = list(population)
        for i in xrange(k):
            j = _int((random() * (n - i)))
            result[i] = pool[j]
            pool[j] = pool[((n - i) - 1)]
    else:
        try:
            selected = set()
            selected_add = selected.add
            for i in xrange(k):
                j = _int((random() * n))
                while (j in selected):
                    j = _int((random() * n))
                selected_add(j)
                result[i] = population[j]
        except (TypeError, KeyError):
            if isinstance(population, list):
                raise
            return self.sample(tuple(population), k)
    return result
