def generate_tokens(readline):
    '\n    The generate_tokens() generator requires one argment, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects. Each call to the function\n    should return one line of input as a string.\n\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found. The line passed is the\n    logical line; continuation lines are included.\n    '
    lnum = parenlev = continued = 0
    (namechars, numchars) = ((string.ascii_letters + '_'), '0123456789')
    (contstr, needcont) = ('', 0)
    contline = None
    indents = [0]
    while 1:
        line = readline()
        lnum = (lnum + 1)
        (pos, max) = (0, len(line))
        if contstr:
            if (not line):
                raise TokenError, ('EOF in multi-line string', strstart)
            endmatch = endprog.match(line)
            if endmatch:
                pos = end = endmatch.end(0)
                yield (STRING, (contstr + line[:end]), strstart, (lnum, end), (contline + line))
                (contstr, needcont) = ('', 0)
                contline = None
            elif (needcont and (line[(-2):] != '\\\n') and (line[(-3):] != '\\\r\n')):
                yield (ERRORTOKEN, (contstr + line), strstart, (lnum, len(line)), contline)
                contstr = ''
                contline = None
                continue
            else:
                contstr = (contstr + line)
                contline = (contline + line)
                continue
        elif ((parenlev == 0) and (not continued)):
            if (not line):
                break
            column = 0
            while (pos < max):
                if (line[pos] == ' '):
                    column = (column + 1)
                elif (line[pos] == '\t'):
                    column = (((column / tabsize) + 1) * tabsize)
                elif (line[pos] == '\x0c'):
                    column = 0
                else:
                    break
                pos = (pos + 1)
            if (pos == max):
                break
            if (line[pos] in '#\r\n'):
                yield ((NL, COMMENT)[(line[pos] == '#')], line[pos:], (lnum, pos), (lnum, len(line)), line)
                continue
            if (column > indents[(-1)]):
                indents.append(column)
                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
            while (column < indents[(-1)]):
                indents = indents[:(-1)]
                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)
        else:
            if (not line):
                raise TokenError, ('EOF in multi-line statement', (lnum, 0))
            continued = 0
        while (pos < max):
            pseudomatch = pseudoprog.match(line, pos)
            if pseudomatch:
                (start, end) = pseudomatch.span(1)
                (spos, epos, pos) = ((lnum, start), (lnum, end), end)
                (token, initial) = (line[start:end], line[start])
                if ((initial in numchars) or ((initial == '.') and (token != '.'))):
                    yield (NUMBER, token, spos, epos, line)
                elif (initial in '\r\n'):
                    yield ((((parenlev > 0) and NL) or NEWLINE), token, spos, epos, line)
                elif (initial == '#'):
                    yield (COMMENT, token, spos, epos, line)
                elif (token in ("'''", '"""', "r'''", 'r"""', "R'''", 'R"""', "u'''", 'u"""', "U'''", 'U"""', "ur'''", 'ur"""', "Ur'''", 'Ur"""', "uR'''", 'uR"""', "UR'''", 'UR"""')):
                    endprog = endprogs[token]
                    endmatch = endprog.match(line, pos)
                    if endmatch:
                        pos = endmatch.end(0)
                        token = line[start:pos]
                        yield (STRING, token, spos, (lnum, pos), line)
                    else:
                        strstart = (lnum, start)
                        contstr = line[start:]
                        contline = line
                        break
                elif ((initial in ("'", '"')) or (token[:2] in ("r'", 'r"', "R'", 'R"', "u'", 'u"', "U'", 'U"')) or (token[:3] in ("ur'", 'ur"', "Ur'", 'Ur"', "uR'", 'uR"', "UR'", 'UR"'))):
                    if (token[(-1)] == '\n'):
                        strstart = (lnum, start)
                        endprog = (endprogs[initial] or endprogs[token[1]] or endprogs[token[2]])
                        (contstr, needcont) = (line[start:], 1)
                        contline = line
                        break
                    else:
                        yield (STRING, token, spos, epos, line)
                elif (initial in namechars):
                    yield (NAME, token, spos, epos, line)
                elif (initial == '\\'):
                    continued = 1
                else:
                    if (initial in '([{'):
                        parenlev = (parenlev + 1)
                    elif (initial in ')]}'):
                        parenlev = (parenlev - 1)
                    yield (OP, token, spos, epos, line)
            else:
                yield (ERRORTOKEN, line[pos], (lnum, pos), (lnum, (pos + 1)), line)
                pos = (pos + 1)
    for indent in indents[1:]:
        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')
    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')
