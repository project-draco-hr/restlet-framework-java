from collections import deque
import unittest
from test import test_support, seq_tests
from weakref import proxy
import copy
import cPickle as pickle
from cStringIO import StringIO
import random
import os
BIG = 100000
libreftest = '\nExample from the Library Reference:  Doc/lib/libcollections.tex\n\n>>> from collections import deque\n>>> d = deque(\'ghi\')                 # make a new deque with three items\n>>> for elem in d:                   # iterate over the deque\'s elements\n...     print elem.upper()\nG\nH\nI\n>>> d.append(\'j\')                    # add a new entry to the right side\n>>> d.appendleft(\'f\')                # add a new entry to the left side\n>>> d                                # show the representation of the deque\ndeque([\'f\', \'g\', \'h\', \'i\', \'j\'])\n>>> d.pop()                          # return and remove the rightmost item\n\'j\'\n>>> d.popleft()                      # return and remove the leftmost item\n\'f\'\n>>> list(d)                          # list the contents of the deque\n[\'g\', \'h\', \'i\']\n>>> d[0]                             # peek at leftmost item\n\'g\'\n>>> d[-1]                            # peek at rightmost item\n\'i\'\n>>> list(reversed(d))                # list the contents of a deque in reverse\n[\'i\', \'h\', \'g\']\n>>> \'h\' in d                         # search the deque\nTrue\n>>> d.extend(\'jkl\')                  # add multiple elements at once\n>>> d\ndeque([\'g\', \'h\', \'i\', \'j\', \'k\', \'l\'])\n>>> d.rotate(1)                      # right rotation\n>>> d\ndeque([\'l\', \'g\', \'h\', \'i\', \'j\', \'k\'])\n>>> d.rotate(-1)                     # left rotation\n>>> d\ndeque([\'g\', \'h\', \'i\', \'j\', \'k\', \'l\'])\n>>> deque(reversed(d))               # make a new deque in reverse order\ndeque([\'l\', \'k\', \'j\', \'i\', \'h\', \'g\'])\n>>> d.clear()                        # empty the deque\n>>> d.pop()                          # cannot pop from an empty deque\nTraceback (most recent call last):\n  File "<pyshell#6>", line 1, in -toplevel-\n    d.pop()\nIndexError: pop from an empty deque\n\n>>> d.extendleft(\'abc\')              # extendleft() reverses the input order\n>>> d\ndeque([\'c\', \'b\', \'a\'])\n\n\n\n>>> def delete_nth(d, n):\n...     d.rotate(-n)\n...     d.popleft()\n...     d.rotate(n)\n...\n>>> d = deque(\'abcdef\')\n>>> delete_nth(d, 2)   # remove the entry at d[2]\n>>> d\ndeque([\'a\', \'b\', \'d\', \'e\', \'f\'])\n\n\n\n>>> def roundrobin(*iterables):\n...     pending = deque(iter(i) for i in iterables)\n...     while pending:\n...         task = pending.popleft()\n...         try:\n...             yield task.next()\n...         except StopIteration:\n...             continue\n...         pending.append(task)\n...\n\n>>> for value in roundrobin(\'abc\', \'d\', \'efgh\'):\n...     print value\n...\na\nd\ne\nb\nf\nc\ng\nh\n\n\n>>> def maketree(iterable):\n...     d = deque(iterable)\n...     while len(d) > 1:\n...         pair = [d.popleft(), d.popleft()]\n...         d.append(pair)\n...     return list(d)\n...\n>>> print maketree(\'abcdefgh\')\n[[[[\'a\', \'b\'], [\'c\', \'d\']], [[\'e\', \'f\'], [\'g\', \'h\']]]]\n\n'
__test__ = {'libreftest': libreftest, }
if (__name__ == '__main__'):
    test_main(verbose=True)
