{
  getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS,headers);
  if (protocol != null) {
    int slashIndex=protocol.indexOf('/');
    if (slashIndex != -1) {
      protocol=protocol.substring(slashIndex + 1);
    }
 else {
      protocol=null;
    }
  }
  Protocol serverProtocol=getConnection().getHelper().getHelped().getProtocols().get(0);
  setProtocol(new Protocol(serverProtocol.getSchemeName(),serverProtocol.getName(),serverProtocol.getDescription(),serverProtocol.getDefaultPort(),serverProtocol.isConfidential(),protocol));
  String host=(getHeaders() == null) ? null : getHeaders().getFirstValue(HeaderConstants.HEADER_HOST,true);
  String hostDomain=null;
  int hostPort=-1;
  if (host != null) {
    int colonIndex=host.indexOf(':');
    if (colonIndex != -1) {
      hostDomain=host.substring(0,colonIndex);
      hostPort=Integer.valueOf(host.substring(colonIndex + 1));
    }
 else {
      hostDomain=host;
      hostPort=getProtocol().getDefaultPort();
    }
  }
 else {
    if (!Protocol.SIP.getSchemeName().equals(serverProtocol.getSchemeName()) && !Protocol.SIPS.getSchemeName().equals(serverProtocol.getSchemeName())) {
      Context.getCurrentLogger().info("Couldn't find the mandatory \"Host\" HTTP header.");
    }
  }
  Protocol protocol=getConnection().getHelper().getHelped().getProtocols().get(0);
  StringBuilder sb=new StringBuilder();
  sb.append(protocol.getSchemeName()).append("://");
  sb.append(hostDomain);
  if ((hostPort != -1) && (hostPort != protocol.getDefaultPort())) {
    sb.append(':').append(hostPort);
  }
  setHostRef(sb.toString());
  if (resourceUri != null) {
    setResourceRef(new Reference(getHostRef(),resourceUri));
    if (getResourceRef().isRelative()) {
      if (!resourceUri.startsWith("/")) {
        setResourceRef(new Reference(getHostRef().toString() + "/" + resourceUri));
      }
 else {
        setResourceRef(new Reference(getHostRef().toString() + resourceUri));
      }
    }
    setOriginalRef(getResourceRef().getTargetRef());
  }
  String dateHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(HeaderConstants.HEADER_DATE,true);
  Date date=null;
  if (dateHeader != null) {
    date=DateUtils.parse(dateHeader);
  }
  if (date == null) {
    date=new Date();
  }
  setDate(date);
  String maxForwardsHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(HeaderConstants.HEADER_MAX_FORWARDS,true);
  if (maxForwardsHeader != null) {
    try {
      setMaxForwards(Integer.parseInt(maxForwardsHeader));
    }
 catch (    NumberFormatException nfe) {
      Context.getCurrentLogger().info("Unable to parse the Max-Forwards header: " + maxForwardsHeader);
    }
  }
  String callIdHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(SipConstants.HEADER_CALL_ID,true);
  if (callIdHeader != null) {
    setCallId(callIdHeader);
  }
  String callSeqHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(SipConstants.HEADER_CALL_SEQ,true);
  if (callSeqHeader != null) {
    setCommandSequence(callSeqHeader);
  }
  String toHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(SipConstants.HEADER_TO,true);
  if (toHeader != null) {
    try {
      setTo(new AddressReader(toHeader).readValue());
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  String fromHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(HeaderConstants.HEADER_FROM,true);
  if (fromHeader != null) {
    try {
      setFrom(new AddressReader(fromHeader).readValue());
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  String mimeVersionHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(SipConstants.HEADER_MIME_VERSION,true);
  setMimeVersion(mimeVersionHeader);
  String organizationHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(SipConstants.HEADER_ORGANIZATION,true);
  setOrganization(organizationHeader);
  String subjectHeader=(getHeaders() == null) ? null : getHeaders().getFirstValue(SipConstants.HEADER_SUBJECT,true);
  setSubject(subjectHeader);
}
