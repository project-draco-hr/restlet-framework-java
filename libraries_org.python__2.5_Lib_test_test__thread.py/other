from test.test_support import verbose
import random
import thread
import time
mutex = thread.allocate_lock()
rmutex = thread.allocate_lock()
running = 0
done = thread.allocate_lock()
done.acquire()
numtasks = 10
next_ident = 0
for i in range(numtasks):
    newtask()
print 'waiting for all tasks to complete'
done.acquire()
print 'all tasks done'
numtrips = 3
print '\n*** Barrier Test ***'
if done.acquire(0):
    raise ValueError, "'done' should have remained acquired"
bar = barrier(numtasks)
running = numtasks
for i in range(numtasks):
    thread.start_new_thread(task2, (i,))
done.acquire()
print 'all tasks done'
print '\n*** Changing thread stack size ***'
if (thread.stack_size() != 0):
    raise ValueError, 'initial stack_size not 0'
thread.stack_size(0)
if (thread.stack_size() != 0):
    raise ValueError, 'stack_size not reset to default'
from os import name as os_name
if (os_name in ('nt', 'os2', 'posix', 'java')):
    tss_supported = 1
    try:
        thread.stack_size(4096)
    except ValueError:
        print 'caught expected ValueError setting stack_size(4096)'
    except thread.error:
        tss_supported = 0
        print 'platform does not support changing thread stack size'
    if tss_supported:
        failed = (lambda s, e: (s != e))
        fail_msg = 'stack_size(%d) failed - should succeed'
        for tss in (262144, 1048576, 0):
            thread.stack_size(tss)
            if failed(thread.stack_size(), tss):
                raise ValueError, (fail_msg % tss)
            print ('successfully set stack_size(%d)' % tss)
        for tss in (262144, 1048576):
            print ('trying stack_size = %d' % tss)
            next_ident = 0
            for i in range(numtasks):
                newtask()
            print 'waiting for all tasks to complete'
            done.acquire()
            print 'all tasks done'
        thread.stack_size(0)
