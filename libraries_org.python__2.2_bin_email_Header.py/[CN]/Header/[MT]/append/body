def append(self, s, charset=None, errors='strict'):
    "Append a string to the MIME header.\n\n        Optional charset, if given, should be a Charset instance or the name\n        of a character set (which will be converted to a Charset instance).  A\n        value of None (the default) means that the charset given in the\n        constructor is used.\n\n        s may be a byte string or a Unicode string.  If it is a byte string\n        (i.e. isinstance(s, StringType) is true), then charset is the encoding\n        of that byte string, and a UnicodeError will be raised if the string\n        cannot be decoded with that charset.  If s is a Unicode string, then\n        charset is a hint specifying the character set of the characters in\n        the string.  In this case, when producing an RFC 2822 compliant header\n        using RFC 2047 rules, the Unicode string will be encoded using the\n        following charsets in order: us-ascii, the charset hint, utf-8.  The\n        first character set not to provoke a UnicodeError is used.\n\n        Optional `errors' is passed as the third argument to any unicode() or\n        ustr.encode() call.\n        "
    if (charset is None):
        charset = self._charset
    elif (not isinstance(charset, Charset)):
        charset = Charset(charset)
    if (charset != '8bit'):
        if isinstance(s, StringType):
            incodec = (charset.input_codec or 'us-ascii')
            ustr = unicode(s, incodec, errors)
            outcodec = (charset.output_codec or 'us-ascii')
            ustr.encode(outcodec, errors)
        elif isinstance(s, UnicodeType):
            for charset in (USASCII, charset, UTF8):
                try:
                    outcodec = (charset.output_codec or 'us-ascii')
                    s = s.encode(outcodec, errors)
                    break
                except UnicodeError:
                    pass
            else:
                assert False, 'utf-8 conversion failed'
    self._chunks.append((s, charset))
