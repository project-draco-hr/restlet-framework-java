'Open an arbitrary URL.\n\nSee the following document for more info on URLs:\n"Names and Addresses, URIs, URLs, URNs, URCs", at\nhttp://www.w3.org/pub/WWW/Addressing/Overview.html\n\nSee also the HTTP spec (from which the error codes are derived):\n"HTTP - Hypertext Transfer Protocol", at\nhttp://www.w3.org/pub/WWW/Protocols/\n\nRelated standards and specs:\n- RFC1808: the "relative URL" spec. (authoritative status)\n- RFC1738 - the "URL standard". (authoritative status)\n- RFC1630 - the "URI spec". (informational status)\n\nThe object returned by URLopener().open(file) will differ per\nprotocol.  All you know is that is has methods read(), readline(),\nreadlines(), fileno(), close() and info().  The read*(), fileno()\nand close() methods work like those of open files.\nThe info() method returns a mimetools.Message object which can be\nused to query various info about the object, if available.\n(mimetools.Message objects are queried with the getheader() method.)\n'
import string
import socket
import os
import stat
import time
import sys
import types
__all__ = ['urlopen', 'URLopener', 'FancyURLopener', 'urlretrieve', 'urlcleanup', 'quote', 'quote_plus', 'unquote', 'unquote_plus', 'urlencode', 'url2pathname', 'pathname2url', 'splittag', 'localhost', 'thishost', 'ftperrors', 'basejoin', 'unwrap', 'splittype', 'splithost', 'splituser', 'splitpasswd', 'splitport', 'splitnport', 'splitquery', 'splitattr', 'splitvalue', 'splitgophertype', 'getproxies']
__version__ = '1.15'
MAXFTPCACHE = 10
if (os.name == 'mac'):
    from macurl2path import url2pathname, pathname2url
elif (os.name == 'nt'):
    from nturl2path import url2pathname, pathname2url
elif (os.name == 'riscos'):
    from rourl2path import url2pathname, pathname2url
else:

    def url2pathname(pathname):
        return unquote(pathname)

    def pathname2url(pathname):
        return quote(pathname)
_urlopener = None
ftpcache = {}
_localhost = None
_thishost = None
_ftperrors = None
_noheaders = None
_typeprog = None
_hostprog = None
_userprog = None
_passwdprog = None
_portprog = None
_nportprog = None
_queryprog = None
_tagprog = None
_valueprog = None
always_safe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-'
_fast_safe_test = (always_safe + '/')
_fast_safe = None
if (os.name == 'mac'):

    def getproxies():
        'Return a dictionary of scheme -> proxy server URL mappings.\n\n        By convention the mac uses Internet Config to store\n        proxies.  An HTTP proxy, for instance, is stored under\n        the HttpProxy key.\n\n        '
        try:
            import ic
        except ImportError:
            return {}
        try:
            config = ic.IC()
        except ic.error:
            return {}
        proxies = {}
        if (config.has_key('UseHTTPProxy') and config['UseHTTPProxy']):
            try:
                value = config['HTTPProxyHost']
            except ic.error:
                pass
            else:
                proxies['http'] = ('http://%s' % value)
        return proxies

    def proxy_bypass(x):
        return 0
elif (os.name == 'nt'):

    def getproxies_registry():
        'Return a dictionary of scheme -> proxy server URL mappings.\n\n        Win32 uses the registry to store proxies.\n\n        '
        proxies = {}
        try:
            import _winreg
        except ImportError:
            return proxies
        try:
            internetSettings = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, 'Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings')
            proxyEnable = _winreg.QueryValueEx(internetSettings, 'ProxyEnable')[0]
            if proxyEnable:
                proxyServer = str(_winreg.QueryValueEx(internetSettings, 'ProxyServer')[0])
                if ('=' in proxyServer):
                    for p in proxyServer.split(';'):
                        (protocol, address) = p.split('=', 1)
                        import re
                        if (not re.match('^([^/:]+)://', address)):
                            address = ('%s://%s' % (protocol, address))
                        proxies[protocol] = address
                elif (proxyServer[:5] == 'http:'):
                    proxies['http'] = proxyServer
                else:
                    proxies['http'] = ('http://%s' % proxyServer)
                    proxies['ftp'] = ('ftp://%s' % proxyServer)
            internetSettings.Close()
        except (WindowsError, ValueError, TypeError):
            pass
        return proxies

    def getproxies():
        'Return a dictionary of scheme -> proxy server URL mappings.\n\n        Returns settings gathered from the environment, if specified,\n        or the registry.\n\n        '
        return (getproxies_environment() or getproxies_registry())

    def proxy_bypass(host):
        try:
            import _winreg
            import re
            import socket
        except ImportError:
            return 0
        try:
            internetSettings = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, 'Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings')
            proxyEnable = _winreg.QueryValueEx(internetSettings, 'ProxyEnable')[0]
            proxyOverride = str(_winreg.QueryValueEx(internetSettings, 'ProxyOverride')[0])
        except WindowsError:
            return 0
        if ((not proxyEnable) or (not proxyOverride)):
            return 0
        host = [host]
        try:
            addr = socket.gethostbyname(host[0])
            if (addr != host):
                host.append(addr)
        except socket.error:
            pass
        proxyOverride = proxyOverride.split(';')
        i = 0
        while (i < len(proxyOverride)):
            if (proxyOverride[i] == '<local>'):
                proxyOverride[i:(i + 1)] = ['localhost', '127.0.0.1', socket.gethostname(), socket.gethostbyname(socket.gethostname())]
            i += 1
        for test in proxyOverride:
            test = test.replace('.', '\\.')
            test = test.replace('*', '.*')
            test = test.replace('?', '.')
            for val in host:
                if re.match(test, val, re.I):
                    return 1
        return 0
else:
    getproxies = getproxies_environment

    def proxy_bypass(host):
        return 0
if (__name__ == '__main__'):
    main()
