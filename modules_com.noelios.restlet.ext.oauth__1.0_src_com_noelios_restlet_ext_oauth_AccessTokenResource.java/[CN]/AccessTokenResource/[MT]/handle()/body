{
  final OAuthMessage requestMessage=OAuthHelper.getMessage(getRequest(),getLogger());
  final OAuthAccessor accessor=this.provider.getAccessor(requestMessage);
  final ChallengeRequest challengeRequest=new ChallengeRequest(ChallengeScheme.HTTP_OAUTH,this.realm);
  if (accessor == null) {
    getResponse().setChallengeRequest(challengeRequest);
    getResponse().setStatus(Status.CLIENT_ERROR_UNAUTHORIZED,"Invalid Consumer Key");
    challengeRequest.getParameters().add("oauth_problem","consumer_key_unknown");
    return;
  }
  try {
    requestMessage.validateSignature(accessor);
  }
 catch (  final Exception e1) {
    getResponse().setChallengeRequest(challengeRequest);
    getResponse().setStatus(Status.CLIENT_ERROR_UNAUTHORIZED,e1);
    challengeRequest.getParameters().add("oauth_problem","signature_invalid");
    return;
  }
  if (!Boolean.TRUE.equals(accessor.getProperty("authorized"))) {
    getResponse().setChallengeRequest(challengeRequest);
    getResponse().setStatus(Status.CLIENT_ERROR_UNAUTHORIZED,"Invalid / expired Token");
    challengeRequest.getParameters().add("oauth_problem","token_rejected");
    return;
  }
  this.provider.generateAccessToken(accessor);
  try {
    getResponse().setEntity(new StringRepresentation(OAuth.formEncode(OAuth.newList("oauth_token",accessor.accessToken,"oauth_token_secret",accessor.tokenSecret))));
  }
 catch (  final IOException e) {
    throw new ResourceException(e);
  }
}
