{
  File file=new File(LocalReference.localizePath(path));
  MetadataService metadataService=getMetadataService(request);
  if (request.getMethod().equals(Method.GET) || request.getMethod().equals(Method.HEAD)) {
    Representation output=null;
    boolean found=false;
    Iterator<Preference<MediaType>> iterator=request.getClientInfo().getAcceptedMediaTypes().iterator();
    while (iterator.hasNext() && !found) {
      Preference<MediaType> pref=iterator.next();
      found=pref.getMetadata().equals(MediaType.TEXT_URI_LIST);
    }
    if (found) {
      String baseName=getBaseName(file,metadataService);
      File[] files=file.getParentFile().listFiles();
      ReferenceList rl=new ReferenceList(files.length);
      rl.setIdentifier(request.getResourceRef());
      for (      File entry : files) {
        try {
          if (entry.getName().startsWith(baseName)) {
            rl.add(LocalReference.createFileReference(entry));
          }
        }
 catch (        IOException ioe) {
          getLogger().log(Level.WARNING,"Unable to create file reference",ioe);
        }
      }
      output=rl.getTextRepresentation();
    }
 else {
      if ((file != null) && file.exists()) {
        if (file.isDirectory()) {
          File[] files=file.listFiles();
          ReferenceList rl=new ReferenceList(files.length);
          rl.setIdentifier(request.getResourceRef());
          for (          File entry : files) {
            try {
              rl.add(LocalReference.createFileReference(entry));
            }
 catch (            IOException ioe) {
              getLogger().log(Level.WARNING,"Unable to create file reference",ioe);
            }
          }
          output=rl.getTextRepresentation();
        }
 else {
          output=new FileRepresentation(file,metadataService.getDefaultMediaType(),getTimeToLive());
          updateMetadata(metadataService,file.getName(),output);
        }
      }
    }
    if (output == null) {
      response.setStatus(Status.CLIENT_ERROR_NOT_FOUND);
    }
 else {
      response.setEntity(output);
      response.setStatus(Status.SUCCESS_OK);
    }
  }
 else   if (request.getMethod().equals(Method.PUT)) {
    if (!checkMetadataConsistency(file.getName(),metadataService,request.getEntity())) {
      response.setStatus(new Status(Status.REDIRECTION_SEE_OTHER,"The metadata are not consistent with the URI"));
    }
 else {
      boolean isDirectory=false;
      if (file.exists()) {
        if (file.isDirectory()) {
          isDirectory=true;
          response.setStatus(new Status(Status.CLIENT_ERROR_FORBIDDEN,"Can't put a new representation of a directory"));
        }
      }
 else {
        if (path.endsWith("/")) {
          isDirectory=true;
          if (file.mkdirs()) {
            response.setStatus(Status.SUCCESS_NO_CONTENT);
          }
 else {
            getLogger().log(Level.WARNING,"Unable to create the new directory");
            response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to create the new directory"));
          }
        }
      }
      if (!isDirectory) {
        String baseName=getBaseName(file,metadataService);
        Set<String> extensions=getExtensions(file,metadataService);
        File[] files=file.getParentFile().listFiles();
        File uniqueVariant=null;
        List<File> variantsList=new ArrayList<File>();
        for (        File entry : files) {
          if (entry.getName().startsWith(baseName)) {
            Set<String> entryExtensions=getExtensions(entry,metadataService);
            if (entryExtensions.containsAll(extensions)) {
              variantsList.add(entry);
              if (extensions.containsAll(entryExtensions)) {
                uniqueVariant=entry;
              }
            }
          }
        }
        if (uniqueVariant != null) {
          file=uniqueVariant;
        }
 else {
          if (!variantsList.isEmpty()) {
            response.setStatus(new Status(Status.CLIENT_ERROR_UNAUTHORIZED,"Unable to process properly the request. Several variants exist but none of them suits precisely."));
          }
 else {
            updateMetadata(metadataService,file.getName(),request.getEntity());
            if (request.getEntity().getLanguages().isEmpty()) {
              if (metadataService.getDefaultLanguage() != null) {
                request.getEntity().getLanguages().add(metadataService.getDefaultLanguage());
              }
            }
            if (request.getEntity().getMediaType() == null) {
              request.getEntity().setMediaType(metadataService.getDefaultMediaType());
            }
            if (request.getEntity().getEncodings().isEmpty()) {
              if (metadataService.getDefaultEncoding() != null && !metadataService.getDefaultEncoding().equals(Encoding.IDENTITY)) {
                request.getEntity().getEncodings().add(metadataService.getDefaultEncoding());
              }
            }
            StringBuilder fileName=new StringBuilder(baseName);
            if (metadataService.getExtension(request.getEntity().getMediaType()) != null) {
              fileName.append("." + metadataService.getExtension(request.getEntity().getMediaType()));
            }
            for (            Language language : request.getEntity().getLanguages()) {
              if (metadataService.getExtension(language) != null) {
                fileName.append("." + metadataService.getExtension(language));
              }
            }
            for (            Encoding encoding : request.getEntity().getEncodings()) {
              if (metadataService.getExtension(encoding) != null) {
                fileName.append("." + metadataService.getExtension(encoding));
              }
            }
            file=new File(file.getParentFile(),fileName.toString());
          }
        }
        if (!checkExtensionsConsistency(file,metadataService)) {
          response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to process properly the URI. At least one extension is not known by the server."));
        }
 else {
          File tmp=null;
          if (file.exists()) {
            FileOutputStream fos=null;
            try {
              tmp=File.createTempFile("restlet-upload","bin");
              if (request.isEntityAvailable()) {
                fos=new FileOutputStream(tmp);
                ByteUtils.write(request.getEntity().getStream(),fos);
              }
            }
 catch (            IOException ioe) {
              getLogger().log(Level.WARNING,"Unable to create the temporary file",ioe);
              response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to create a temporary file"));
            }
 finally {
              try {
                if (fos != null)                 fos.close();
              }
 catch (              IOException ioe) {
                getLogger().log(Level.WARNING,"Unable to close the temporary file",ioe);
                response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to close a temporary file"));
              }
            }
            if (file.delete()) {
              if ((tmp != null) && tmp.renameTo(file)) {
                if (request.getEntity() == null) {
                  response.setStatus(Status.SUCCESS_NO_CONTENT);
                }
 else {
                  response.setStatus(Status.SUCCESS_OK);
                }
              }
 else {
                getLogger().log(Level.WARNING,"Unable to move the temporary file to replace the existing file");
                response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to move the temporary file to replace the existing file"));
              }
            }
 else {
              getLogger().log(Level.WARNING,"Unable to delete the existing file");
              response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to delete the existing file"));
            }
          }
 else {
            File parent=file.getParentFile();
            if ((parent != null) && parent.isDirectory()) {
              if (!parent.exists()) {
                if (!parent.mkdirs()) {
                  getLogger().log(Level.WARNING,"Unable to create the parent directory");
                  response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to create the parent directory"));
                }
              }
            }
            FileOutputStream fos=null;
            try {
              if (file.createNewFile()) {
                if (request.getEntity() == null) {
                  response.setStatus(Status.SUCCESS_NO_CONTENT);
                }
 else {
                  fos=new FileOutputStream(file);
                  ByteUtils.write(request.getEntity().getStream(),fos);
                  response.setStatus(Status.SUCCESS_CREATED);
                }
              }
 else {
                getLogger().log(Level.WARNING,"Unable to create the new file");
                response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to create the new file"));
              }
            }
 catch (            FileNotFoundException fnfe) {
              getLogger().log(Level.WARNING,"Unable to create the new file",fnfe);
              response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to create the new file"));
            }
catch (            IOException ioe) {
              getLogger().log(Level.WARNING,"Unable to create the new file",ioe);
              response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to create the new file"));
            }
 finally {
              try {
                if (fos != null)                 fos.close();
              }
 catch (              IOException ioe) {
                getLogger().log(Level.WARNING,"Unable to close the temporary file",ioe);
                response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Unable to close a temporary file"));
              }
            }
          }
        }
      }
    }
  }
 else   if (request.getMethod().equals(Method.DELETE)) {
    if (file.isDirectory()) {
      if (file.listFiles().length == 0) {
        response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Couldn't delete the empty directory"));
      }
 else {
        response.setStatus(new Status(Status.CLIENT_ERROR_FORBIDDEN,"Couldn't delete the non-empty directory"));
      }
    }
 else {
      if (file.delete()) {
        response.setStatus(Status.SUCCESS_NO_CONTENT);
      }
 else {
        response.setStatus(new Status(Status.SERVER_ERROR_INTERNAL,"Couldn't delete the file"));
      }
    }
  }
 else {
    response.setStatus(Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
    response.getAllowedMethods().add(Method.GET);
    response.getAllowedMethods().add(Method.HEAD);
    response.getAllowedMethods().add(Method.PUT);
    response.getAllowedMethods().add(Method.DELETE);
  }
}
