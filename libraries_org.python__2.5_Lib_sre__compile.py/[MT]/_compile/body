def _compile(code, pattern, flags):
    emit = code.append
    _len = len
    LITERAL_CODES = _LITERAL_CODES
    REPEATING_CODES = _REPEATING_CODES
    SUCCESS_CODES = _SUCCESS_CODES
    ASSERT_CODES = _ASSERT_CODES
    for (op, av) in pattern:
        if (op in LITERAL_CODES):
            if (flags & SRE_FLAG_IGNORECASE):
                emit(OPCODES[OP_IGNORE[op]])
                emit(_sre.getlower(av, flags))
            else:
                emit(OPCODES[op])
                emit(av)
        elif (op is IN):
            if (flags & SRE_FLAG_IGNORECASE):
                emit(OPCODES[OP_IGNORE[op]])

                def fixup(literal, flags=flags):
                    return _sre.getlower(literal, flags)
            else:
                emit(OPCODES[op])
                fixup = _identityfunction
            skip = _len(code)
            emit(0)
            _compile_charset(av, flags, code, fixup)
            code[skip] = (_len(code) - skip)
        elif (op is ANY):
            if (flags & SRE_FLAG_DOTALL):
                emit(OPCODES[ANY_ALL])
            else:
                emit(OPCODES[ANY])
        elif (op in REPEATING_CODES):
            if (flags & SRE_FLAG_TEMPLATE):
                raise error, 'internal: unsupported template operator'
                emit(OPCODES[REPEAT])
                skip = _len(code)
                emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                emit(OPCODES[SUCCESS])
                code[skip] = (_len(code) - skip)
            elif (_simple(av) and (op is not REPEAT)):
                if (op is MAX_REPEAT):
                    emit(OPCODES[REPEAT_ONE])
                else:
                    emit(OPCODES[MIN_REPEAT_ONE])
                skip = _len(code)
                emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                emit(OPCODES[SUCCESS])
                code[skip] = (_len(code) - skip)
            else:
                emit(OPCODES[REPEAT])
                skip = _len(code)
                emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                code[skip] = (_len(code) - skip)
                if (op is MAX_REPEAT):
                    emit(OPCODES[MAX_UNTIL])
                else:
                    emit(OPCODES[MIN_UNTIL])
        elif (op is SUBPATTERN):
            if av[0]:
                emit(OPCODES[MARK])
                emit(((av[0] - 1) * 2))
            _compile(code, av[1], flags)
            if av[0]:
                emit(OPCODES[MARK])
                emit((((av[0] - 1) * 2) + 1))
        elif (op in SUCCESS_CODES):
            emit(OPCODES[op])
        elif (op in ASSERT_CODES):
            emit(OPCODES[op])
            skip = _len(code)
            emit(0)
            if (av[0] >= 0):
                emit(0)
            else:
                (lo, hi) = av[1].getwidth()
                if (lo != hi):
                    raise error, 'look-behind requires fixed-width pattern'
                emit(lo)
            _compile(code, av[1], flags)
            emit(OPCODES[SUCCESS])
            code[skip] = (_len(code) - skip)
        elif (op is CALL):
            emit(OPCODES[op])
            skip = _len(code)
            emit(0)
            _compile(code, av, flags)
            emit(OPCODES[SUCCESS])
            code[skip] = (_len(code) - skip)
        elif (op is AT):
            emit(OPCODES[op])
            if (flags & SRE_FLAG_MULTILINE):
                av = AT_MULTILINE.get(av, av)
            if (flags & SRE_FLAG_LOCALE):
                av = AT_LOCALE.get(av, av)
            elif (flags & SRE_FLAG_UNICODE):
                av = AT_UNICODE.get(av, av)
            emit(ATCODES[av])
        elif (op is BRANCH):
            emit(OPCODES[op])
            tail = []
            tailappend = tail.append
            for av in av[1]:
                skip = _len(code)
                emit(0)
                _compile(code, av, flags)
                emit(OPCODES[JUMP])
                tailappend(_len(code))
                emit(0)
                code[skip] = (_len(code) - skip)
            emit(0)
            for tail in tail:
                code[tail] = (_len(code) - tail)
        elif (op is CATEGORY):
            emit(OPCODES[op])
            if (flags & SRE_FLAG_LOCALE):
                av = CH_LOCALE[av]
            elif (flags & SRE_FLAG_UNICODE):
                av = CH_UNICODE[av]
            emit(CHCODES[av])
        elif (op is GROUPREF):
            if (flags & SRE_FLAG_IGNORECASE):
                emit(OPCODES[OP_IGNORE[op]])
            else:
                emit(OPCODES[op])
            emit((av - 1))
        elif (op is GROUPREF_EXISTS):
            emit(OPCODES[op])
            emit((av[0] - 1))
            skipyes = _len(code)
            emit(0)
            _compile(code, av[1], flags)
            if av[2]:
                emit(OPCODES[JUMP])
                skipno = _len(code)
                emit(0)
                code[skipyes] = ((_len(code) - skipyes) + 1)
                _compile(code, av[2], flags)
                code[skipno] = (_len(code) - skipno)
            else:
                code[skipyes] = ((_len(code) - skipyes) + 1)
        else:
            raise ValueError, ('unsupported operand type', op)
