def parse_request(self):
    'Parse a request (internal).\n\n        The request should be stored in self.raw_requestline; the results\n        are in self.command, self.path, self.request_version and\n        self.headers.\n\n        Return True for success, False for failure; on failure, an\n        error is sent back.\n\n        '
    self.command = None
    self.request_version = version = 'HTTP/0.9'
    self.close_connection = 1
    requestline = self.raw_requestline
    if (requestline[(-2):] == '\r\n'):
        requestline = requestline[:(-2)]
    elif (requestline[(-1):] == '\n'):
        requestline = requestline[:(-1)]
    self.requestline = requestline
    words = requestline.split()
    if (len(words) == 3):
        [command, path, version] = words
        if (version[:5] != 'HTTP/'):
            self.send_error(400, ('Bad request version (%r)' % version))
            return False
        try:
            base_version_number = version.split('/', 1)[1]
            version_number = base_version_number.split('.')
            if (len(version_number) != 2):
                raise ValueError
            version_number = (int(version_number[0]), int(version_number[1]))
        except (ValueError, IndexError):
            self.send_error(400, ('Bad request version (%r)' % version))
            return False
        if ((version_number >= (1, 1)) and (self.protocol_version >= 'HTTP/1.1')):
            self.close_connection = 0
        if (version_number >= (2, 0)):
            self.send_error(505, ('Invalid HTTP Version (%s)' % base_version_number))
            return False
    elif (len(words) == 2):
        [command, path] = words
        self.close_connection = 1
        if (command != 'GET'):
            self.send_error(400, ('Bad HTTP/0.9 request type (%r)' % command))
            return False
    elif (not words):
        return False
    else:
        self.send_error(400, ('Bad request syntax (%r)' % requestline))
        return False
    (self.command, self.path, self.request_version) = (command, path, version)
    self.headers = self.MessageClass(self.rfile, 0)
    conntype = self.headers.get('Connection', '')
    if (conntype.lower() == 'close'):
        self.close_connection = 1
    elif ((conntype.lower() == 'keep-alive') and (self.protocol_version >= 'HTTP/1.1')):
        self.close_connection = 0
    return True
