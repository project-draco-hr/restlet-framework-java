def link(self, target_desc, objects, output_filename, output_dir=None, libraries=None, library_dirs=None, runtime_library_dirs=None, export_symbols=None, debug=0, extra_preargs=None, extra_postargs=None, build_temp=None, target_lang=None):
    (objects, output_dir) = self._fix_object_args(objects, output_dir)
    (libraries, library_dirs, runtime_library_dirs) = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
    lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)
    if (type(output_dir) not in (StringType, NoneType)):
        raise TypeError, "'output_dir' must be a string or None"
    if (output_dir is not None):
        output_filename = os.path.join(output_dir, output_filename)
    if self._need_link(objects, output_filename):
        ld_args = (((objects + self.objects) + lib_opts) + ['-o', output_filename])
        if debug:
            ld_args[:0] = ['-g']
        if extra_preargs:
            ld_args[:0] = extra_preargs
        if extra_postargs:
            ld_args.extend(extra_postargs)
        self.mkpath(os.path.dirname(output_filename))
        try:
            if (target_desc == CCompiler.EXECUTABLE):
                linker = self.linker_exe[:]
            else:
                linker = self.linker_so[:]
            if ((target_lang == 'c++') and self.compiler_cxx):
                i = 0
                if (os.path.basename(linker[0]) == 'env'):
                    i = 1
                    while ('=' in linker[i]):
                        i = (i + 1)
                linker[i] = self.compiler_cxx[i]
            if (sys.platform == 'darwin'):
                linker = _darwin_compiler_fixup(linker, ld_args)
            self.spawn((linker + ld_args))
        except DistutilsExecError as msg:
            raise LinkError, msg
    else:
        log.debug('skipping %s (up-to-date)', output_filename)
