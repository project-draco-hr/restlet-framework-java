source = '# line 1\n\'A module docstring.\'\n\nimport sys, inspect\n# line 5\n\n# line 7\ndef spam(a, b, c, d=3, (e, (f,))=(4, (5,)), *g, **h):\n    eggs(b + d, c + f)\n\n# line 11\ndef eggs(x, y):\n    "A docstring."\n    global fr, st\n    fr = inspect.currentframe()\n    st = inspect.stack()\n    p = x\n    q = y / 0\n\n# line 20\nclass StupidGit:\n    """A longer,\n\n    indented\n\n    docstring."""\n# line 27\n\n    def abuse(self, a, b, c):\n        """Another\n\n\tdocstring\n\n        containing\n\n\ttabs\n\t\n        """\n        self.argue(a, b, c)\n# line 40\n    def argue(self, a, b, c):\n        try:\n            spam(a, b, c)\n        except:\n            self.ex = sys.exc_info()\n            self.tr = inspect.trace()\n\n# line 48\nclass MalodorousPervert(StupidGit):\n    pass\n\nclass ParrotDroppings:\n    pass\n\nclass FesteringGob(MalodorousPervert, ParrotDroppings):\n    pass\n'
from test_support import TestFailed, TESTFN, is_jython
import sys, imp, os, string
import inspect
file = open(TESTFN, 'w')
file.write(source)
file.close()
mod = imp.load_source('testmod', TESTFN)
files_to_clean_up = [TESTFN, (TESTFN + 'c'), (TESTFN + 'o')]
git = mod.StupidGit()
try:
    (1 / 0)
except:
    tb = sys.exc_traceback
istest(inspect.isbuiltin, 'ord')
istest(inspect.isbuiltin, '[].append')
istest(inspect.isclass, 'mod.StupidGit')
istest(inspect.iscode, 'mod.spam.func_code')
istest(inspect.isframe, 'tb.tb_frame')
istest(inspect.isfunction, 'mod.spam')
istest(inspect.ismethod, 'mod.StupidGit.abuse')
istest(inspect.ismethod, 'git.argue')
istest(inspect.ismodule, 'mod')
istest(inspect.istraceback, 'tb')
test(inspect.isroutine(mod.spam), 'isroutine(mod.spam)')
test(inspect.isroutine([].count), 'isroutine([].count)')
classes = inspect.getmembers(mod, inspect.isclass)
test((classes == [('FesteringGob', mod.FesteringGob), ('MalodorousPervert', mod.MalodorousPervert), ('ParrotDroppings', mod.ParrotDroppings), ('StupidGit', mod.StupidGit)]), 'class list')
tree = inspect.getclasstree(map((lambda x: x[1]), classes), 1)
test((tree == [(mod.ParrotDroppings, ()), (mod.StupidGit, ()), [(mod.MalodorousPervert, (mod.StupidGit,)), [(mod.FesteringGob, (mod.MalodorousPervert, mod.ParrotDroppings))]]]), 'class tree')
functions = inspect.getmembers(mod, inspect.isfunction)
test((functions == [('eggs', mod.eggs), ('spam', mod.spam)]), 'function list')
test((inspect.getdoc(mod) == 'A module docstring.'), 'getdoc(mod)')
test((inspect.getcomments(mod) == '# line 1\n'), 'getcomments(mod)')
test((inspect.getmodule(mod.StupidGit) == mod), 'getmodule(mod.StupidGit)')
test((inspect.getfile(mod.StupidGit) == TESTFN), 'getfile(mod.StupidGit)')
test((inspect.getsourcefile(mod.spam) == TESTFN), 'getsourcefile(mod.spam)')
test((inspect.getsourcefile(git.abuse) == TESTFN), 'getsourcefile(git.abuse)')
test((inspect.getsource(git.abuse) == sourcerange(29, 39)), 'getsource(git.abuse)')
test((inspect.getsource(mod.StupidGit) == sourcerange(21, 46)), 'getsource(mod.StupidGit)')
test((inspect.getdoc(mod.StupidGit) == 'A longer,\n\nindented\n\ndocstring.'), 'getdoc(mod.StupidGit)')
test((inspect.getdoc(git.abuse) == 'Another\n\ndocstring\n\ncontaining\n\ntabs\n\n'), 'getdoc(git.abuse)')
test((inspect.getcomments(mod.StupidGit) == '# line 20\n'), 'getcomments(mod.StupidGit)')
(args, varargs, varkw, defaults) = inspect.getargspec(mod.eggs)
test((args == ['x', 'y']), 'mod.eggs args')
test((varargs == None), 'mod.eggs varargs')
test((varkw == None), 'mod.eggs varkw')
test((defaults == None), 'mod.eggs defaults')
test((inspect.formatargspec(args, varargs, varkw, defaults) == '(x, y)'), 'mod.eggs formatted argspec')
if (not is_jython):
    (args, varargs, varkw, defaults) = inspect.getargspec(mod.spam)
    test((args == ['a', 'b', 'c', 'd', ['e', ['f']]]), 'mod.spam args')
    test((varargs == 'g'), 'mod.spam varargs')
    test((varkw == 'h'), 'mod.spam varkw')
    test((defaults == (3, (4, (5,)))), 'mod.spam defaults')
    test((inspect.formatargspec(args, varargs, varkw, defaults) == '(a, b, c, d=3, (e, (f,))=(4, (5,)), *g, **h)'), 'mod.spam formatted argspec')
git.abuse(7, 8, 9)
istest(inspect.istraceback, 'git.ex[2]')
istest(inspect.isframe, 'mod.fr')
test((len(git.tr) == 3), 'trace() length')
test((git.tr[0][1:] == (TESTFN, 46, 'argue', ['            self.tr = inspect.trace()\n'], 0)), 'trace() row 2')
test((git.tr[1][1:] == (TESTFN, 9, 'spam', ['    eggs(b + d, c + f)\n'], 0)), 'trace() row 2')
test((git.tr[2][1:] == (TESTFN, 18, 'eggs', ['    q = y / 0\n'], 0)), 'trace() row 3')
test((len(mod.st) >= 5), 'stack() length')
test((mod.st[0][1:] == (TESTFN, 16, 'eggs', ['    st = inspect.stack()\n'], 0)), 'stack() row 1')
test((mod.st[1][1:] == (TESTFN, 9, 'spam', ['    eggs(b + d, c + f)\n'], 0)), 'stack() row 2')
test((mod.st[2][1:] == (TESTFN, 43, 'argue', ['            spam(a, b, c)\n'], 0)), 'stack() row 3')
test((mod.st[3][1:] == (TESTFN, 39, 'abuse', ['        self.argue(a, b, c)\n'], 0)), 'stack() row 4')
(args, varargs, varkw, locals) = inspect.getargvalues(mod.fr)
test((args == ['x', 'y']), 'mod.fr args')
test((varargs == None), 'mod.fr varargs')
test((varkw == None), 'mod.fr varkw')
test((locals == {'x': 11, 'p': 11, 'y': 14, }), 'mod.fr locals')
test((inspect.formatargvalues(args, varargs, varkw, locals) == '(x=11, y=14)'), 'mod.fr formatted argvalues')
if (not is_jython):
    (args, varargs, varkw, locals) = inspect.getargvalues(mod.fr.f_back)
    test((args == ['a', 'b', 'c', 'd', ['e', ['f']]]), 'mod.fr.f_back args')
    test((varargs == 'g'), 'mod.fr.f_back varargs')
    test((varkw == 'h'), 'mod.fr.f_back varkw')
    test((inspect.formatargvalues(args, varargs, varkw, locals) == '(a=7, b=8, c=9, d=3, (e=4, (f=5,)), *g=(), **h={})'), 'mod.fr.f_back formatted argvalues')
for fname in files_to_clean_up:
    try:
        os.unlink(fname)
    except:
        pass
expected = (D, B, A, C)
got = inspect.getmro(D)
test((expected == got), 'expected %r mro, got %r', expected, got)
expected = (D, B, C, A, object)
got = inspect.getmro(D)
test((expected == got), 'expected %r mro, got %r', expected, got)
attrs = attrs_wo_objs(A)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'class method', A) in attrs), 'missing class method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', A) in attrs), 'missing plain method')
test((('m1', 'method', A) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
attrs = attrs_wo_objs(B)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'class method', A) in attrs), 'missing class method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', B) in attrs), 'missing plain method')
test((('m1', 'method', A) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
attrs = attrs_wo_objs(C)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'method', C) in attrs), 'missing plain method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', C) in attrs), 'missing plain method')
test((('m1', 'method', A) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
attrs = attrs_wo_objs(D)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'class method', A) in attrs), 'missing class method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', B) in attrs), 'missing plain method')
test((('m1', 'method', D) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
attrs = attrs_wo_objs(A)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'class method', A) in attrs), 'missing class method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', A) in attrs), 'missing plain method')
test((('m1', 'method', A) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
attrs = attrs_wo_objs(B)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'class method', A) in attrs), 'missing class method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', B) in attrs), 'missing plain method')
test((('m1', 'method', A) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
attrs = attrs_wo_objs(C)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'method', C) in attrs), 'missing plain method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', C) in attrs), 'missing plain method')
test((('m1', 'method', A) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
attrs = attrs_wo_objs(D)
test((('s', 'static method', A) in attrs), 'missing static method')
test((('c', 'method', C) in attrs), 'missing plain method')
test((('p', 'property', A) in attrs), 'missing property')
test((('m', 'method', B) in attrs), 'missing plain method')
test((('m1', 'method', D) in attrs), 'missing plain method')
test((('datablob', 'data', A) in attrs), 'missing data')
