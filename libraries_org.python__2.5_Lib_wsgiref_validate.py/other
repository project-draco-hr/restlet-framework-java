"\nMiddleware to check for obedience to the WSGI specification.\n\nSome of the things this checks:\n\n* Signature of the application and start_response (including that\n  keyword arguments are not used).\n\n* Environment checks:\n\n  - Environment is a dictionary (and not a subclass).\n\n  - That all the required keys are in the environment: REQUEST_METHOD,\n    SERVER_NAME, SERVER_PORT, wsgi.version, wsgi.input, wsgi.errors,\n    wsgi.multithread, wsgi.multiprocess, wsgi.run_once\n\n  - That HTTP_CONTENT_TYPE and HTTP_CONTENT_LENGTH are not in the\n    environment (these headers should appear as CONTENT_LENGTH and\n    CONTENT_TYPE).\n\n  - Warns if QUERY_STRING is missing, as the cgi module acts\n    unpredictably in that case.\n\n  - That CGI-style variables (that don't contain a .) have\n    (non-unicode) string values\n\n  - That wsgi.version is a tuple\n\n  - That wsgi.url_scheme is 'http' or 'https' (@@: is this too\n    restrictive?)\n\n  - Warns if the REQUEST_METHOD is not known (@@: probably too\n    restrictive).\n\n  - That SCRIPT_NAME and PATH_INFO are empty or start with /\n\n  - That at least one of SCRIPT_NAME or PATH_INFO are set.\n\n  - That CONTENT_LENGTH is a positive integer.\n\n  - That SCRIPT_NAME is not '/' (it should be '', and PATH_INFO should\n    be '/').\n\n  - That wsgi.input has the methods read, readline, readlines, and\n    __iter__\n\n  - That wsgi.errors has the methods flush, write, writelines\n\n* The status is a string, contains a space, starts with an integer,\n  and that integer is in range (> 100).\n\n* That the headers is a list (not a subclass, not another kind of\n  sequence).\n\n* That the items of the headers are tuples of strings.\n\n* That there is no 'status' header (that is used in CGI, but not in\n  WSGI).\n\n* That the headers don't contain newlines or colons, end in _ or -, or\n  contain characters codes below 037.\n\n* That Content-Type is given if there is content (CGI often has a\n  default content type, but WSGI does not).\n\n* That no Content-Type is given when there is no content (@@: is this\n  too restrictive?)\n\n* That the exc_info argument to start_response is a tuple or None.\n\n* That all calls to the writer are with strings, and no other methods\n  on the writer are accessed.\n\n* That wsgi.input is used properly:\n\n  - .read() is called with zero or one argument\n\n  - That it returns a string\n\n  - That readline, readlines, and __iter__ return strings\n\n  - That .close() is not called\n\n  - No other methods are provided\n\n* That wsgi.errors is used properly:\n\n  - .write() and .writelines() is called with a string\n\n  - That .close() is not called, and no other methods are provided.\n\n* The response iterator:\n\n  - That it is not a string (it should be a list of a single string; a\n    string will work, but perform horribly).\n\n  - That .next() returns a string\n\n  - That the iterator is not iterated over until start_response has\n    been called (that can signal either a server or application\n    error).\n\n  - That .close() is called (doesn't raise exception, only prints to\n    sys.stderr, because we only know it isn't called when the object\n    is garbage collected).\n"
__all__ = ['validator']
import re
import sys
from types import DictType, StringType, TupleType, ListType
import warnings
header_re = re.compile('^[a-zA-Z][a-zA-Z0-9\\-_]*$')
bad_header_value_re = re.compile('[\\000-\\037]')
