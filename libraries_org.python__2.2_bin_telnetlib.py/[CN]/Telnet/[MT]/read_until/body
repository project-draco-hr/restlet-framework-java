def read_until(self, match, timeout=None):
    'Read until a given string is encountered or until timeout.\n\n        When no match is found, return whatever is available instead,\n        possibly the empty string.  Raise EOFError if the connection\n        is closed and no cooked data is available.\n\n        '
    n = len(match)
    self.process_rawq()
    i = self.cookedq.find(match)
    if (i >= 0):
        i = (i + n)
        buf = self.cookedq[:i]
        self.cookedq = self.cookedq[i:]
        return buf
    s_reply = ([self], [], [])
    s_args = s_reply
    if (timeout is not None):
        s_args = (s_args + (timeout,))
    while ((not self.eof) and (select(*s_args) == s_reply)):
        i = max(0, (len(self.cookedq) - n))
        self.fill_rawq()
        self.process_rawq()
        i = self.cookedq.find(match, i)
        if (i >= 0):
            i = (i + n)
            buf = self.cookedq[:i]
            self.cookedq = self.cookedq[i:]
            return buf
    return self.read_very_lazy()
