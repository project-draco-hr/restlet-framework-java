from test.test_support import verify, TestFailed, check_syntax, vereq, is_jython
import warnings
warnings.filterwarnings('ignore', 'import \\*', SyntaxWarning, '<string>')
print '1. simple nesting'
inc = make_adder(1)
plus10 = make_adder(10)
vereq(inc(1), 2)
vereq(plus10((-2)), 8)
print '2. extra nesting'
inc = make_adder2(1)
plus10 = make_adder2(10)
vereq(inc(1), 2)
vereq(plus10((-2)), 8)
print '3. simple nesting + rebinding'
inc = make_adder3(0)
plus10 = make_adder3(9)
vereq(inc(1), 2)
vereq(plus10((-2)), 8)
print '4. nesting with global but no free'
global_x = 1
adder = make_adder4()
vereq(adder(1), 2)
global_x = 10
vereq(adder((-2)), 8)
print '5. nesting through class'
inc = make_adder5(1)
plus10 = make_adder5(10)
vereq(inc(1), 2)
vereq(plus10((-2)), 8)
print '6. nesting plus free ref to global'
inc = make_adder6(1)
plus10 = make_adder6(10)
vereq(inc(1), 11)
vereq(plus10((-2)), 8)
print '7. nearest enclosing scope'
test_func = f(10)
vereq(test_func(5), 47)
print '8. mixed freevars and cellvars'
g = f(1, 2, 3)
h = g(2, 4, 6)
vereq(h(), 39)
print '9. free variable in method'
t = test()
vereq(t.test(), 'var')
vereq(t.method_and_var(), 'method')
vereq(t.actual_global(), 'global')
method_and_var = 'var'
t = Test()
vereq(t.test(), 'var')
vereq(t.method_and_var(), 'method')
vereq(t.actual_global(), 'global')
print '10. recursion'
vereq(f(6), 720)
print '11. unoptimized namespaces'
check_syntax('def unoptimized_clash1(strip):\n    def f(s):\n        from string import *\n        return strip(s) # ambiguity: free or local\n    return f\n')
check_syntax('def unoptimized_clash2():\n    from string import *\n    def f(s):\n        return strip(s) # ambiguity: global or local\n    return f\n')
check_syntax('def unoptimized_clash2():\n    from string import *\n    def g():\n        def f(s):\n            return strip(s) # ambiguity: global or local\n        return f\n')
check_syntax('def error(y):\n    exec "a = 1"\n    def f(x):\n        return x + y\n    return f\n')
check_syntax("def f(x):\n    def g():\n        return x\n    del x # can't del name\n")
check_syntax('def f():\n    def g():\n         from string import *\n         return strip # global or local?\n')
exec '\ndef noproblem1():\n    from string import *\n    f = lambda x:x\n\ndef noproblem2():\n    from string import *\n    def f(x):\n        return x + 1\n\ndef noproblem3():\n    from string import *\n    def f(x):\n        global y\n        y = x\n'
print '12. lambdas'
f1 = (lambda x: (lambda y: (x + y)))
inc = f1(1)
plus10 = f1(10)
vereq(inc(1), 2)
vereq(plus10(5), 15)
f2 = (lambda x: (lambda : (lambda y: (x + y)))())
inc = f2(1)
plus10 = f2(10)
vereq(inc(1), 2)
vereq(plus10(5), 15)
f3 = (lambda x: (lambda y: (global_x + y)))
global_x = 1
inc = f3(None)
vereq(inc(2), 3)
f8 = (lambda x, y, z: (lambda a, b, c: (lambda : (z * (b + y)))))
g = f8(1, 2, 3)
h = g(2, 4, 6)
vereq(h(), 18)
print '13. UnboundLocal'
try:
    errorInOuter()
except UnboundLocalError:
    pass
else:
    raise TestFailed
try:
    errorInInner()
except NameError:
    pass
else:
    raise TestFailed
global_x = 1
try:
    f()
except UnboundLocalError:
    pass
else:
    raise TestFailed, 'scope of global_x not correctly determined'
print '14. complex definitions'
vereq(makeReturner(1, 2, 3)(), (1, 2, 3))
vereq(makeReturner2(a=11)()['a'], 11)
vereq(makeAddPair((1, 2))((100, 200)), (101, 202))
print '15. scope of global statements'
x = 7
vereq(f(), 7)
vereq(x, 7)
x = 7
vereq(f(), 2)
vereq(x, 7)
x = 7
vereq(f(), 2)
vereq(x, 2)
x = 7
vereq(f(), 2)
vereq(x, 2)
x = 12
g = Global()
vereq(g.get(), 13)
g.set(15)
vereq(g.get(), 13)
print '16. check leaks'
for i in range(100):
    f1()
if is_jython:
    from test_weakref import extra_collect
    for i in range(3):
        extra_collect()
vereq(Foo.count, 0)
print '17. class and global'
x = 0
vereq(test(6)(2), 8)
x = (-1)
vereq(test(3)(2), 5)
looked_up_by_load_name = False
verify(X.passed)
print '18. verify that locals() works'
d = f(2)(4)
verify(d.has_key('h'))
del d['h']
vereq(d, {'x': 2, 'y': 7, 'w': 6, })
print '19. var is bound and free in class'
inst = f(3)()
vereq(inst.a, inst.m())
print '20. interaction with trace function'
import sys
sys.settrace(tracer)
adaptgetter('foo', TestClass, (1, ''))
sys.settrace(None)
try:
    sys.settrace()
except TypeError:
    pass
else:
    raise TestFailed, 'sys.settrace() did not raise TypeError'
print '20. eval and exec with free variables'
g = f(3)
try:
    eval(g.func_code)
except TypeError:
    pass
else:
    print 'eval() should have failed, because code contained free vars'
try:
    exec g.func_code
except TypeError:
    pass
else:
    print 'exec should have failed, because code contained free vars'
print '21. list comprehension with local variables'
try:
    print bad
except NameError:
    pass
else:
    print 'bad should not be defined'
x()
try:
    print bad
except NameError:
    pass
print '22. eval with free variables'
f(4)()
