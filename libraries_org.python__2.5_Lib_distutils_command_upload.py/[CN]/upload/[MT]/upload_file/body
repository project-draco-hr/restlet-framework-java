def upload_file(self, command, pyversion, filename):
    if self.sign:
        gpg_args = ['gpg', '--detach-sign', '-a', filename]
        if self.identity:
            gpg_args[2:2] = ['--local-user', self.identity]
        spawn(gpg_args, dry_run=self.dry_run)
    content = open(filename, 'rb').read()
    meta = self.distribution.metadata
    data = {':action': 'file_upload', 'protcol_version': '1', 'name': meta.get_name(), 'version': meta.get_version(), 'content': (os.path.basename(filename), content), 'filetype': command, 'pyversion': pyversion, 'md5_digest': md5(content).hexdigest(), 'metadata_version': '1.0', 'summary': meta.get_description(), 'home_page': meta.get_url(), 'author': meta.get_contact(), 'author_email': meta.get_contact_email(), 'license': meta.get_licence(), 'description': meta.get_long_description(), 'keywords': meta.get_keywords(), 'platform': meta.get_platforms(), 'classifiers': meta.get_classifiers(), 'download_url': meta.get_download_url(), 'provides': meta.get_provides(), 'requires': meta.get_requires(), 'obsoletes': meta.get_obsoletes(), }
    comment = ''
    if (command == 'bdist_rpm'):
        (dist, version, id) = platform.dist()
        if dist:
            comment = ('built for %s %s' % (dist, version))
    elif (command == 'bdist_dumb'):
        comment = ('built for %s' % platform.platform(terse=1))
    data['comment'] = comment
    if self.sign:
        data['gpg_signature'] = ((os.path.basename(filename) + '.asc'), open((filename + '.asc')).read())
    auth = ('Basic ' + base64.encodestring(((self.username + ':') + self.password)).strip())
    boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
    sep_boundary = ('\n--' + boundary)
    end_boundary = (sep_boundary + '--')
    body = StringIO.StringIO()
    for (key, value) in data.items():
        if (type(value) != type([])):
            value = [value]
        for value in value:
            if (type(value) is tuple):
                fn = (';filename="%s"' % value[0])
                value = value[1]
            else:
                fn = ''
            value = str(value)
            body.write(sep_boundary)
            body.write(('\nContent-Disposition: form-data; name="%s"' % key))
            body.write(fn)
            body.write('\n\n')
            body.write(value)
            if (value and (value[(-1)] == '\r')):
                body.write('\n')
    body.write(end_boundary)
    body.write('\n')
    body = body.getvalue()
    self.announce(('Submitting %s to %s' % (filename, self.repository)), log.INFO)
    (schema, netloc, url, params, query, fragments) = urlparse.urlparse(self.repository)
    assert ((not params) and (not query) and (not fragments))
    if (schema == 'http'):
        http = httplib.HTTPConnection(netloc)
    elif (schema == 'https'):
        http = httplib.HTTPSConnection(netloc)
    else:
        raise AssertionError, ('unsupported schema ' + schema)
    data = ''
    loglevel = log.INFO
    try:
        http.connect()
        http.putrequest('POST', url)
        http.putheader('Content-type', ('multipart/form-data; boundary=%s' % boundary))
        http.putheader('Content-length', str(len(body)))
        http.putheader('Authorization', auth)
        http.endheaders()
        http.send(body)
    except socket.error as e:
        self.announce(str(e), log.ERROR)
        return
    r = http.getresponse()
    if (r.status == 200):
        self.announce(('Server response (%s): %s' % (r.status, r.reason)), log.INFO)
    else:
        self.announce(('Upload failed (%s): %s' % (r.status, r.reason)), log.ERROR)
    if self.show_response:
        print ('-' * 75), r.read(), ('-' * 75)
