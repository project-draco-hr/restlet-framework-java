def supers():
    if verbose:
        print 'Testing super...'


    class A(object):

        def meth(self, a):
            return ('A(%r)' % a)
    vereq(A().meth(1), 'A(1)')


    class B(A):

        def __init__(self):
            self.__super = super(B, self)

        def meth(self, a):
            return (('B(%r)' % a) + self.__super.meth(a))
    vereq(B().meth(2), 'B(2)A(2)')


    class C(A):

        def meth(self, a):
            return (('C(%r)' % a) + self.__super.meth(a))
    C._C__super = super(C)
    vereq(C().meth(3), 'C(3)A(3)')


    class D(C, B):

        def meth(self, a):
            return (('D(%r)' % a) + super(D, self).meth(a))
    vereq(D().meth(4), 'D(4)C(4)B(4)A(4)')


    class mysuper(super):

        def __init__(self, *args):
            return super(mysuper, self).__init__(*args)


    class E(D):

        def meth(self, a):
            return (('E(%r)' % a) + mysuper(E, self).meth(a))
    vereq(E().meth(5), 'E(5)D(5)C(5)B(5)A(5)')


    class F(E):

        def meth(self, a):
            s = self.__super
            return (('F(%r)[%s]' % (a, s.__class__.__name__)) + s.meth(a))
    F._F__super = mysuper(F)
    vereq(F().meth(6), 'F(6)[mysuper]E(6)D(6)C(6)B(6)A(6)')
    try:
        super(D, 42)
    except TypeError:
        pass
    else:
        raise TestFailed, "shouldn't allow super(D, 42)"
    try:
        super(D, C())
    except TypeError:
        pass
    else:
        raise TestFailed, "shouldn't allow super(D, C())"
    try:
        super(D).__get__(12)
    except TypeError:
        pass
    else:
        raise TestFailed, "shouldn't allow super(D).__get__(12)"
    try:
        super(D).__get__(C())
    except TypeError:
        pass
    else:
        raise TestFailed, "shouldn't allow super(D).__get__(C())"


    class DDbase(object):

        def getx(self):
            return 42
        x = property(getx)


    class DDsub(DDbase):

        def getx(self):
            return 'hello'
        x = property(getx)
    dd = DDsub()
    vereq(dd.x, 'hello')
    vereq(super(DDsub, dd).x, 42)


    class Base(object):
        aProp = property((lambda self: 'foo'))


    class Sub(Base):

        @classmethod
        def test(klass):
            return super(Sub, klass).aProp
    veris(Sub.test(), Base.aProp)
    try:
        super(Base, kw=1)
    except TypeError:
        pass
    else:
        raise TestFailed, "super shouldn't accept keyword args"
