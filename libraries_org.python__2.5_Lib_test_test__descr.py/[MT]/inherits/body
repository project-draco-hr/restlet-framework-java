def inherits():
    if verbose:
        print 'Testing inheritance from basic types...'


    class hexint(int):

        def __repr__(self):
            return hex(self)

        def __add__(self, other):
            return hexint(int.__add__(self, other))
    vereq(repr((hexint(7) + 9)), '0x10')
    vereq(repr((hexint(1000) + 7)), '0x3ef')
    a = hexint(12345)
    vereq(a, 12345)
    vereq(int(a), 12345)
    verify((int(a).__class__ is int))
    vereq(hash(a), hash(12345))
    verify(((+ a).__class__ is int))
    verify(((a >> 0).__class__ is int))
    verify(((a << 0).__class__ is int))
    verify(((hexint(0) << 12).__class__ is int))
    verify(((hexint(0) >> 12).__class__ is int))


    class octlong(long):
        __slots__ = []

        def __str__(self):
            s = oct(self)
            if (s[(-1)] == 'L'):
                s = s[:(-1)]
            return s

        def __add__(self, other):
            return self.__class__(super(octlong, self).__add__(other))
        __radd__ = __add__
    vereq(str((octlong(3) + 5)), '010')
    vereq(str((5 + octlong(3000))), '05675')
    a = octlong(12345)
    vereq(a, 12345L)
    vereq(long(a), 12345L)
    vereq(hash(a), hash(12345L))
    verify((long(a).__class__ is long))
    verify(((+ a).__class__ is long))
    verify(((- a).__class__ is long))
    verify(((- octlong(0)).__class__ is long))
    verify(((a >> 0).__class__ is long))
    verify(((a << 0).__class__ is long))
    verify(((a - 0).__class__ is long))
    verify(((a * 1).__class__ is long))
    verify(((a ** 1).__class__ is long))
    verify(((a // 1).__class__ is long))
    verify(((1 * a).__class__ is long))
    verify(((a | 0).__class__ is long))
    verify(((a ^ 0).__class__ is long))
    verify(((a & (-1L)).__class__ is long))
    verify(((octlong(0) << 12).__class__ is long))
    verify(((octlong(0) >> 12).__class__ is long))
    verify((abs(octlong(0)).__class__ is long))


    class longclone(long):
        pass
    a = longclone(1)
    verify(((a + 0).__class__ is long))
    verify(((0 + a).__class__ is long))
    a = longclone((-1))
    vereq(a.__dict__, {})
    vereq(long(a), (-1))


    class precfloat(float):
        __slots__ = ['prec']

        def __init__(self, value=0.0, prec=12):
            self.prec = int(prec)
            float.__init__(value)

        def __repr__(self):
            return ('%.*g' % (self.prec, self))
    vereq(repr(precfloat(1.1)), '1.1')
    a = precfloat(12345)
    vereq(a, 12345.0)
    vereq(float(a), 12345.0)
    verify((float(a).__class__ is float))
    vereq(hash(a), hash(12345.0))
    verify(((+ a).__class__ is float))


    class madcomplex(complex):

        def __repr__(self):
            return ('%.17gj%+.17g' % (self.imag, self.real))
    a = madcomplex((-3), 4)
    vereq(repr(a), '4j-3')
    base = complex((-3), 4)
    veris(base.__class__, complex)
    vereq(a, base)
    vereq(complex(a), base)
    veris(complex(a).__class__, complex)
    a = madcomplex(a)
    vereq(repr(a), '4j-3')
    vereq(a, base)
    vereq(complex(a), base)
    veris(complex(a).__class__, complex)
    vereq(hash(a), hash(base))
    veris((+ a).__class__, complex)
    veris((a + 0).__class__, complex)
    vereq((a + 0), base)
    veris((a - 0).__class__, complex)
    vereq((a - 0), base)
    veris((a * 1).__class__, complex)
    vereq((a * 1), base)
    veris((a / 1).__class__, complex)
    vereq((a / 1), base)


    class madtuple(tuple):
        _rev = None

        def rev(self):
            if (self._rev is not None):
                return self._rev
            L = list(self)
            L.reverse()
            self._rev = self.__class__(L)
            return self._rev
    a = madtuple((1, 2, 3, 4, 5, 6, 7, 8, 9, 0))
    vereq(a, (1, 2, 3, 4, 5, 6, 7, 8, 9, 0))
    vereq(a.rev(), madtuple((0, 9, 8, 7, 6, 5, 4, 3, 2, 1)))
    vereq(a.rev().rev(), madtuple((1, 2, 3, 4, 5, 6, 7, 8, 9, 0)))
    for i in range(512):
        t = madtuple(range(i))
        u = t.rev()
        v = u.rev()
        vereq(v, t)
    a = madtuple((1, 2, 3, 4, 5))
    vereq(tuple(a), (1, 2, 3, 4, 5))
    verify((tuple(a).__class__ is tuple))
    vereq(hash(a), hash((1, 2, 3, 4, 5)))
    verify((a[:].__class__ is tuple))
    verify(((a * 1).__class__ is tuple))
    verify(((a * 0).__class__ is tuple))
    verify(((a + ()).__class__ is tuple))
    a = madtuple(())
    vereq(tuple(a), ())
    verify((tuple(a).__class__ is tuple))
    verify(((a + a).__class__ is tuple))
    verify(((a * 0).__class__ is tuple))
    verify(((a * 1).__class__ is tuple))
    verify(((a * 2).__class__ is tuple))
    verify((a[:].__class__ is tuple))


    class madstring(str):
        _rev = None

        def rev(self):
            if (self._rev is not None):
                return self._rev
            L = list(self)
            L.reverse()
            self._rev = self.__class__(''.join(L))
            return self._rev
    s = madstring('abcdefghijklmnopqrstuvwxyz')
    vereq(s, 'abcdefghijklmnopqrstuvwxyz')
    vereq(s.rev(), madstring('zyxwvutsrqponmlkjihgfedcba'))
    vereq(s.rev().rev(), madstring('abcdefghijklmnopqrstuvwxyz'))
    for i in range(256):
        s = madstring(''.join(map(chr, range(i))))
        t = s.rev()
        u = t.rev()
        vereq(u, s)
    s = madstring('12345')
    vereq(str(s), '12345')
    verify((str(s).__class__ is str))
    base = ('\x00' * 5)
    s = madstring(base)
    vereq(s, base)
    vereq(str(s), base)
    verify((str(s).__class__ is str))
    vereq(hash(s), hash(base))
    vereq({s: 1, }[base], 1)
    vereq({base: 1, }[s], 1)
    verify(((s + '').__class__ is str))
    vereq((s + ''), base)
    verify((('' + s).__class__ is str))
    vereq(('' + s), base)
    verify(((s * 0).__class__ is str))
    vereq((s * 0), '')
    verify(((s * 1).__class__ is str))
    vereq((s * 1), base)
    verify(((s * 2).__class__ is str))
    vereq((s * 2), (base + base))
    verify((s[:].__class__ is str))
    vereq(s[:], base)
    verify((s[0:0].__class__ is str))
    vereq(s[0:0], '')
    verify((s.strip().__class__ is str))
    vereq(s.strip(), base)
    verify((s.lstrip().__class__ is str))
    vereq(s.lstrip(), base)
    verify((s.rstrip().__class__ is str))
    vereq(s.rstrip(), base)
    identitytab = ''.join([chr(i) for i in range(256)])
    verify((s.translate(identitytab).__class__ is str))
    vereq(s.translate(identitytab), base)
    verify((s.translate(identitytab, 'x').__class__ is str))
    vereq(s.translate(identitytab, 'x'), base)
    vereq(s.translate(identitytab, '\x00'), '')
    verify((s.replace('x', 'x').__class__ is str))
    vereq(s.replace('x', 'x'), base)
    verify((s.ljust(len(s)).__class__ is str))
    vereq(s.ljust(len(s)), base)
    verify((s.rjust(len(s)).__class__ is str))
    vereq(s.rjust(len(s)), base)
    verify((s.center(len(s)).__class__ is str))
    vereq(s.center(len(s)), base)
    verify((s.lower().__class__ is str))
    vereq(s.lower(), base)


    class madunicode(unicode):
        _rev = None

        def rev(self):
            if (self._rev is not None):
                return self._rev
            L = list(self)
            L.reverse()
            self._rev = self.__class__(u''.join(L))
            return self._rev
    u = madunicode('ABCDEF')
    vereq(u, u'ABCDEF')
    vereq(u.rev(), madunicode(u'FEDCBA'))
    vereq(u.rev().rev(), madunicode(u'ABCDEF'))
    base = u'12345'
    u = madunicode(base)
    vereq(unicode(u), base)
    verify((unicode(u).__class__ is unicode))
    vereq(hash(u), hash(base))
    vereq({u: 1, }[base], 1)
    vereq({base: 1, }[u], 1)
    verify((u.strip().__class__ is unicode))
    vereq(u.strip(), base)
    verify((u.lstrip().__class__ is unicode))
    vereq(u.lstrip(), base)
    verify((u.rstrip().__class__ is unicode))
    vereq(u.rstrip(), base)
    verify((u.replace(u'x', u'x').__class__ is unicode))
    vereq(u.replace(u'x', u'x'), base)
    verify((u.replace(u'xy', u'xy').__class__ is unicode))
    vereq(u.replace(u'xy', u'xy'), base)
    verify((u.center(len(u)).__class__ is unicode))
    vereq(u.center(len(u)), base)
    verify((u.ljust(len(u)).__class__ is unicode))
    vereq(u.ljust(len(u)), base)
    verify((u.rjust(len(u)).__class__ is unicode))
    vereq(u.rjust(len(u)), base)
    verify((u.lower().__class__ is unicode))
    vereq(u.lower(), base)
    verify((u.upper().__class__ is unicode))
    vereq(u.upper(), base)
    verify((u.capitalize().__class__ is unicode))
    vereq(u.capitalize(), base)
    verify((u.title().__class__ is unicode))
    vereq(u.title(), base)
    verify(((u + u'').__class__ is unicode))
    vereq((u + u''), base)
    verify(((u'' + u).__class__ is unicode))
    vereq((u'' + u), base)
    verify(((u * 0).__class__ is unicode))
    vereq((u * 0), u'')
    verify(((u * 1).__class__ is unicode))
    vereq((u * 1), base)
    verify(((u * 2).__class__ is unicode))
    vereq((u * 2), (base + base))
    verify((u[:].__class__ is unicode))
    vereq(u[:], base)
    verify((u[0:0].__class__ is unicode))
    vereq(u[0:0], u'')


    class sublist(list):
        pass
    a = sublist(range(5))
    vereq(a, range(5))
    a.append('hello')
    vereq(a, (range(5) + ['hello']))
    a[5] = 5
    vereq(a, range(6))
    a.extend(range(6, 20))
    vereq(a, range(20))
    a[(-5):] = []
    vereq(a, range(15))
    del a[10:15]
    vereq(len(a), 10)
    vereq(a, range(10))
    vereq(list(a), range(10))
    vereq(a[0], 0)
    vereq(a[9], 9)
    vereq(a[(-10)], 0)
    vereq(a[(-1)], 9)
    vereq(a[:5], range(5))


    class CountedInput(file):
        'Counts lines read by self.readline().\n\n        self.lineno is the 0-based ordinal of the last line read, up to\n        a maximum of one greater than the number of lines in the file.\n\n        self.ateof is true if and only if the final "" line has been read,\n        at which point self.lineno stops incrementing, and further calls\n        to readline() continue to return "".\n        '
        lineno = 0
        ateof = 0

        def readline(self):
            if self.ateof:
                return ''
            s = file.readline(self)
            self.lineno += 1
            if (s == ''):
                self.ateof = 1
            return s
    f = file(name=TESTFN, mode='w')
    lines = ['a\n', 'b\n', 'c\n']
    try:
        f.writelines(lines)
        f.close()
        f = CountedInput(TESTFN)
        for (i, expected) in zip((range(1, 5) + [4]), (lines + (2 * ['']))):
            got = f.readline()
            vereq(expected, got)
            vereq(f.lineno, i)
            vereq(f.ateof, (i > len(lines)))
        f.close()
    finally:
        try:
            f.close()
        except:
            pass
        try:
            import os
            os.unlink(TESTFN)
        except:
            pass
