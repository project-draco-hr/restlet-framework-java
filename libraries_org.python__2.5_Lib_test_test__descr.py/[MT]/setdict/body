def setdict():
    if verbose:
        print 'Testing __dict__ assignment...'


    class C(object):
        pass
    a = C()
    a.__dict__ = {'b': 1, }
    vereq(a.b, 1)

    def cant(x, dict):
        try:
            x.__dict__ = dict
        except (AttributeError, TypeError):
            pass
        else:
            raise TestFailed, ("shouldn't allow %r.__dict__ = %r" % (x, dict))
    cant(a, None)
    cant(a, [])
    cant(a, 1)
    del a.__dict__


    class Base(object):
        pass

    def verify_dict_readonly(x):
        '\n        x has to be an instance of a class inheriting from Base.\n        '
        cant(x, {})
        try:
            del x.__dict__
        except (AttributeError, TypeError):
            pass
        else:
            raise TestFailed, ("shouldn't allow del %r.__dict__" % x)
        dict_descr = Base.__dict__['__dict__']
        try:
            dict_descr.__set__(x, {})
        except (AttributeError, TypeError):
            pass
        else:
            raise TestFailed, ("dict_descr allowed access to %r's dict" % x)


    class Meta1(type, Base):
        pass


    class Meta2(Base, type):
        pass


    class D(object):
        __metaclass__ = Meta1


    class E(object):
        __metaclass__ = Meta2
    for cls in (C, D, E):
        verify_dict_readonly(cls)
        class_dict = cls.__dict__
        try:
            class_dict['spam'] = 'eggs'
        except TypeError:
            pass
        else:
            raise TestFailed, ("%r's __dict__ can be modified" % cls)


    class Module1(types.ModuleType, Base):
        pass


    class Module2(Base, types.ModuleType):
        pass
    for ModuleType in (Module1, Module2):
        mod = ModuleType('spam')
        verify_dict_readonly(mod)
        mod.__dict__['spam'] = 'eggs'


    class Exception1(Exception, Base):
        pass


    class Exception2(Base, Exception):
        pass
    for ExceptionType in (Exception, Exception1, Exception2):
        e = ExceptionType()
        e.__dict__ = {'a': 1, }
        vereq(e.a, 1)
        try:
            del e.__dict__
        except (TypeError, AttributeError):
            pass
        else:
            raise TestFaied, ("%r's __dict__ can be deleted" % e)
