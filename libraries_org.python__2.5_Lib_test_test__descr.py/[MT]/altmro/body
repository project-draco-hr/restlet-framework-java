def altmro():
    if verbose:
        print 'Testing mro() and overriding it...'


    class A(object):

        def f(self):
            return 'A'


    class B(A):
        pass


    class C(A):

        def f(self):
            return 'C'


    class D(B, C):
        pass
    vereq(D.mro(), [D, B, C, A, object])
    vereq(D.__mro__, (D, B, C, A, object))
    vereq(D().f(), 'C')


    class PerverseMetaType(type):

        def mro(cls):
            L = type.mro(cls)
            L.reverse()
            return L


    class X(D, B, C, A):
        __metaclass__ = PerverseMetaType
    vereq(X.__mro__, (object, A, C, B, D, X))
    vereq(X().f(), 'A')
    try:


        class X(object):


            class __metaclass__(type):

                def mro(self):
                    return [self, dict, object]
    except TypeError:
        pass
    else:
        raise TestFailed, 'devious mro() return not caught'
    try:


        class X(object):


            class __metaclass__(type):

                def mro(self):
                    return [1]
    except TypeError:
        pass
    else:
        raise TestFailed, 'non-class mro() return not caught'
    try:


        class X(object):


            class __metaclass__(type):

                def mro(self):
                    return 1
    except TypeError:
        pass
    else:
        raise TestFailed, 'non-sequence mro() return not caught'
