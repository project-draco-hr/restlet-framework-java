def slots():
    if verbose:
        print 'Testing __slots__...'


    class C0(object):
        __slots__ = []
    x = C0()
    verify((not hasattr(x, '__dict__')))
    verify((not hasattr(x, 'foo')))


    class C1(object):
        __slots__ = ['a']
    x = C1()
    verify((not hasattr(x, '__dict__')))
    verify((not hasattr(x, 'a')))
    x.a = 1
    vereq(x.a, 1)
    x.a = None
    veris(x.a, None)
    del x.a
    verify((not hasattr(x, 'a')))


    class C3(object):
        __slots__ = ['a', 'b', 'c']
    x = C3()
    verify((not hasattr(x, '__dict__')))
    verify((not hasattr(x, 'a')))
    verify((not hasattr(x, 'b')))
    verify((not hasattr(x, 'c')))
    x.a = 1
    x.b = 2
    x.c = 3
    vereq(x.a, 1)
    vereq(x.b, 2)
    vereq(x.c, 3)


    class C4(object):
        'Validate name mangling'
        __slots__ = ['__a']

        def __init__(self, value):
            self.__a = value

        def get(self):
            return self.__a
    x = C4(5)
    verify((not hasattr(x, '__dict__')))
    verify((not hasattr(x, '__a')))
    vereq(x.get(), 5)
    try:
        x.__a = 6
    except AttributeError:
        pass
    else:
        raise TestFailed, 'Double underscored names not mangled'
    try:


        class C(object):
            __slots__ = [None]
    except TypeError:
        pass
    else:
        raise TestFailed, '[None] slots not caught'
    try:


        class C(object):
            __slots__ = ['foo bar']
    except TypeError:
        pass
    else:
        raise TestFailed, "['foo bar'] slots not caught"
    try:


        class C(object):
            __slots__ = ['foo\x00bar']
    except TypeError:
        pass
    else:
        raise TestFailed, "['foo\\0bar'] slots not caught"
    try:


        class C(object):
            __slots__ = ['1']
    except TypeError:
        pass
    else:
        raise TestFailed, "['1'] slots not caught"
    try:


        class C(object):
            __slots__ = ['']
    except TypeError:
        pass
    else:
        raise TestFailed, "[''] slots not caught"


    class C(object):
        __slots__ = ['a', 'a_b', '_a', 'A0123456789Z']
    try:
        unichr
    except NameError:
        pass
    else:
        slots = (unicode('foo'), unicode('bar'))


        class C(object):
            __slots__ = slots
        x = C()
        x.foo = 5
        vereq(x.foo, 5)
        veris(type(slots[0]), unicode)
        try:


            class C(object):
                __slots__ = [unichr(128)]
        except (TypeError, UnicodeEncodeError):
            pass
        else:
            raise TestFailed, '[unichr(128)] slots not caught'


    class Counted:
        counter = 0

        def __init__(self):
            Counted.counter += 1

        def __del__(self):
            Counted.counter -= 1


    class C(object):
        __slots__ = ['a', 'b', 'c']
    x = C()
    x.a = Counted()
    x.b = Counted()
    x.c = Counted()
    vereq(Counted.counter, 3)
    del x
    extra_collect()
    vereq(Counted.counter, 0)


    class D(C):
        pass
    x = D()
    x.a = Counted()
    x.z = Counted()
    vereq(Counted.counter, 2)
    del x
    extra_collect()
    vereq(Counted.counter, 0)


    class E(D):
        __slots__ = ['e']
    x = E()
    x.a = Counted()
    x.z = Counted()
    x.e = Counted()
    vereq(Counted.counter, 3)
    del x
    extra_collect()
    vereq(Counted.counter, 0)


    class F(object):
        __slots__ = ['a', 'b']
    log = []
    s = F()
    s.a = [Counted(), s]
    vereq(Counted.counter, 1)
    s = None
    import gc
    gc.collect()
    extra_collect()
    vereq(Counted.counter, 0)
    import sys
    '\n    # Test lookup leaks [SF bug 572567]\n    import sys,gc\n    class G(object):\n        def __cmp__(self, other):\n            return 0\n    g = G()\n    orig_objects = len(gc.get_objects())\n    for i in xrange(10):\n        g==g\n    new_objects = len(gc.get_objects())\n    vereq(orig_objects, new_objects)\n    '


    class H(object):
        __slots__ = ['a', 'b']

        def __init__(self):
            self.a = 1
            self.b = 2

        def __del__(self):
            assert (self.a == 1)
            assert (self.b == 2)
    save_stderr = sys.stderr
    sys.stderr = sys.stdout
    h = H()
    try:
        del h
        extra_collect()
    finally:
        sys.stderr = save_stderr
