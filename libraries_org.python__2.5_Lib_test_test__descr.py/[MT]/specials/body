def specials():
    if verbose:
        print 'Testing special operators...'


    class C(object):

        def __getitem__(self, i):
            if (0 <= i < 10):
                return i
            raise IndexError
    c1 = C()
    c2 = C()
    verify((not (not c1)))
    verify((id(c1) != id(c2)))
    hash(c1)
    hash(c2)
    vereq(cmp(c1, c2), cmp(id(c1), id(c2)))
    vereq(c1, c1)
    verify((c1 != c2))
    verify((not (c1 != c1)))
    verify((not (c1 == c2)))
    verify((str(c1).find('C object at ') >= 0))
    vereq(str(c1), repr(c1))
    verify(((-1) not in c1))
    for i in range(10):
        verify((i in c1))
    verify((10 not in c1))


    class D(object):

        def __getitem__(self, i):
            if (0 <= i < 10):
                return i
            raise IndexError
    d1 = D()
    d2 = D()
    verify((not (not d1)))
    verify((id(d1) != id(d2)))
    hash(d1)
    hash(d2)
    vereq(cmp(d1, d2), cmp(id(d1), id(d2)))
    vereq(d1, d1)
    verify((d1 != d2))
    verify((not (d1 != d1)))
    verify((not (d1 == d2)))
    verify((str(d1).find('D object at ') >= 0))
    vereq(str(d1), repr(d1))
    verify(((-1) not in d1))
    for i in range(10):
        verify((i in d1))
    verify((10 not in d1))


    class Proxy(object):

        def __init__(self, x):
            self.x = x

        def __nonzero__(self):
            return (not (not self.x))

        def __hash__(self):
            return hash(self.x)

        def __eq__(self, other):
            return (self.x == other)

        def __ne__(self, other):
            return (self.x != other)

        def __cmp__(self, other):
            return cmp(self.x, other.x)

        def __str__(self):
            return ('Proxy:%s' % self.x)

        def __repr__(self):
            return ('Proxy(%r)' % self.x)

        def __contains__(self, value):
            return (value in self.x)
    p0 = Proxy(0)
    p1 = Proxy(1)
    p_1 = Proxy((-1))
    verify((not p0))
    verify((not (not p1)))
    vereq(hash(p0), hash(0))
    vereq(p0, p0)
    verify((p0 != p1))
    verify((not (p0 != p0)))
    vereq((not p0), p1)
    vereq(cmp(p0, p1), (-1))
    vereq(cmp(p0, p0), 0)
    vereq(cmp(p0, p_1), 1)
    vereq(str(p0), 'Proxy:0')
    vereq(repr(p0), 'Proxy(0)')
    p10 = Proxy(range(10))
    verify(((-1) not in p10))
    for i in range(10):
        verify((i in p10))
    verify((10 not in p10))


    class DProxy(object):

        def __init__(self, x):
            self.x = x

        def __nonzero__(self):
            return (not (not self.x))

        def __hash__(self):
            return hash(self.x)

        def __eq__(self, other):
            return (self.x == other)

        def __ne__(self, other):
            return (self.x != other)

        def __cmp__(self, other):
            return cmp(self.x, other.x)

        def __str__(self):
            return ('DProxy:%s' % self.x)

        def __repr__(self):
            return ('DProxy(%r)' % self.x)

        def __contains__(self, value):
            return (value in self.x)
    p0 = DProxy(0)
    p1 = DProxy(1)
    p_1 = DProxy((-1))
    verify((not p0))
    verify((not (not p1)))
    vereq(hash(p0), hash(0))
    vereq(p0, p0)
    verify((p0 != p1))
    verify((not (p0 != p0)))
    vereq((not p0), p1)
    vereq(cmp(p0, p1), (-1))
    vereq(cmp(p0, p0), 0)
    vereq(cmp(p0, p_1), 1)
    vereq(str(p0), 'DProxy:0')
    vereq(repr(p0), 'DProxy(0)')
    p10 = DProxy(range(10))
    verify(((-1) not in p10))
    for i in range(10):
        verify((i in p10))
    verify((10 not in p10))

    def unsafecmp(a, b):
        try:
            a.__class__.__cmp__(a, b)
        except TypeError:
            pass
        else:
            raise TestFailed, ("shouldn't allow %s.__cmp__(%r, %r)" % (a.__class__, a, b))
    unsafecmp(u'123', '123')
    unsafecmp('123', u'123')
    unsafecmp(1, 1.0)
    unsafecmp(1.0, 1)
    unsafecmp(1, 1L)
    unsafecmp(1L, 1)


    class Letter(str):

        def __new__(cls, letter):
            if (letter == 'EPS'):
                return str.__new__(cls)
            return str.__new__(cls, letter)

        def __str__(self):
            if (not self):
                return 'EPS'
            return self
    import sys
    test_stdout = sys.stdout
    sys.stdout = get_original_stdout()
    try:
        print Letter('w')
    except RuntimeError:
        pass
    else:
        raise TestFailed, 'expected a RuntimeError for print recursion'
    sys.stdout = test_stdout
