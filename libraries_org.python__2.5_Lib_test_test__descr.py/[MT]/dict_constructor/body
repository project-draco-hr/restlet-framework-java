def dict_constructor():
    if verbose:
        print 'Testing dict constructor ...'
    d = dict()
    vereq(d, {})
    d = dict({})
    vereq(d, {})
    d = dict({1: 2, 'a': 'b', })
    vereq(d, {1: 2, 'a': 'b', })
    vereq(d, dict(d.items()))
    vereq(d, dict(d.iteritems()))
    d = dict({'one': 1, 'two': 2, })
    vereq(d, dict(one=1, two=2))
    vereq(d, dict(**d))
    vereq(d, dict({'one': 1, }, two=2))
    vereq(d, dict([('two', 2)], one=1))
    vereq(d, dict([('one', 100), ('two', 200)], **d))
    verify((d is not dict(**d)))
    for badarg in (0, 0L, 0j, '0', [0], (0,)):
        try:
            dict(badarg)
        except TypeError:
            pass
        except ValueError:
            if (badarg == '0'):
                pass
            else:
                raise TestFailed(('no TypeError from dict(%r)' % badarg))
        else:
            raise TestFailed(('no TypeError from dict(%r)' % badarg))
    try:
        dict({}, {})
    except TypeError:
        pass
    else:
        raise TestFailed('no TypeError from dict({}, {})')


    class Mapping:
        dict = {1: 2, 3: 4, 'a': 1j, }
    try:
        dict(Mapping())
    except TypeError:
        pass
    else:
        raise TestFailed('no TypeError from dict(incomplete mapping)')
    Mapping.keys = (lambda self: self.dict.keys())
    Mapping.__getitem__ = (lambda self, i: self.dict[i])
    d = dict(Mapping())
    vereq(d, Mapping.dict)


    class AddressBookEntry:

        def __init__(self, first, last):
            self.first = first
            self.last = last

        def __iter__(self):
            return iter([self.first, self.last])
    d = dict([AddressBookEntry('Tim', 'Warsaw'), AddressBookEntry('Barry', 'Peters'), AddressBookEntry('Tim', 'Peters'), AddressBookEntry('Barry', 'Warsaw')])
    vereq(d, {'Barry': 'Warsaw', 'Tim': 'Peters', })
    d = dict(zip(range(4), range(1, 5)))
    vereq(d, dict([(i, (i + 1)) for i in range(4)]))
    for bad in ([('tooshort',)], [('too', 'long', 'by 1')]):
        try:
            dict(bad)
        except ValueError:
            pass
        else:
            raise TestFailed(('no ValueError from dict(%r)' % bad))
