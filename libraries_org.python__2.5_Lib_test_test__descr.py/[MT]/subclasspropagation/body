def subclasspropagation():
    if verbose:
        print 'Testing propagation of slot functions to subclasses...'


    class A(object):
        pass


    class B(A):
        pass


    class C(A):
        pass


    class D(B, C):
        pass
    d = D()
    orig_hash = hash(d)
    A.__hash__ = (lambda self: 42)
    vereq(hash(d), 42)
    C.__hash__ = (lambda self: 314)
    vereq(hash(d), 314)
    B.__hash__ = (lambda self: 144)
    vereq(hash(d), 144)
    D.__hash__ = (lambda self: 100)
    vereq(hash(d), 100)
    del D.__hash__
    vereq(hash(d), 144)
    del B.__hash__
    vereq(hash(d), 314)
    del C.__hash__
    vereq(hash(d), 42)
    del A.__hash__
    vereq(hash(d), orig_hash)
    d.foo = 42
    d.bar = 42
    vereq(d.foo, 42)
    vereq(d.bar, 42)

    def __getattribute__(self, name):
        if (name == 'foo'):
            return 24
        return object.__getattribute__(self, name)
    A.__getattribute__ = __getattribute__
    vereq(d.foo, 24)
    vereq(d.bar, 42)

    def __getattr__(self, name):
        if (name in ('spam', 'foo', 'bar')):
            return 'hello'
        raise AttributeError, name
    B.__getattr__ = __getattr__
    vereq(d.spam, 'hello')
    vereq(d.foo, 24)
    vereq(d.bar, 42)
    del A.__getattribute__
    vereq(d.foo, 42)
    del d.foo
    vereq(d.foo, 'hello')
    vereq(d.bar, 42)
    del B.__getattr__
    try:
        d.foo
    except AttributeError:
        pass
    else:
        raise TestFailed, 'd.foo should be undefined now'
    import gc


    class A(object):
        pass


    class B(A):
        pass
    del B
    gc.collect()
    A.__setitem__ = (lambda *a: None)
