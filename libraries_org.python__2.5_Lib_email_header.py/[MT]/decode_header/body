def decode_header(header):
    'Decode a message header value without converting charset.\n\n    Returns a list of (decoded_string, charset) pairs containing each of the\n    decoded parts of the header.  Charset is None for non-encoded parts of the\n    header, otherwise a lower-case string containing the name of the character\n    set specified in the encoded string.\n\n    An email.Errors.HeaderParseError may be raised when certain decoding error\n    occurs (e.g. a base64 decoding exception).\n    '
    header = str(header)
    if (not ecre.search(header)):
        return [(header, None)]
    decoded = []
    dec = ''
    for line in header.splitlines():
        if (not ecre.search(line)):
            decoded.append((line, None))
            continue
        parts = ecre.split(line)
        while parts:
            unenc = parts.pop(0).strip()
            if unenc:
                if (decoded and (decoded[(-1)][1] is None)):
                    decoded[(-1)] = (((decoded[(-1)][0] + SPACE) + unenc), None)
                else:
                    decoded.append((unenc, None))
            if parts:
                (charset, encoding) = [s.lower() for s in parts[0:2]]
                encoded = parts[2]
                dec = None
                if (encoding == 'q'):
                    dec = email.quoprimime.header_decode(encoded)
                elif (encoding == 'b'):
                    try:
                        dec = email.base64mime.decode(encoded)
                    except binascii.Error:
                        raise HeaderParseError
                if (dec is None):
                    dec = encoded
                if (decoded and (decoded[(-1)][1] == charset)):
                    decoded[(-1)] = ((decoded[(-1)][0] + dec), decoded[(-1)][1])
                else:
                    decoded.append((dec, charset))
            del parts[0:3]
    return decoded
