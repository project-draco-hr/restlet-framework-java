def _parse(source, state):
    subpattern = SubPattern(state)
    while 1:
        if (source.next in ('|', ')')):
            break
        this = source.get()
        if (this is None):
            break
        if (state.flags & SRE_FLAG_VERBOSE):
            if (this in WHITESPACE):
                continue
            if (this == '#'):
                while 1:
                    this = source.get()
                    if (this in (None, '\n')):
                        break
                continue
        if (this and (this[0] not in SPECIAL_CHARS)):
            subpattern.append((LITERAL, ord(this)))
        elif (this == '['):
            set = []
            if source.match('^'):
                set.append((NEGATE, None))
            start = set[:]
            while 1:
                this = source.get()
                if ((this == ']') and (set != start)):
                    break
                elif (this and (this[0] == '\\')):
                    code1 = _class_escape(source, this)
                elif this:
                    code1 = (LITERAL, ord(this))
                else:
                    raise error, 'unexpected end of regular expression'
                if source.match('-'):
                    this = source.get()
                    if (this == ']'):
                        if (code1[0] is IN):
                            code1 = code1[1][0]
                        set.append(code1)
                        set.append((LITERAL, ord('-')))
                        break
                    else:
                        if (this[0] == '\\'):
                            code2 = _class_escape(source, this)
                        else:
                            code2 = (LITERAL, ord(this))
                        if ((code1[0] != LITERAL) or (code2[0] != LITERAL)):
                            raise error, 'bad character range'
                        lo = code1[1]
                        hi = code2[1]
                        if (hi < lo):
                            raise error, 'bad character range'
                        set.append((RANGE, (lo, hi)))
                else:
                    if (code1[0] is IN):
                        code1 = code1[1][0]
                    set.append(code1)
            if ((len(set) == 1) and (set[0][0] is LITERAL)):
                subpattern.append(set[0])
            elif ((len(set) == 2) and (set[0][0] is NEGATE) and (set[1][0] is LITERAL)):
                subpattern.append((NOT_LITERAL, set[1][1]))
            else:
                subpattern.append((IN, set))
        elif (this and (this[0] in REPEAT_CHARS)):
            if (this == '?'):
                (min, max) = (0, 1)
            elif (this == '*'):
                (min, max) = (0, MAXREPEAT)
            elif (this == '+'):
                (min, max) = (1, MAXREPEAT)
            elif (this == '{'):
                here = source.tell()
                (min, max) = (0, MAXREPEAT)
                lo = hi = ''
                while (source.next in DIGITS):
                    lo = (lo + source.get())
                if source.match(','):
                    while (source.next in DIGITS):
                        hi = (hi + source.get())
                else:
                    hi = lo
                if (not source.match('}')):
                    subpattern.append((LITERAL, ord(this)))
                    source.seek(here)
                    continue
                if lo:
                    min = atoi(lo)
                if hi:
                    max = atoi(hi)
                if (max < min):
                    raise error, 'bad repeat interval'
            else:
                raise error, 'not supported'
            if subpattern:
                item = subpattern[(-1):]
            else:
                item = None
            if ((not item) or ((len(item) == 1) and (item[0][0] == AT))):
                raise error, 'nothing to repeat'
            if (item[0][0] in (MIN_REPEAT, MAX_REPEAT)):
                raise error, 'multiple repeat'
            if source.match('?'):
                subpattern[(-1)] = (MIN_REPEAT, (min, max, item))
            else:
                subpattern[(-1)] = (MAX_REPEAT, (min, max, item))
        elif (this == '.'):
            subpattern.append((ANY, None))
        elif (this == '('):
            group = 1
            name = None
            if source.match('?'):
                group = 0
                if source.match('P'):
                    if source.match('<'):
                        name = ''
                        while 1:
                            char = source.get()
                            if (char is None):
                                raise error, 'unterminated name'
                            if (char == '>'):
                                break
                            name = (name + char)
                        group = 1
                        if (not isname(name)):
                            raise error, 'bad character in group name'
                    elif source.match('='):
                        name = ''
                        while 1:
                            char = source.get()
                            if (char is None):
                                raise error, 'unterminated name'
                            if (char == ')'):
                                break
                            name = (name + char)
                        if (not isname(name)):
                            raise error, 'bad character in group name'
                        gid = state.groupdict.get(name)
                        if (gid is None):
                            raise error, 'unknown group name'
                        subpattern.append((GROUPREF, gid))
                        continue
                    else:
                        char = source.get()
                        if (char is None):
                            raise error, 'unexpected end of pattern'
                        raise error, ('unknown specifier: ?P%s' % char)
                elif source.match(':'):
                    group = 2
                elif source.match('#'):
                    while 1:
                        if ((source.next is None) or (source.next == ')')):
                            break
                        source.get()
                    if (not source.match(')')):
                        raise error, 'unbalanced parenthesis'
                    continue
                elif (source.next in ('=', '!', '<')):
                    char = source.get()
                    dir = 1
                    if (char == '<'):
                        if (source.next not in ('=', '!')):
                            raise error, 'syntax error'
                        dir = (-1)
                        char = source.get()
                    p = _parse_sub(source, state)
                    if (not source.match(')')):
                        raise error, 'unbalanced parenthesis'
                    if (char == '='):
                        subpattern.append((ASSERT, (dir, p)))
                    else:
                        subpattern.append((ASSERT_NOT, (dir, p)))
                    continue
                else:
                    if (not FLAGS.has_key(source.next)):
                        raise error, 'unexpected end of pattern'
                    while FLAGS.has_key(source.next):
                        state.flags = (state.flags | FLAGS[source.get()])
            if group:
                if (group == 2):
                    group = None
                else:
                    group = state.opengroup(name)
                p = _parse_sub(source, state)
                if (not source.match(')')):
                    raise error, 'unbalanced parenthesis'
                if (group is not None):
                    state.closegroup(group)
                subpattern.append((SUBPATTERN, (group, p)))
            else:
                while 1:
                    char = source.get()
                    if (char is None):
                        raise error, 'unexpected end of pattern'
                    if (char == ')'):
                        break
                    raise error, 'unknown extension'
        elif (this == '^'):
            subpattern.append((AT, AT_BEGINNING))
        elif (this == '$'):
            subpattern.append((AT, AT_END))
        elif (this and (this[0] == '\\')):
            code = _escape(source, this, state)
            subpattern.append(code)
        else:
            raise error, 'parser error'
    return subpattern
