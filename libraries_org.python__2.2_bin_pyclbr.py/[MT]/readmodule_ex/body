def readmodule_ex(module, path=[], inpackage=0):
    'Read a module file and return a dictionary of classes.\n\n    Search for MODULE in PATH and sys.path, read and parse the\n    module and return a dictionary with one entry for each class\n    found in the module.'
    dict = {}
    i = module.rfind('.')
    if (i >= 0):
        package = module[:i].strip()
        submodule = module[(i + 1):].strip()
        parent = readmodule_ex(package, path, inpackage)
        child = readmodule_ex(submodule, parent['__path__'], 1)
        return child
    if _modules.has_key(module):
        return _modules[module]
    if (module in sys.builtin_module_names):
        _modules[module] = dict
        return dict
    f = None
    if inpackage:
        try:
            (f, file, (suff, mode, type)) = imp.find_module(module, path)
        except ImportError:
            f = None
    if (f is None):
        fullpath = (list(path) + sys.path)
        (f, file, (suff, mode, type)) = imp.find_module(module, fullpath)
    if (type == imp.PKG_DIRECTORY):
        dict['__path__'] = [file]
        _modules[module] = dict
        path = ([file] + path)
        (f, file, (suff, mode, type)) = imp.find_module('__init__', [file])
    if (type != imp.PY_SOURCE):
        f.close()
        _modules[module] = dict
        return dict
    _modules[module] = dict
    classstack = []
    src = f.read()
    f.close()
    countnl = string.count
    (lineno, last_lineno_pos) = (1, 0)
    i = 0
    while 1:
        m = _getnext(src, i)
        if (not m):
            break
        (start, i) = m.span()
        if (m.start('Method') >= 0):
            thisindent = _indent(m.group('MethodIndent'))
            meth_name = m.group('MethodName')
            lineno = (lineno + countnl(src, '\n', last_lineno_pos, start))
            last_lineno_pos = start
            while (classstack and (classstack[(-1)][1] >= thisindent)):
                del classstack[(-1)]
            if classstack:
                cur_class = classstack[(-1)][0]
                cur_class._addmethod(meth_name, lineno)
            else:
                f = Function(module, meth_name, file, lineno)
                dict[meth_name] = f
        elif (m.start('String') >= 0):
            pass
        elif (m.start('Class') >= 0):
            thisindent = _indent(m.group('ClassIndent'))
            while (classstack and (classstack[(-1)][1] >= thisindent)):
                del classstack[(-1)]
            lineno = (lineno + countnl(src, '\n', last_lineno_pos, start))
            last_lineno_pos = start
            class_name = m.group('ClassName')
            inherit = m.group('ClassSupers')
            if inherit:
                inherit = inherit[1:(-1)].strip()
                names = []
                for n in inherit.split(','):
                    n = n.strip()
                    if dict.has_key(n):
                        n = dict[n]
                    else:
                        c = n.split('.')
                        if (len(c) > 1):
                            m = c[(-2)]
                            c = c[(-1)]
                            if _modules.has_key(m):
                                d = _modules[m]
                                if d.has_key(c):
                                    n = d[c]
                    names.append(n)
                inherit = names
            cur_class = Class(module, class_name, inherit, file, lineno)
            dict[class_name] = cur_class
            classstack.append((cur_class, thisindent))
        elif (m.start('Import') >= 0):
            for n in m.group('ImportList').split(','):
                n = n.strip()
                try:
                    d = readmodule_ex(n, path, inpackage)
                except:
                    pass
        elif (m.start('ImportFrom') >= 0):
            mod = m.group('ImportFromPath')
            names = m.group('ImportFromList').split(',')
            try:
                d = readmodule_ex(mod, path, inpackage)
            except:
                continue
            for n in names:
                n = n.strip()
                if d.has_key(n):
                    dict[n] = d[n]
                elif (n == '*'):
                    for n in d.keys():
                        if ((n[0] != '_') and (not dict.has_key(n))):
                            dict[n] = d[n]
        else:
            assert 0, 'regexp _getnext found something unexpected'
    return dict
