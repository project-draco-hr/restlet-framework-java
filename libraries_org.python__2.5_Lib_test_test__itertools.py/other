import unittest
from test import test_support
from itertools import *
from weakref import proxy
import sys
import operator
import random
libreftest = ' Doctest for examples in the library reference: libitertools.tex\n\n\n>>> amounts = [120.15, 764.05, 823.14]\n>>> for checknum, amount in izip(count(1200), amounts):\n...     print \'Check %d is for $%.2f\' % (checknum, amount)\n...\nCheck 1200 is for $120.15\nCheck 1201 is for $764.05\nCheck 1202 is for $823.14\n\n>>> import operator\n>>> for cube in imap(operator.pow, xrange(1,4), repeat(3)):\n...    print cube\n...\n1\n8\n27\n\n>>> reportlines = [\'EuroPython\', \'Roster\', \'\', \'alex\', \'\', \'laura\', \'\', \'martin\', \'\', \'walter\', \'\', \'samuele\']\n>>> for name in islice(reportlines, 3, None, 2):\n...    print name.title()\n...\nAlex\nLaura\nMartin\nWalter\nSamuele\n\n# >>> from operator import itemgetter\n# >>> d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)\n# >>> di = sorted(sorted(d.iteritems()), key=itemgetter(1))\n# >>> for k, g in groupby(di, itemgetter(1)):\n# ...     print k, map(itemgetter(0), g)\n# ...\n# 1 [\'a\', \'c\', \'e\']\n# 2 [\'b\', \'d\', \'f\']\n# 3 [\'g\']\n\n# Find runs of consecutive numbers using groupby.  The key to the solution\n# is differencing with a range so that consecutive numbers all appear in\n# same group.\n#>>> data = [ 1,  4,5,6, 10, 15,16,17,18, 22, 25,26,27,28]\n# >>> for k, g in groupby(enumerate(data), lambda (i,x):i-x):\n# ...     print map(operator.itemgetter(1), g)\n# ...\n# [1]\n# [4, 5, 6]\n# [10]\n# [15, 16, 17, 18]\n# [22]\n# [25, 26, 27, 28]\n\n>>> def take(n, seq):\n...     return list(islice(seq, n))\n\n>>> def enumerate(iterable):\n...     return izip(count(), iterable)\n\n>>> def tabulate(function):\n...     "Return function(0), function(1), ..."\n...     return imap(function, count())\n\n>>> def iteritems(mapping):\n...     return izip(mapping.iterkeys(), mapping.itervalues())\n\n>>> def nth(iterable, n):\n...     "Returns the nth item"\n...     return list(islice(iterable, n, n+1))\n\n>>> def all(seq, pred=None):\n...     "Returns True if pred(x) is true for every element in the iterable"\n...     for elem in ifilterfalse(pred, seq):\n...         return False\n...     return True\n\n>>> def any(seq, pred=None):\n...     "Returns True if pred(x) is true for at least one element in the iterable"\n...     for elem in ifilter(pred, seq):\n...         return True\n...     return False\n\n>>> def no(seq, pred=None):\n...     "Returns True if pred(x) is false for every element in the iterable"\n...     for elem in ifilter(pred, seq):\n...         return False\n...     return True\n\n>>> def quantify(seq, pred=None):\n...     "Count how many times the predicate is true in the sequence"\n...     return sum(imap(pred, seq))\n\n>>> def padnone(seq):\n...     "Returns the sequence elements and then returns None indefinitely"\n...     return chain(seq, repeat(None))\n\n>>> def ncycles(seq, n):\n...     "Returns the sequence elements n times"\n...     return chain(*repeat(seq, n))\n\n>>> def dotproduct(vec1, vec2):\n...     return sum(imap(operator.mul, vec1, vec2))\n\n>>> def flatten(listOfLists):\n...     return list(chain(*listOfLists))\n\n>>> def repeatfunc(func, times=None, *args):\n...     "Repeat calls to func with specified arguments."\n...     "   Example:  repeatfunc(random.random)"\n...     if times is None:\n...         return starmap(func, repeat(args))\n...     else:\n...         return starmap(func, repeat(args, times))\n\n>>> def pairwise(iterable):\n...     "s -> (s0,s1), (s1,s2), (s2, s3), ..."\n...     a, b = tee(iterable)\n...     try:\n...         b.next()\n...     except StopIteration:\n...         pass\n...     return izip(a, b)\n\nThis is not part of the examples but it tests to make sure the definitions\nperform as purported.\n\n>>> take(10, count())\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> list(enumerate(\'abc\'))\n[(0, \'a\'), (1, \'b\'), (2, \'c\')]\n\n>>> list(islice(tabulate(lambda x: 2*x), 4))\n[0, 2, 4, 6]\n\n>>> nth(\'abcde\', 3)\n[\'d\']\n\n>>> all([2, 4, 6, 8], lambda x: x%2==0)\nTrue\n\n>>> all([2, 3, 6, 8], lambda x: x%2==0)\nFalse\n\n>>> any([2, 4, 6, 8], lambda x: x%2==0)\nTrue\n\n>>> any([1, 3, 5, 9], lambda x: x%2==0,)\nFalse\n\n>>> no([1, 3, 5, 9], lambda x: x%2==0)\nTrue\n\n>>> no([1, 2, 5, 9], lambda x: x%2==0)\nFalse\n\n>>> quantify(xrange(99), lambda x: x%2==0)\n50\n\n>>> a = [[1, 2, 3], [4, 5, 6]]\n>>> flatten(a)\n[1, 2, 3, 4, 5, 6]\n\n>>> list(repeatfunc(pow, 5, 2, 3))\n[8, 8, 8, 8, 8]\n\n>>> import random\n>>> take(5, imap(int, repeatfunc(random.random)))\n[0, 0, 0, 0, 0]\n\n>>> list(pairwise(\'abcd\'))\n[(\'a\', \'b\'), (\'b\', \'c\'), (\'c\', \'d\')]\n\n>>> list(pairwise([]))\n[]\n\n>>> list(pairwise(\'a\'))\n[]\n\n>>> list(islice(padnone(\'abc\'), 0, 6))\n[\'a\', \'b\', \'c\', None, None, None]\n\n>>> list(ncycles(\'abc\', 3))\n[\'a\', \'b\', \'c\', \'a\', \'b\', \'c\', \'a\', \'b\', \'c\']\n\n>>> dotproduct([1,2,3], [4,5,6])\n32\n\n'
__test__ = {'libreftest': libreftest, }
if (__name__ == '__main__'):
    test_main(verbose=True)
