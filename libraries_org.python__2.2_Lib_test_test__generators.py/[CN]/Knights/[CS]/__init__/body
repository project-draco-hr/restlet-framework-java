def __init__(self, m, n, hard=0):
    (self.m, self.n) = (m, n)
    succs = self.succs = []

    def remove_from_successors(i0, len=len):
        ne0 = ne1 = 0
        for i in succs[i0]:
            s = succs[i]
            s.remove(i0)
            e = len(s)
            if (e == 0):
                ne0 += 1
            elif (e == 1):
                ne1 += 1
        return ((ne0 == 0) and (ne1 < 2))

    def add_to_successors(i0):
        for i in succs[i0]:
            succs[i].append(i0)

    def first():
        if ((m < 1) or (n < 1)):
            return
        corner = self.coords2index(0, 0)
        remove_from_successors(corner)
        self.lastij = corner
        yield corner
        add_to_successors(corner)

    def second():
        corner = self.coords2index(0, 0)
        assert (self.lastij == corner)
        if ((m < 3) or (n < 3)):
            return
        assert (len(succs[corner]) == 2)
        assert (self.coords2index(1, 2) in succs[corner])
        assert (self.coords2index(2, 1) in succs[corner])
        for (i, j) in ((1, 2), (2, 1)):
            this = self.coords2index(i, j)
            final = self.coords2index((3 - i), (3 - j))
            self.final = final
            remove_from_successors(this)
            succs[final].append(corner)
            self.lastij = this
            yield this
            succs[final].remove(corner)
            add_to_successors(this)

    def advance(len=len):
        candidates = []
        for i in succs[self.lastij]:
            e = len(succs[i])
            assert (e > 0), 'else remove_from_successors() pruning flawed'
            if (e == 1):
                candidates = [(e, i)]
                break
            candidates.append((e, i))
        else:
            candidates.sort()
        for (e, i) in candidates:
            if (i != self.final):
                if remove_from_successors(i):
                    self.lastij = i
                    yield i
                add_to_successors(i)

    def advance_hard(vmid=((m - 1) / 2.0), hmid=((n - 1) / 2.0), len=len):
        candidates = []
        for i in succs[self.lastij]:
            e = len(succs[i])
            assert (e > 0), 'else remove_from_successors() pruning flawed'
            if (e == 1):
                candidates = [(e, 0, i)]
                break
            (i1, j1) = self.index2coords(i)
            d = (((i1 - vmid) ** 2) + ((j1 - hmid) ** 2))
            candidates.append((e, (- d), i))
        else:
            candidates.sort()
        for (e, d, i) in candidates:
            if (i != self.final):
                if remove_from_successors(i):
                    self.lastij = i
                    yield i
                add_to_successors(i)

    def last():
        assert (self.final in succs[self.lastij])
        yield self.final
    if ((m * n) < 4):
        self.squaregenerators = [first]
    else:
        self.squaregenerators = (([first, second] + ([((hard and advance_hard) or advance)] * ((m * n) - 3))) + [last])
