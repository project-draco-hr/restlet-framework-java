def parse_multipart(fp, pdict):
    'Parse multipart input.\n\n    Arguments:\n    fp   : input file\n    pdict: dictionary containing other parameters of content-type header\n\n    Returns a dictionary just like parse_qs(): keys are the field names, each\n    value is a list of values for that field.  This is easy to use but not\n    much good if you are expecting megabytes to be uploaded -- in that case,\n    use the FieldStorage class instead which is much more flexible.  Note\n    that content-type is the raw, unparsed contents of the content-type\n    header.\n\n    XXX This does not parse nested multipart parts -- use FieldStorage for\n    that.\n\n    XXX This should really be subsumed by FieldStorage altogether -- no\n    point in having two implementations of the same parsing algorithm.\n    Also, FieldStorage protects itself better against certain DoS attacks\n    by limiting the size of the data read in one chunk.  The API here\n    does not support that kind of protection.  This also affects parse()\n    since it can call parse_multipart().\n\n    '
    boundary = ''
    if ('boundary' in pdict):
        boundary = pdict['boundary']
    if (not valid_boundary(boundary)):
        raise ValueError, ('Invalid boundary in multipart form: %r' % (boundary,))
    nextpart = ('--' + boundary)
    lastpart = (('--' + boundary) + '--')
    partdict = {}
    terminator = ''
    while (terminator != lastpart):
        bytes = (-1)
        data = None
        if terminator:
            headers = mimetools.Message(fp)
            clength = headers.getheader('content-length')
            if clength:
                try:
                    bytes = int(clength)
                except ValueError:
                    pass
            if (bytes > 0):
                if (maxlen and (bytes > maxlen)):
                    raise ValueError, 'Maximum content length exceeded'
                data = fp.read(bytes)
            else:
                data = ''
        lines = []
        while 1:
            line = fp.readline()
            if (not line):
                terminator = lastpart
                break
            if (line[:2] == '--'):
                terminator = line.strip()
                if (terminator in (nextpart, lastpart)):
                    break
            lines.append(line)
        if (data is None):
            continue
        if (bytes < 0):
            if lines:
                line = lines[(-1)]
                if (line[(-2):] == '\r\n'):
                    line = line[:(-2)]
                elif (line[(-1):] == '\n'):
                    line = line[:(-1)]
                lines[(-1)] = line
                data = ''.join(lines)
        line = headers['content-disposition']
        if (not line):
            continue
        (key, params) = parse_header(line)
        if (key != 'form-data'):
            continue
        if ('name' in params):
            name = params['name']
        else:
            continue
        if (name in partdict):
            partdict[name].append(data)
        else:
            partdict[name] = [data]
    return partdict
