{
  final InetSocketAddress clientAddress=(InetSocketAddress)e.getRemoteAddress();
  boolean close=false;
  boolean isLastChunk=false;
  ChannelBuffer content=null;
  if (!readingChunks) {
    request=(HttpRequest)e.getMessage();
    if (request.isChunked()) {
      readingChunks=true;
    }
 else {
      content=request.getContent();
    }
  }
 else {
    HttpChunk chunk=(HttpChunk)e.getMessage();
    if (chunk.isLast()) {
      readingChunks=false;
      isLastChunk=true;
      close=true;
    }
    content=chunk.getContent();
  }
  close=HttpHeaders.Values.CLOSE.equalsIgnoreCase(request.getHeader(HttpHeaders.Names.CONNECTION)) || request.getProtocolVersion().equals(HttpVersion.HTTP_1_0) && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(request.getHeader(HttpHeaders.Names.CONNECTION));
  HttpResponse response=null;
  if ((content != null) && (!isLastChunk)) {
    SslHandler sslHandler=ctx.getPipeline().get(SslHandler.class);
    SSLEngine sslEngine=sslHandler == null ? null : sslHandler.getEngine();
    NettyServerCall httpCall=new NettyServerCall(this.helper.getHelped(),content,request,clientAddress,(this.helper instanceof HttpsServerHelper),sslEngine);
    this.helper.handle(httpCall);
    response=httpCall.getResponse();
  }
  if (response == null) {
    response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);
  }
  Channel ch=e.getChannel();
  if (!close) {
    response.setHeader(HttpHeaders.Names.CONTENT_LENGTH,String.valueOf(-1));
  }
  if (request.isChunked()) {
    if (isLastChunk) {
      ChannelFuture future=ch.close();
      if (close) {
        future.addListener(ChannelFutureListener.CLOSE);
      }
    }
 else {
      if (e.getMessage() instanceof HttpChunk) {
        ch.write(response.getContent());
      }
 else {
        ch.write(response);
      }
    }
  }
 else {
    ChannelFuture future=ch.write(response);
    future.addListener(ChannelFutureListener.CLOSE);
  }
}
