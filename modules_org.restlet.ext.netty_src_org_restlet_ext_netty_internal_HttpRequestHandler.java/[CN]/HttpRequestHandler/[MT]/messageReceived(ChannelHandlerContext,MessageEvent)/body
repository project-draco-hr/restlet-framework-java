{
  if (clientAddress == null) {
    clientAddress=(InetSocketAddress)messageEvent.getRemoteAddress();
  }
  boolean lastChunk=false;
  if (!readingChunks) {
    request=(HttpRequest)messageEvent.getMessage();
    if (request.isChunked()) {
      readingChunks=true;
    }
 else {
      content=request.getContent();
    }
  }
 else {
    HttpChunk chunk=(HttpChunk)messageEvent.getMessage();
    if (chunk.isLast()) {
      readingChunks=false;
      lastChunk=true;
    }
    content.writeBytes(chunk.getContent());
  }
  if (content == null) {
    content=ChannelBuffers.dynamicBuffer();
  }
  HttpResponse nettyResponse=null;
  NettyServerCall httpCall=null;
  if ((!request.isChunked()) || lastChunk) {
    SslHandler sslHandler=ctx.getPipeline().get(SslHandler.class);
    SSLEngine sslEngine=sslHandler == null ? null : sslHandler.getEngine();
    httpCall=new NettyServerCall(this.helper.getHelped(),messageEvent,content,request,clientAddress,(this.helper instanceof HttpsServerHelper),sslEngine);
    this.helper.handle(httpCall);
    nettyResponse=httpCall.getResponse();
    Response restletResponse=httpCall.getRestletResponse();
    if (restletResponse != null) {
      Representation responseEntity=restletResponse.getEntity();
      ConnectorService connectorService=ConnectorHelper.getConnectorService();
      if (connectorService != null) {
        connectorService.beforeSend(responseEntity);
      }
      try {
        if (nettyResponse != null) {
          nettyResponse.clearHeaders();
        }
 else {
          HttpResponseStatus status=new HttpResponseStatus(restletResponse.getStatus().getCode(),restletResponse.getStatus().getName());
          nettyResponse=new DefaultHttpResponse(HttpVersion.HTTP_1_1,status);
        }
        for (        Parameter header : httpCall.getResponseHeaders()) {
          nettyResponse.addHeader(header.getName(),header.getValue());
        }
        if (httpCall.shouldResponseBeChunked(restletResponse)) {
          nettyResponse.addHeader(HeaderConstants.HEADER_TRANSFER_ENCODING,"chunked");
        }
        Channel ch=messageEvent.getChannel();
        ChannelFuture future=null;
        if (responseEntity != null) {
          if (nettyResponse.isChunked()) {
            nettyResponse.setContent(null);
            ch.write(new ChunkedStream(restletResponse.getEntity().getStream()));
          }
 else {
            ChannelBuffer buf=dynamicBuffer();
            buf.writeBytes(responseEntity.getStream(),(int)responseEntity.getAvailableSize());
            nettyResponse.setContent(buf);
          }
        }
        future=ch.write(nettyResponse);
        if (shouldCloseConnection()) {
          future.addListener(ChannelFutureListener.CLOSE);
        }
      }
  finally {
        if (responseEntity != null) {
          responseEntity.release();
        }
        if (connectorService != null) {
          connectorService.afterSend(responseEntity);
        }
      }
    }
  }
}
