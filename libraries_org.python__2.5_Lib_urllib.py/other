'Open an arbitrary URL.\n\nSee the following document for more info on URLs:\n"Names and Addresses, URIs, URLs, URNs, URCs", at\nhttp://www.w3.org/pub/WWW/Addressing/Overview.html\n\nSee also the HTTP spec (from which the error codes are derived):\n"HTTP - Hypertext Transfer Protocol", at\nhttp://www.w3.org/pub/WWW/Protocols/\n\nRelated standards and specs:\n- RFC1808: the "relative URL" spec. (authoritative status)\n- RFC1738 - the "URL standard". (authoritative status)\n- RFC1630 - the "URI spec". (informational status)\n\nThe object returned by URLopener().open(file) will differ per\nprotocol.  All you know is that is has methods read(), readline(),\nreadlines(), fileno(), close() and info().  The read*(), fileno()\nand close() methods work like those of open files.\nThe info() method returns a mimetools.Message object which can be\nused to query various info about the object, if available.\n(mimetools.Message objects are queried with the getheader() method.)\n'
import string
import socket
import os
import time
import sys
from urlparse import urljoin as basejoin
__all__ = ['urlopen', 'URLopener', 'FancyURLopener', 'urlretrieve', 'urlcleanup', 'quote', 'quote_plus', 'unquote', 'unquote_plus', 'urlencode', 'url2pathname', 'pathname2url', 'splittag', 'localhost', 'thishost', 'ftperrors', 'basejoin', 'unwrap', 'splittype', 'splithost', 'splituser', 'splitpasswd', 'splitport', 'splitnport', 'splitquery', 'splitattr', 'splitvalue', 'splitgophertype', 'getproxies']
__version__ = '1.17'
MAXFTPCACHE = 10
if (os.name == 'mac'):
    from macurl2path import url2pathname, pathname2url
elif ((os._name if sys.platform.startswith('java') else os.name) == 'nt'):
    from nturl2path import url2pathname, pathname2url
elif (os.name == 'riscos'):
    from rourl2path import url2pathname, pathname2url
else:

    def url2pathname(pathname):
        "OS-specific conversion from a relative URL of the 'file' scheme\n        to a file system path; not recommended for general use."
        return unquote(pathname)

    def pathname2url(pathname):
        "OS-specific conversion from a file system path to a relative URL\n        of the 'file' scheme; not recommended for general use."
        return quote(pathname)
_urlopener = None
ftpcache = {}
_localhost = None
_thishost = None
_ftperrors = None
_noheaders = None
try:
    unicode
except NameError:

    def _is_unicode(x):
        return 0
else:

    def _is_unicode(x):
        return isinstance(x, unicode)
_typeprog = None
_hostprog = None
_userprog = None
_passwdprog = None
_portprog = None
_nportprog = None
_queryprog = None
_tagprog = None
_valueprog = None
_hextochr = dict(((('%02x' % i), chr(i)) for i in range(256)))
_hextochr.update(((('%02X' % i), chr(i)) for i in range(256)))
always_safe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-'
_safemaps = {}
if (sys.platform == 'darwin'):

    def getproxies_internetconfig():
        'Return a dictionary of scheme -> proxy server URL mappings.\n\n        By convention the mac uses Internet Config to store\n        proxies.  An HTTP proxy, for instance, is stored under\n        the HttpProxy key.\n\n        '
        try:
            import ic
        except ImportError:
            return {}
        try:
            config = ic.IC()
        except ic.error:
            return {}
        proxies = {}
        if (('UseHTTPProxy' in config) and config['UseHTTPProxy']):
            try:
                value = config['HTTPProxyHost']
            except ic.error:
                pass
            else:
                proxies['http'] = ('http://%s' % value)
        return proxies

    def proxy_bypass(x):
        return 0

    def getproxies():
        return (getproxies_environment() or getproxies_internetconfig())
elif (os.name == 'nt'):

    def getproxies_registry():
        'Return a dictionary of scheme -> proxy server URL mappings.\n\n        Win32 uses the registry to store proxies.\n\n        '
        proxies = {}
        try:
            import _winreg
        except ImportError:
            return proxies
        try:
            internetSettings = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, 'Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings')
            proxyEnable = _winreg.QueryValueEx(internetSettings, 'ProxyEnable')[0]
            if proxyEnable:
                proxyServer = str(_winreg.QueryValueEx(internetSettings, 'ProxyServer')[0])
                if ('=' in proxyServer):
                    for p in proxyServer.split(';'):
                        (protocol, address) = p.split('=', 1)
                        import re
                        if (not re.match('^([^/:]+)://', address)):
                            address = ('%s://%s' % (protocol, address))
                        proxies[protocol] = address
                elif (proxyServer[:5] == 'http:'):
                    proxies['http'] = proxyServer
                else:
                    proxies['http'] = ('http://%s' % proxyServer)
                    proxies['ftp'] = ('ftp://%s' % proxyServer)
            internetSettings.Close()
        except (WindowsError, ValueError, TypeError):
            pass
        return proxies

    def getproxies():
        'Return a dictionary of scheme -> proxy server URL mappings.\n\n        Returns settings gathered from the environment, if specified,\n        or the registry.\n\n        '
        return (getproxies_environment() or getproxies_registry())

    def proxy_bypass(host):
        try:
            import _winreg
            import re
        except ImportError:
            return 0
        try:
            internetSettings = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, 'Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings')
            proxyEnable = _winreg.QueryValueEx(internetSettings, 'ProxyEnable')[0]
            proxyOverride = str(_winreg.QueryValueEx(internetSettings, 'ProxyOverride')[0])
        except WindowsError:
            return 0
        if ((not proxyEnable) or (not proxyOverride)):
            return 0
        (rawHost, port) = splitport(host)
        host = [rawHost]
        try:
            addr = socket.gethostbyname(rawHost)
            if (addr != rawHost):
                host.append(addr)
        except socket.error:
            pass
        try:
            fqdn = socket.getfqdn(rawHost)
            if (fqdn != rawHost):
                host.append(fqdn)
        except socket.error:
            pass
        proxyOverride = proxyOverride.split(';')
        i = 0
        while (i < len(proxyOverride)):
            if (proxyOverride[i] == '<local>'):
                proxyOverride[i:(i + 1)] = ['localhost', '127.0.0.1', socket.gethostname(), socket.gethostbyname(socket.gethostname())]
            i += 1
        for test in proxyOverride:
            test = test.replace('.', '\\.')
            test = test.replace('*', '.*')
            test = test.replace('?', '.')
            for val in host:
                if re.match(test, val, re.I):
                    return 1
        return 0
else:
    getproxies = getproxies_environment

    def proxy_bypass(host):
        return 0
if (__name__ == '__main__'):
    main()
