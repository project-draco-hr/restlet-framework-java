def test_attributes(self):


    class Foo(object):
        pass
    Foo.__name__ = 'Bar'
    self.assertEqual(Foo.__name__, 'Bar')
    try:
        del Foo.__name__
    except TypeError as te:
        self.assertEqual(str(te), "can't delete Bar.__name__")
    else:
        self.assert_(False, 'Expected a TypeError')
    Foo.__module__ = 'baz'
    self.assertEqual(Foo.__module__, 'baz')
    try:
        del Foo.__module__
    except TypeError as te:
        self.assertEqual(str(te), "can't delete Bar.__module__")
    else:
        self.assert_(False, 'Expected a TypeError')
    try:
        Foo.__dict__ = {}
    except AttributeError as ae:
        self.assertEqual(str(ae), "attribute '__dict__' of 'type' objects is not writable")
    else:
        self.assert_(False, 'Expected an AttributeError')
    try:
        del Foo.__dict__
    except AttributeError as ae:
        self.assertEqual(str(ae), "attribute '__dict__' of 'type' objects is not writable")
    else:
        self.assert_(False, 'Expected an AttributeError')
    for (attr, val) in dict(__flags__=1, __base__=object, __bases__=(unicode, object), __mro__=(unicode, object)).iteritems():
        try:
            setattr(str, attr, val)
        except TypeError as te:
            self.assertEqual(str(te), self.TE_MSG)
        else:
            self.assert_(False, ('setattr Foo.%s expected a TypeError' % attr))
        try:
            delattr(str, attr)
        except TypeError as te:
            self.assertEqual(str(te), self.TE_MSG)
        else:
            self.assert_(False, ('delattr Foo.%s expected a TypeError' % attr))
