{
  getLogger().fine("In Validator resource");
  JSONObject response=new JSONObject();
  boolean authenticated=false;
  String lo=(String)getContext().getAttributes().get(LOCAL_ACCESS_ONLY);
  if ((lo != null) && (lo.length() > 0)) {
    boolean localOnly=Boolean.parseBoolean(lo);
    if (localOnly) {
      String scheme=getOriginalRef().getScheme();
      if (!Protocol.RIAP.getSchemeName().equals(scheme)) {
        setStatus(Status.CLIENT_ERROR_FORBIDDEN,"Auth server only allows local resource validation");
        return null;
      }
    }
  }
  try {
    String error=null;
    JsonRepresentation rest=new JsonRepresentation(input);
    JSONObject call=rest.getJsonObject();
    String token=call.get("access_token").toString();
    String uri=call.get("uri").toString();
    JSONArray scopes=null;
    if (call.has("scope")) {
      scopes=call.getJSONArray("scope");
    }
    String owner=null;
    if (call.has("owner")) {
      owner=call.getString("owner");
    }
    getLogger().fine("In Validator resource - searching for token = " + token);
    Token t=this.generator.findToken(token);
    if (t == null) {
      response.put("authenticated",authenticated);
      error=OAuthError.INVALID_TOKEN.name();
    }
 else {
      getLogger().fine("In Validator resource - got token = " + t);
      if (t instanceof ExpireToken) {
        ExpireToken et=(ExpireToken)t;
        if (!token.equals(et.getToken())) {
          error=OAuthError.INVALID_TOKEN.name();
          getLogger().warning("Should not use the refresh_token to sign!");
        }
      }
      getLogger().fine("Received uri = " + uri);
      getLogger().fine("Received scope = " + scopes);
      getLogger().fine("Received owner = " + owner);
      AuthenticatedUser user=t.getUser();
      authenticated=(user == null) ? false : true;
      if (!authenticated) {
        error=OAuthError.INVALID_REQUEST.name();
      }
      if (authenticated && (scopes != null) && (scopes.length() > 0)) {
        for (int i=0; i < scopes.length(); i++) {
          if (scopes.isNull(i)) {
            continue;
          }
          String scope=scopes.getString(i);
          boolean granted=user.isGrantedRole(Scopes.toRole(scope),owner);
          getLogger().fine("Granted permission : " + scope + " = "+ granted);
          if (!granted) {
            error=OAuthError.INSUFFICIENT_SCOPE.name();
            authenticated=false;
            break;
          }
        }
      }
      if (authenticated) {
        if ((owner != null) && (owner.length() > 0) && !AUTONOMOUS_USER.equals(user.getId())&& !owner.equals(user.getId())) {
          authenticated=false;
          error=OAuthError.INVALID_REQUEST.name();
        }
 else {
          response.put("tokenOwner",user.getId());
        }
      }
      response.put("authenticated",authenticated);
      if (error != null) {
        response.put("error",error);
      }
      getResponse().setCacheDirectives(noStore);
      getResponse().setCacheDirectives(noCache);
    }
  }
 catch (  JSONException e) {
    throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST,"Failed parse JSON",e);
  }
catch (  IOException e) {
    throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST,"Failed parse JSON",e);
  }
  return new JsonStringRepresentation(response);
}
