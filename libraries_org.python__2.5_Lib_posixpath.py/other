'Common operations on Posix pathnames.\n\nInstead of importing this module directly, import os and refer to\nthis module as os.path.  The "os.path" name is an alias for this\nmodule on Posix systems; on other systems (e.g. Mac, Windows),\nos.path provides the same operations in a manner specific to that\nplatform, and is an alias to another module (e.g. macpath, ntpath).\n\nSome of this can actually be useful on non-Posix systems too, e.g.\nfor manipulation of the pathname component of URLs.\n'
import java.io.File
import java.io.IOException
import os
import stat
from org.python.core.Py import newString
__all__ = ['normcase', 'isabs', 'join', 'splitdrive', 'split', 'splitext', 'basename', 'dirname', 'commonprefix', 'getsize', 'getmtime', 'getatime', 'getctime', 'islink', 'exists', 'lexists', 'isdir', 'isfile', 'walk', 'expanduser', 'expandvars', 'normpath', 'abspath', 'samefile', 'curdir', 'pardir', 'sep', 'pathsep', 'defpath', 'altsep', 'extsep', 'devnull', 'realpath', 'supports_unicode_filenames']
curdir = '.'
pardir = '..'
extsep = '.'
sep = '/'
pathsep = ':'
defpath = ':/bin:/usr/bin'
altsep = None
devnull = '/dev/null'
if (not os._native_posix):

    def samefile(f1, f2):
        'Test whether two pathnames reference the same actual file'
        canon1 = newString(java.io.File(_ensure_str(f1)).getCanonicalPath())
        canon2 = newString(java.io.File(_ensure_str(f2)).getCanonicalPath())
        return (canon1 == canon2)
else:

    def samefile(f1, f2):
        'Test whether two pathnames reference the same actual file'
        s1 = os.stat(f1)
        s2 = os.stat(f2)
        return samestat(s1, s2)
if hasattr(os, 'fstat'):

    def sameopenfile(fp1, fp2):
        'Test whether two open file objects reference the same file'
        s1 = os.fstat(fp1)
        s2 = os.fstat(fp2)
        return samestat(s1, s2)
    __all__.append('sameopenfile')
if os._native_posix:

    def samestat(s1, s2):
        'Test whether two stat buffers reference the same file'
        return ((s1.st_ino == s2.st_ino) and (s1.st_dev == s2.st_dev))

    def ismount(path):
        'Test whether a path is a mount point'
        try:
            s1 = os.lstat(path)
            s2 = os.lstat(join(path, '..'))
        except os.error:
            return False
        dev1 = s1.st_dev
        dev2 = s2.st_dev
        if (dev1 != dev2):
            return True
        ino1 = s1.st_ino
        ino2 = s2.st_ino
        if (ino1 == ino2):
            return True
        return False
    __all__.extend(['samestat', 'ismount'])
_varprog = None
if (not os._native_posix):

    def _resolve_link(path):
        "Internal helper function.  Takes a path and follows symlinks\n        until we either arrive at something that isn't a symlink, or\n        encounter a path we've seen before (meaning that there's a loop).\n        "
        try:
            return newString(java.io.File(abspath(path)).getCanonicalPath())
        except java.io.IOException:
            return None
else:

    def _resolve_link(path):
        "Internal helper function.  Takes a path and follows symlinks\n        until we either arrive at something that isn't a symlink, or\n        encounter a path we've seen before (meaning that there's a loop).\n        "
        paths_seen = []
        while islink(path):
            if (path in paths_seen):
                return None
            paths_seen.append(path)
            resolved = os.readlink(path)
            if (not isabs(resolved)):
                dir = dirname(path)
                path = normpath(join(dir, resolved))
            else:
                path = normpath(resolved)
        return path
supports_unicode_filenames = False
