def testmod(m, name=None, globs=None, verbose=None, isprivate=None, report=1):
    'm, name=None, globs=None, verbose=None, isprivate=None, report=1\n\n    Test examples in docstrings in functions and classes reachable from\n    module m, starting with m.__doc__.  Private names are skipped.\n\n    Also test examples reachable from dict m.__test__ if it exists and is\n    not None.  m.__dict__ maps names to functions, classes and strings;\n    function and class docstrings are tested even if the name is private;\n    strings are tested directly, as if they were docstrings.\n\n    Return (#failures, #tests).\n\n    See doctest.__doc__ for an overview.\n\n    Optional keyword arg "name" gives the name of the module; by default\n    use m.__name__.\n\n    Optional keyword arg "globs" gives a dict to be used as the globals\n    when executing examples; by default, use m.__dict__.  A copy of this\n    dict is actually used for each docstring, so that each docstring\'s\n    examples start with a clean slate.\n\n    Optional keyword arg "verbose" prints lots of stuff if true, prints\n    only failures if false; by default, it\'s true iff "-v" is in sys.argv.\n\n    Optional keyword arg "isprivate" specifies a function used to\n    determine whether a name is private.  The default function is\n    doctest.is_private; see its docs for details.\n\n    Optional keyword arg "report" prints a summary at the end when true,\n    else prints nothing at the end.  In verbose mode, the summary is\n    detailed, else very brief (in fact, empty if all tests passed).\n\n    Advanced tomfoolery:  testmod runs methods of a local instance of\n    class doctest.Tester, then merges the results into (or creates)\n    global Tester instance doctest.master.  Methods of doctest.master\n    can be called directly too, if you want to do something unusual.\n    Passing report=0 to testmod is especially useful then, to delay\n    displaying a summary.  Invoke doctest.master.summarize(verbose)\n    when you\'re done fiddling.\n    '
    global master
    if (not _ismodule(m)):
        raise TypeError(('testmod: module required; ' + `m`))
    if (name is None):
        name = m.__name__
    tester = Tester(m, globs=globs, verbose=verbose, isprivate=isprivate)
    (failures, tries) = tester.rundoc(m, name)
    (f, t) = tester.rundict(m.__dict__, name, m)
    failures = (failures + f)
    tries = (tries + t)
    if hasattr(m, '__test__'):
        testdict = m.__test__
        if testdict:
            if (not hasattr(testdict, 'items')):
                raise TypeError(('testmod: module.__test__ must support .items(); ' + `testdict`))
            (f, t) = tester.run__test__(testdict, (name + '.__test__'))
            failures = (failures + f)
            tries = (tries + t)
    if report:
        tester.summarize()
    if (master is None):
        master = tester
    else:
        master.merge(tester)
    return (failures, tries)
