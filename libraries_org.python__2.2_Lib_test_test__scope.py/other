from test_support import verify, TestFailed, check_syntax
import warnings
warnings.filterwarnings('ignore', 'import \\*', SyntaxWarning, '<string>')
print '1. simple nesting'
inc = make_adder(1)
plus10 = make_adder(10)
verify((inc(1) == 2))
verify((plus10((-2)) == 8))
print '2. extra nesting'
inc = make_adder2(1)
plus10 = make_adder2(10)
verify((inc(1) == 2))
verify((plus10((-2)) == 8))
print '3. simple nesting + rebinding'
inc = make_adder3(0)
plus10 = make_adder3(9)
verify((inc(1) == 2))
verify((plus10((-2)) == 8))
print '4. nesting with global but no free'
global_x = 1
adder = make_adder4()
verify((adder(1) == 2))
global_x = 10
verify((adder((-2)) == 8))
print '5. nesting through class'
inc = make_adder5(1)
plus10 = make_adder5(10)
verify((inc(1) == 2))
verify((plus10((-2)) == 8))
print '6. nesting plus free ref to global'
inc = make_adder6(1)
plus10 = make_adder6(10)
verify((inc(1) == 11))
verify((plus10((-2)) == 8))
print '7. nearest enclosing scope'
test_func = f(10)
verify((test_func(5) == 47))
print '8. mixed freevars and cellvars'
g = f(1, 2, 3)
h = g(2, 4, 6)
verify((h() == 39))
print '9. free variable in method'
t = test()
verify((t.test() == 'var'))
verify((t.method_and_var() == 'method'))
verify((t.actual_global() == 'global'))
method_and_var = 'var'
t = Test()
verify((t.test() == 'var'))
verify((t.method_and_var() == 'method'))
verify((t.actual_global() == 'global'))
print '10. recursion'
verify((f(6) == 720))
print '11. unoptimized namespaces'
check_syntax('def unoptimized_clash1(strip):\n    def f(s):\n        from string import *\n        return strip(s) # ambiguity: free or local\n    return f\n')
check_syntax('def unoptimized_clash2():\n    from string import *\n    def f(s):\n        return strip(s) # ambiguity: global or local\n    return f\n')
check_syntax('def unoptimized_clash2():\n    from string import *\n    def g():\n        def f(s):\n            return strip(s) # ambiguity: global or local\n        return f\n')
check_syntax('def error(y):\n    exec "a = 1"\n    def f(x):\n        return x + y\n    return f\n')
check_syntax("def f(x):\n    def g():\n        return x\n    del x # can't del name\n")
check_syntax('def f():\n    def g():\n         from string import *\n         return strip # global or local?\n')
exec '\ndef noproblem1():\n    from string import *\n    f = lambda x:x\n\ndef noproblem2():\n    from string import *\n    def f(x):\n        return x + 1\n\ndef noproblem3():\n    from string import *\n    def f(x):\n        global y\n        y = x\n'
print '12. lambdas'
f1 = (lambda x: (lambda y: (x + y)))
inc = f1(1)
plus10 = f1(10)
verify((inc(1) == 2))
verify((plus10(5) == 15))
f2 = (lambda x: (lambda : (lambda y: (x + y)))())
inc = f2(1)
plus10 = f2(10)
verify((inc(1) == 2))
verify((plus10(5) == 15))
f3 = (lambda x: (lambda y: (global_x + y)))
global_x = 1
inc = f3(None)
verify((inc(2) == 3))
f8 = (lambda x, y, z: (lambda a, b, c: (lambda : (z * (b + y)))))
g = f8(1, 2, 3)
h = g(2, 4, 6)
verify((h() == 18))
print '13. UnboundLocal'
try:
    errorInOuter()
except UnboundLocalError:
    pass
else:
    raise TestFailed
try:
    errorInInner()
except NameError:
    pass
else:
    raise TestFailed
print '14. complex definitions'
verify((makeReturner(1, 2, 3)() == (1, 2, 3)))
verify((makeReturner2(a=11)()['a'] == 11))
verify((makeAddPair((1, 2))((100, 200)) == (101, 202)))
print '15. scope of global statements'
x = 7
verify((f() == 7))
verify((x == 7))
x = 7
verify((f() == 2))
verify((x == 7))
x = 7
verify((f() == 2))
verify((x == 2))
x = 7
verify((f() == 2))
verify((x == 2))
print '16. check leaks'
for i in range(100):
    f1()
import os
if (os.name == 'java'):
    from java.lang import System, Thread
    System.gc()
    Thread.sleep(100)
    System.gc()
verify((Foo.count == 0))
print '17. class and global'
x = 0
verify((test(6)(2) == 8))
x = (-1)
verify((test(3)(2) == 5))
print '18. verify that locals() works'
d = f(2)(4)
verify(d.has_key('h'))
del d['h']
verify((d == {'x': 2, 'y': 7, 'w': 6, }))
print '19. var is bound and free in class'
inst = f(3)()
verify((inst.a == inst.m()))
print '20. interaction with trace function'
import sys
sys.settrace(tracer)
adaptgetter('foo', TestClass, (1, ''))
sys.settrace(None)
try:
    sys.settrace()
except TypeError:
    pass
else:
    raise TestFailed, 'sys.settrace() did not raise TypeError'
print '20. eval and exec with free variables'
g = f(3)
try:
    eval(g.func_code)
except TypeError:
    pass
else:
    print 'eval() should have failed, because code contained free vars'
try:
    exec g.func_code
except TypeError:
    pass
else:
    print 'exec should have failed, because code contained free vars'
print '21. list comprehension with local variables'
try:
    print bad
except NameError:
    pass
else:
    print 'bad should not be defined'
x()
try:
    print bad
except NameError:
    pass
print '22. eval with free variables'
f(4)()
