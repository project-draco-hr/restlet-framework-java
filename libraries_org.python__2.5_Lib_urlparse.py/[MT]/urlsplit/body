def urlsplit(url, scheme='', allow_fragments=True):
    "Parse a URL into 5 components:\n    <scheme>://<netloc>/<path>?<query>#<fragment>\n    Return a 5-tuple: (scheme, netloc, path, query, fragment).\n    Note that we don't break the components up in smaller bits\n    (e.g. netloc is a single string) and we don't expand % escapes."
    allow_fragments = bool(allow_fragments)
    key = (url, scheme, allow_fragments, type(url), type(scheme))
    cached = _parse_cache.get(key, None)
    if cached:
        return cached
    if (len(_parse_cache) >= MAX_CACHE_SIZE):
        clear_cache()
    netloc = query = fragment = ''
    i = url.find(':')
    if (i > 0):
        if (url[:i] == 'http'):
            scheme = url[:i].lower()
            url = url[(i + 1):]
            if (url[:2] == '//'):
                (netloc, url) = _splitnetloc(url, 2)
            if (allow_fragments and ('#' in url)):
                (url, fragment) = url.split('#', 1)
            if ('?' in url):
                (url, query) = url.split('?', 1)
            v = SplitResult(scheme, netloc, url, query, fragment)
            _parse_cache[key] = v
            return v
        for c in url[:i]:
            if (c not in scheme_chars):
                break
        else:
            (scheme, url) = (url[:i].lower(), url[(i + 1):])
    if ((scheme in uses_netloc) and (url[:2] == '//')):
        (netloc, url) = _splitnetloc(url, 2)
    if (allow_fragments and (scheme in uses_fragment) and ('#' in url)):
        (url, fragment) = url.split('#', 1)
    if ((scheme in uses_query) and ('?' in url)):
        (url, query) = url.split('?', 1)
    v = SplitResult(scheme, netloc, url, query, fragment)
    _parse_cache[key] = v
    return v
