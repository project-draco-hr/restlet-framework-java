def iter_importers(fullname=''):
    'Yield PEP 302 importers for the given module name\n\n    If fullname contains a \'.\', the importers will be for the package\n    containing fullname, otherwise they will be importers for sys.meta_path,\n    sys.path, and Python\'s "classic" import machinery, in that order.  If\n    the named module is in a package, that package is imported as a side\n    effect of invoking this function.\n\n    Non PEP 302 mechanisms (e.g. the Windows registry) used by the\n    standard import machinery to find files in alternative locations\n    are partially supported, but are searched AFTER sys.path. Normally,\n    these locations are searched BEFORE sys.path, preventing sys.path\n    entries from shadowing them.\n\n    For this to cause a visible difference in behaviour, there must\n    be a module or package name that is accessible via both sys.path\n    and one of the non PEP 302 file system mechanisms. In this case,\n    the emulation will find the former version, while the builtin\n    import mechanism will find the latter.\n\n    Items of the following types can be affected by this discrepancy:\n        imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY\n    '
    if fullname.startswith('.'):
        raise ImportError('Relative module names not supported')
    if ('.' in fullname):
        pkg = '.'.join(fullname.split('.')[:(-1)])
        if (pkg not in sys.modules):
            __import__(pkg)
        path = (getattr(sys.modules[pkg], '__path__', None) or [])
    else:
        for importer in sys.meta_path:
            yield importer
        path = sys.path
    for item in path:
        yield get_importer(item)
    if ('.' not in fullname):
        yield ImpImporter()
