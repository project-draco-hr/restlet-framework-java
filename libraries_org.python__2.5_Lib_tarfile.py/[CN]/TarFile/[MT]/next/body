def next(self):
    'Return the next member of the archive as a TarInfo object, when\n           TarFile is opened for reading. Return None if there is no more\n           available.\n        '
    self._check('ra')
    if (self.firstmember is not None):
        m = self.firstmember
        self.firstmember = None
        return m
    self.fileobj.seek(self.offset)
    while True:
        buf = self.fileobj.read(BLOCKSIZE)
        if (not buf):
            return None
        try:
            tarinfo = TarInfo.frombuf(buf)
            tarinfo.offset = self.offset
            self.offset += BLOCKSIZE
            tarinfo = self.proc_member(tarinfo)
        except ValueError as e:
            if self.ignore_zeros:
                self._dbg(2, ('0x%X: empty or invalid block: %s' % (self.offset, e)))
                self.offset += BLOCKSIZE
                continue
            else:
                if (self.offset == 0):
                    raise ReadError(('empty, unreadable or compressed file: %s' % e))
                return None
        break
    if (tarinfo.isreg() and tarinfo.name.endswith('/')):
        tarinfo.type = DIRTYPE
    if (tarinfo.isdir() and (not tarinfo.name.endswith('/'))):
        tarinfo.name += '/'
    self.members.append(tarinfo)
    return tarinfo
