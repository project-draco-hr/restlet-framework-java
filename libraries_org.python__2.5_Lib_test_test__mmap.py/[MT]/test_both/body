def test_both():
    'Test mmap module on Unix systems and Windows'
    if os.path.exists(TESTFN):
        os.unlink(TESTFN)
    f = open(TESTFN, 'w+')
    try:
        f.write(('\x00' * PAGESIZE))
        f.write('foo')
        f.write(('\x00' * (PAGESIZE - 3)))
        f.flush()
        m = mmap.mmap(f.fileno(), (2 * PAGESIZE))
        f.close()
        print type(m)
        print '  Position of foo:', (m.find('foo') / float(PAGESIZE)), 'pages'
        vereq(m.find('foo'), PAGESIZE)
        print '  Length of file:', (len(m) / float(PAGESIZE)), 'pages'
        vereq(len(m), (2 * PAGESIZE))
        print '  Contents of byte 0:', repr(m[0])
        vereq(m[0], '\x00')
        print '  Contents of first 3 bytes:', repr(m[0:3])
        vereq(m[0:3], '\x00\x00\x00')
        print "\n  Modifying file's content..."
        m[0] = '3'
        m[(PAGESIZE + 3):((PAGESIZE + 3) + 3)] = 'bar'
        print '  Contents of byte 0:', repr(m[0])
        vereq(m[0], '3')
        print '  Contents of first 3 bytes:', repr(m[0:3])
        vereq(m[0:3], '3\x00\x00')
        print '  Contents of second page:', repr(m[(PAGESIZE - 1):(PAGESIZE + 7)])
        vereq(m[(PAGESIZE - 1):(PAGESIZE + 7)], '\x00foobar\x00')
        m.flush()
        match = re.search('[A-Za-z]+', m)
        if (match is None):
            print '  ERROR: regex match on mmap failed!'
        else:
            (start, end) = match.span(0)
            length = (end - start)
            print '  Regex match on mmap (page start, length of match):',
            print (start / float(PAGESIZE)), length
            vereq(start, PAGESIZE)
            vereq(end, (PAGESIZE + 6))
        m.seek(0, 0)
        print '  Seek to zeroth byte'
        vereq(m.tell(), 0)
        m.seek(42, 1)
        print '  Seek to 42nd byte'
        vereq(m.tell(), 42)
        m.seek(0, 2)
        print '  Seek to last byte'
        vereq(m.tell(), len(m))
        print '  Try to seek to negative position...'
        try:
            m.seek((-1))
        except ValueError:
            pass
        else:
            verify(0, 'expected a ValueError but did not get it')
        print '  Try to seek beyond end of mmap...'
        try:
            m.seek(1, 2)
        except ValueError:
            pass
        else:
            verify(0, 'expected a ValueError but did not get it')
        print '  Try to seek to negative position...'
        try:
            m.seek(((- len(m)) - 1), 2)
        except ValueError:
            pass
        else:
            verify(0, 'expected a ValueError but did not get it')
        print '  Attempting resize()'
        try:
            m.resize(512)
        except SystemError:
            pass
        else:
            verify((len(m) == 512), ('len(m) is %d, but expecting 512' % (len(m),)))
            try:
                m.seek(513, 0)
            except ValueError:
                pass
            else:
                verify(0, 'Could seek beyond the new size')
            f = open(TESTFN)
            f.seek(0, 2)
            verify((f.tell() == 512), 'Underlying file not truncated')
            f.close()
            verify((m.size() == 512), 'New size not reflected in file')
        m.close()
    finally:
        try:
            f.close()
        except OSError:
            pass
        try:
            os.unlink(TESTFN)
        except OSError:
            pass
    try:
        mapsize = 10
        print '  Creating', mapsize, 'byte test data file.'
        open(TESTFN, 'wb').write(('a' * mapsize))
        print '  Opening mmap with access=ACCESS_READ'
        f = open(TESTFN, 'rb')
        m = mmap.mmap(f.fileno(), mapsize, access=mmap.ACCESS_READ)
        verify((m[:] == ('a' * mapsize)), 'Readonly memory map data incorrect.')
        print "  Ensuring that readonly mmap can't be slice assigned."
        try:
            m[:] = ('b' * mapsize)
        except TypeError:
            pass
        else:
            verify(0, 'Able to write to readonly memory map')
        print "  Ensuring that readonly mmap can't be item assigned."
        try:
            m[0] = 'b'
        except TypeError:
            pass
        else:
            verify(0, 'Able to write to readonly memory map')
        print "  Ensuring that readonly mmap can't be write() to."
        try:
            m.seek(0, 0)
            m.write('abc')
        except TypeError:
            pass
        else:
            verify(0, 'Able to write to readonly memory map')
        print "  Ensuring that readonly mmap can't be write_byte() to."
        try:
            m.seek(0, 0)
            m.write_byte('d')
        except TypeError:
            pass
        else:
            verify(0, 'Able to write to readonly memory map')
        print "  Ensuring that readonly mmap can't be resized."
        try:
            m.resize((2 * mapsize))
        except SystemError:
            pass
        except TypeError:
            pass
        else:
            verify(0, 'Able to resize readonly memory map')
        del m, f
        verify((open(TESTFN, 'rb').read() == ('a' * mapsize)), 'Readonly memory map data file was modified')
        print '  Opening mmap with size too big'
        import sys
        f = open(TESTFN, 'r+b')
        try:
            m = mmap.mmap(f.fileno(), (mapsize + 1))
        except ValueError:
            if sys.platform.startswith('win'):
                verify(0, 'Opening mmap with size+1 should work on Windows.')
        else:
            if (not sys.platform.startswith('win')):
                verify(0, 'Opening mmap with size+1 should raise ValueError.')
            m.close()
        f.close()
        if sys.platform.startswith('win'):
            f = open(TESTFN, 'r+b')
            f.truncate(mapsize)
            f.close()
        print '  Opening mmap with access=ACCESS_WRITE'
        f = open(TESTFN, 'r+b')
        m = mmap.mmap(f.fileno(), mapsize, access=mmap.ACCESS_WRITE)
        print '  Modifying write-through memory map.'
        m[:] = ('c' * mapsize)
        verify((m[:] == ('c' * mapsize)), 'Write-through memory map memory not updated properly.')
        m.flush()
        m.close()
        f.close()
        f = open(TESTFN, 'rb')
        stuff = f.read()
        f.close()
        verify((stuff == ('c' * mapsize)), 'Write-through memory map data file not updated properly.')
        print '  Opening mmap with access=ACCESS_COPY'
        f = open(TESTFN, 'r+b')
        m = mmap.mmap(f.fileno(), mapsize, access=mmap.ACCESS_COPY)
        print '  Modifying copy-on-write memory map.'
        m[:] = ('d' * mapsize)
        verify((m[:] == ('d' * mapsize)), 'Copy-on-write memory map data not written correctly.')
        m.flush()
        verify((open(TESTFN, 'rb').read() == ('c' * mapsize)), 'Copy-on-write test data file should not be modified.')
        try:
            print '  Ensuring copy-on-write maps cannot be resized.'
            m.resize((2 * mapsize))
        except TypeError:
            pass
        else:
            verify(0, 'Copy-on-write mmap resize did not raise exception.')
        del m, f
        try:
            print '  Ensuring invalid access parameter raises exception.'
            f = open(TESTFN, 'r+b')
            m = mmap.mmap(f.fileno(), mapsize, access=4)
        except ValueError:
            pass
        else:
            verify(0, 'Invalid access code should have raised exception.')
        if (os.name == 'posix'):
            f = open(TESTFN, 'r+b')
            try:
                m = mmap.mmap(f.fileno(), mapsize, flags=mmap.MAP_PRIVATE, prot=mmap.PROT_READ, access=mmap.ACCESS_WRITE)
            except ValueError:
                pass
            else:
                verify(0, 'Incompatible parameters should raise ValueError.')
            f.close()
    finally:
        try:
            os.unlink(TESTFN)
        except OSError:
            pass
    print '  Try opening a bad file descriptor...'
    try:
        mmap.mmap((-2), 4096)
    except mmap.error:
        pass
    else:
        verify(0, 'expected a mmap.error but did not get it')
    f = open(TESTFN, 'w+')
    try:
        data = 'aabaac\x00deef\x00\x00aa\x00'
        n = len(data)
        f.write(data)
        f.flush()
        m = mmap.mmap(f.fileno(), n)
        f.close()
        for start in range((n + 1)):
            for finish in range(start, (n + 1)):
                slice = data[start:finish]
                vereq(m.find(slice), data.find(slice))
                vereq(m.find((slice + 'x')), (-1))
        m.close()
    finally:
        os.unlink(TESTFN)
    f = open(TESTFN, 'w+')
    try:
        f.write(((2 ** 16) * 'a'))
        f.close()
        f = open(TESTFN)
        mf = mmap.mmap(f.fileno(), (2 ** 16), access=mmap.ACCESS_READ)
        mf.close()
        mf.close()
        f.close()
    finally:
        os.unlink(TESTFN)
    if hasattr(os, 'stat'):
        print '  Ensuring that passing 0 as map length sets map size to current file size.'
        f = open(TESTFN, 'w+')
        try:
            f.write(((2 ** 16) * 'm'))
            f.close()
            f = open(TESTFN, 'rb+')
            mf = mmap.mmap(f.fileno(), 0)
            verify((len(mf) == (2 ** 16)), 'Map size should equal file size.')
            vereq(mf.read((2 ** 16)), ((2 ** 16) * 'm'))
            mf.close()
            f.close()
        finally:
            os.unlink(TESTFN)
    if hasattr(os, 'stat'):
        print '  Ensuring that passing 0 as map length sets map size to current file size.'
        f = open(TESTFN, 'w+')
        try:
            f.write(((2 ** 16) * 'm'))
            f.close()
            f = open(TESTFN, 'rb+')
            mf = mmap.mmap(f.fileno(), 0)
            verify((len(mf) == (2 ** 16)), 'Map size should equal file size.')
            vereq(mf.read((2 ** 16)), ((2 ** 16) * 'm'))
            mf.close()
            f.close()
        finally:
            os.unlink(TESTFN)
    f = open(TESTFN, 'w+')
    try:
        f.write('ABCDEabcde')
        f.flush()
        mf = mmap.mmap(f.fileno(), 10)
        mf.move(5, 0, 5)
        verify((mf[:] == 'ABCDEABCDE'), 'Map move should have duplicated front 5')
        mf.close()
        f.close()
    finally:
        os.unlink(TESTFN)
    if hasattr(mmap, 'PROT_READ'):
        try:
            mapsize = 10
            open(TESTFN, 'wb').write(('a' * mapsize))
            f = open(TESTFN, 'rb')
            m = mmap.mmap(f.fileno(), mapsize, prot=mmap.PROT_READ)
            try:
                m.write('foo')
            except TypeError:
                pass
            else:
                verify(0, 'PROT_READ is not working')
        finally:
            os.unlink(TESTFN)
