def _command(self, name, *args):
    if (self.state not in Commands[name]):
        self.literal = None
        raise self.error(('command %s illegal in state %s' % (name, self.state)))
    for typ in ('OK', 'NO', 'BAD'):
        if self.untagged_responses.has_key(typ):
            del self.untagged_responses[typ]
    if (self.untagged_responses.has_key('READ-ONLY') and (not self.is_readonly)):
        raise self.readonly('mailbox status changed to READ-ONLY')
    tag = self._new_tag()
    data = ('%s %s' % (tag, name))
    for arg in args:
        if (arg is None):
            continue
        data = ('%s %s' % (data, self._checkquote(arg)))
    literal = self.literal
    if (literal is not None):
        self.literal = None
        if (type(literal) is type(self._command)):
            literator = literal
        else:
            literator = None
            data = ('%s {%s}' % (data, len(literal)))
    if __debug__:
        if (self.debug >= 4):
            _mesg(('> %s' % data))
        else:
            _log(('> %s' % data))
    try:
        self.send(('%s%s' % (data, CRLF)))
    except (socket.error, OSError) as val:
        raise self.abort(('socket error: %s' % val))
    if (literal is None):
        return tag
    while 1:
        while self._get_response():
            if self.tagged_commands[tag]:
                return tag
        if literator:
            literal = literator(self.continuation_response)
        if __debug__:
            if (self.debug >= 4):
                _mesg(('write literal size %s' % len(literal)))
        try:
            self.send(literal)
            self.send(CRLF)
        except (socket.error, OSError) as val:
            raise self.abort(('socket error: %s' % val))
        if (not literator):
            break
    return tag
