def parse_multipart(fp, pdict):
    'Parse multipart input.\n\n    Arguments:\n    fp   : input file\n    pdict: dictionary containing other parameters of conten-type header\n\n    Returns a dictionary just like parse_qs(): keys are the field names, each\n    value is a list of values for that field.  This is easy to use but not\n    much good if you are expecting megabytes to be uploaded -- in that case,\n    use the FieldStorage class instead which is much more flexible.  Note\n    that content-type is the raw, unparsed contents of the content-type\n    header.\n\n    XXX This does not parse nested multipart parts -- use FieldStorage for\n    that.\n\n    XXX This should really be subsumed by FieldStorage altogether -- no\n    point in having two implementations of the same parsing algorithm.\n\n    '
    boundary = ''
    if pdict.has_key('boundary'):
        boundary = pdict['boundary']
    if (not valid_boundary(boundary)):
        raise ValueError, ('Invalid boundary in multipart form: %s' % `boundary`)
    nextpart = ('--' + boundary)
    lastpart = (('--' + boundary) + '--')
    partdict = {}
    terminator = ''
    while (terminator != lastpart):
        bytes = (-1)
        data = None
        if terminator:
            headers = mimetools.Message(fp)
            clength = headers.getheader('content-length')
            if clength:
                try:
                    bytes = int(clength)
                except ValueError:
                    pass
            if (bytes > 0):
                if (maxlen and (bytes > maxlen)):
                    raise ValueError, 'Maximum content length exceeded'
                data = fp.read(bytes)
            else:
                data = ''
        lines = []
        while 1:
            line = fp.readline()
            if (not line):
                terminator = lastpart
                break
            if (line[:2] == '--'):
                terminator = line.strip()
                if (terminator in (nextpart, lastpart)):
                    break
            lines.append(line)
        if (data is None):
            continue
        if (bytes < 0):
            if lines:
                line = lines[(-1)]
                if (line[(-2):] == '\r\n'):
                    line = line[:(-2)]
                elif (line[(-1):] == '\n'):
                    line = line[:(-1)]
                lines[(-1)] = line
                data = ''.join(lines)
        line = headers['content-disposition']
        if (not line):
            continue
        (key, params) = parse_header(line)
        if (key != 'form-data'):
            continue
        if params.has_key('name'):
            name = params['name']
        else:
            continue
        if partdict.has_key(name):
            partdict[name].append(data)
        else:
            partdict[name] = [data]
    return partdict
