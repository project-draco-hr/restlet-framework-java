def __init__(self, fp=None, headers=None, outerboundary='', environ=os.environ, keep_blank_values=0, strict_parsing=0):
    'Constructor.  Read multipart/* until last part.\n\n        Arguments, all optional:\n\n        fp              : file pointer; default: sys.stdin\n            (not used when the request method is GET)\n\n        headers         : header dictionary-like object; default:\n            taken from environ as per CGI spec\n\n        outerboundary   : terminating multipart boundary\n            (for internal use only)\n\n        environ         : environment dictionary; default: os.environ\n\n        keep_blank_values: flag indicating whether blank values in\n            URL encoded forms should be treated as blank strings.\n            A true value indicates that blanks should be retained as\n            blank strings.  The default false value indicates that\n            blank values are to be ignored and treated as if they were\n            not included.\n\n        strict_parsing: flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored.\n            If true, errors raise a ValueError exception.\n\n        '
    method = 'GET'
    self.keep_blank_values = keep_blank_values
    self.strict_parsing = strict_parsing
    if environ.has_key('REQUEST_METHOD'):
        method = environ['REQUEST_METHOD'].upper()
    if ((method == 'GET') or (method == 'HEAD')):
        if environ.has_key('QUERY_STRING'):
            qs = environ['QUERY_STRING']
        elif sys.argv[1:]:
            qs = sys.argv[1]
        else:
            qs = ''
        fp = StringIO(qs)
        if (headers is None):
            headers = {'content-type': 'application/x-www-form-urlencoded', }
    if (headers is None):
        headers = {}
        if (method == 'POST'):
            headers['content-type'] = 'application/x-www-form-urlencoded'
        if environ.has_key('CONTENT_TYPE'):
            headers['content-type'] = environ['CONTENT_TYPE']
        if environ.has_key('CONTENT_LENGTH'):
            headers['content-length'] = environ['CONTENT_LENGTH']
    self.fp = (fp or sys.stdin)
    self.headers = headers
    self.outerboundary = outerboundary
    (cdisp, pdict) = ('', {})
    if self.headers.has_key('content-disposition'):
        (cdisp, pdict) = parse_header(self.headers['content-disposition'])
    self.disposition = cdisp
    self.disposition_options = pdict
    self.name = None
    if pdict.has_key('name'):
        self.name = pdict['name']
    self.filename = None
    if pdict.has_key('filename'):
        self.filename = pdict['filename']
    if self.headers.has_key('content-type'):
        (ctype, pdict) = parse_header(self.headers['content-type'])
    elif (self.outerboundary or (method != 'POST')):
        (ctype, pdict) = ('text/plain', {})
    else:
        (ctype, pdict) = ('application/x-www-form-urlencoded', {})
    self.type = ctype
    self.type_options = pdict
    self.innerboundary = ''
    if pdict.has_key('boundary'):
        self.innerboundary = pdict['boundary']
    clen = (-1)
    if self.headers.has_key('content-length'):
        try:
            clen = int(self.headers['content-length'])
        except:
            pass
        if (maxlen and (clen > maxlen)):
            raise ValueError, 'Maximum content length exceeded'
    self.length = clen
    self.list = self.file = None
    self.done = 0
    if (ctype == 'application/x-www-form-urlencoded'):
        self.read_urlencoded()
    elif (ctype[:10] == 'multipart/'):
        self.read_multi(environ, keep_blank_values, strict_parsing)
    else:
        self.read_single()
