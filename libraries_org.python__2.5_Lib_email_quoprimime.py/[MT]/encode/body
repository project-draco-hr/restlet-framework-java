def encode(body, binary=False, maxlinelen=76, eol=NL):
    'Encode with quoted-printable, wrapping at maxlinelen characters.\n\n    If binary is False (the default), end-of-line characters will be converted\n    to the canonical email end-of-line sequence \\r\\n.  Otherwise they will\n    be left verbatim.\n\n    Each line of encoded text will end with eol, which defaults to "\\n".  Set\n    this to "\\r\\n" if you will be using the result of this function directly\n    in an email.\n\n    Each line will be wrapped at, at most, maxlinelen characters (defaults to\n    76 characters).  Long lines will have the `soft linefeed\' quoted-printable\n    character "=" appended to them, so the decoded text will be identical to\n    the original text.\n    '
    if (not body):
        return body
    if (not binary):
        body = fix_eols(body)
    encoded_body = ''
    lineno = (-1)
    lines = body.splitlines(1)
    for line in lines:
        if line.endswith(CRLF):
            line = line[:(-2)]
        elif (line[(-1)] in CRLF):
            line = line[:(-1)]
        lineno += 1
        encoded_line = ''
        prev = None
        linelen = len(line)
        for j in range(linelen):
            c = line[j]
            prev = c
            if bqre.match(c):
                c = quote(c)
            elif ((j + 1) == linelen):
                if (c not in ' \t'):
                    encoded_line += c
                prev = c
                continue
            if ((len(encoded_line) + len(c)) >= maxlinelen):
                encoded_body += ((encoded_line + '=') + eol)
                encoded_line = ''
            encoded_line += c
        if (prev and (prev in ' \t')):
            if ((lineno + 1) == len(lines)):
                prev = quote(prev)
                if ((len(encoded_line) + len(prev)) > maxlinelen):
                    encoded_body += (((encoded_line + '=') + eol) + prev)
                else:
                    encoded_body += (encoded_line + prev)
            else:
                encoded_body += (((encoded_line + prev) + '=') + eol)
            encoded_line = ''
        if (lines[lineno].endswith(CRLF) or (lines[lineno][(-1)] in CRLF)):
            encoded_body += (encoded_line + eol)
        else:
            encoded_body += encoded_line
        encoded_line = ''
    return encoded_body
