def read(self, name):
    'Return file bytes (as a string) for name.'
    if (self.mode not in ('r', 'a')):
        raise RuntimeError, 'read() requires mode "r" or "a"'
    if (not self.fp):
        raise RuntimeError, 'Attempt to read ZIP archive that was already closed'
    zinfo = self.getinfo(name)
    filepos = self.fp.tell()
    self.fp.seek(zinfo.header_offset, 0)
    fheader = self.fp.read(30)
    if (fheader[0:4] != stringFileHeader):
        raise BadZipfile, 'Bad magic number for file header'
    fheader = struct.unpack(structFileHeader, fheader)
    fname = self.fp.read(fheader[_FH_FILENAME_LENGTH])
    if fheader[_FH_EXTRA_FIELD_LENGTH]:
        self.fp.read(fheader[_FH_EXTRA_FIELD_LENGTH])
    if (fname != zinfo.orig_filename):
        raise BadZipfile, ('File name in directory "%s" and header "%s" differ.' % (zinfo.orig_filename, fname))
    bytes = self.fp.read(zinfo.compress_size)
    self.fp.seek(filepos, 0)
    if (zinfo.compress_type == ZIP_STORED):
        pass
    elif (zinfo.compress_type == ZIP_DEFLATED):
        if (not zlib):
            raise RuntimeError, 'De-compression requires the (missing) zlib module'
        dc = zlib.decompressobj((-15))
        bytes = dc.decompress(bytes)
        ex = (dc.decompress('Z') + dc.flush())
        if ex:
            bytes = (bytes + ex)
    else:
        raise BadZipfile, ('Unsupported compression method %d for file %s' % (zinfo.compress_type, name))
    crc = binascii.crc32(bytes)
    if (crc != zinfo.CRC):
        raise BadZipfile, ('Bad CRC-32 for file %s' % name)
    return bytes
