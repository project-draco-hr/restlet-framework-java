'Test the functionality of Python classes implementing operators.'
from test.test_support import TestFailed
testmeths = ['add', 'radd', 'sub', 'rsub', 'mul', 'rmul', 'div', 'rdiv', 'mod', 'rmod', 'divmod', 'rdivmod', 'pow', 'rpow', 'rshift', 'rrshift', 'lshift', 'rlshift', 'and', 'rand', 'or', 'ror', 'xor', 'rxor', 'contains', 'getitem', 'getslice', 'setitem', 'setslice', 'delitem', 'delslice', 'neg', 'pos', 'abs', 'init']
method_template = 'def __%(method)s__(self, *args):\n    print "__%(method)s__:", args\n'
for method in testmeths:
    exec (method_template % locals()) in AllTests.__dict__
del method, method_template
testme = AllTests()
(testme + 1)
(1 + testme)
(testme - 1)
(1 - testme)
(testme * 1)
(1 * testme)
if ((1 / 2) == 0):
    (testme / 1)
    (1 / testme)
else:
    testme.__coerce__(1)
    testme.__div__(1)
    testme.__coerce__(1)
    testme.__rdiv__(1)
(testme % 1)
(1 % testme)
divmod(testme, 1)
divmod(1, testme)
(testme ** 1)
(1 ** testme)
(testme >> 1)
(1 >> testme)
(testme << 1)
(1 << testme)
(testme & 1)
(1 & testme)
(testme | 1)
(1 | testme)
(testme ^ 1)
(1 ^ testme)
try:
    (1 in Empty())
    print 'failed, should have raised TypeError'
except TypeError:
    pass
(1 in testme)
testme[1]
testme[1] = 1
del testme[1]
testme[:42]
testme[:42] = 'The Answer'
del testme[:42]
testme[2:1024:10]
testme[2:1024:10] = 'A lot'
del testme[2:1024:10]
testme[:42, ..., :24:, 24, 100]
testme[:42, ..., :24:, 24, 100] = 'Strange'
del testme[:42, ..., :24:, 24, 100]
del AllTests.__getslice__
del AllTests.__setslice__
del AllTests.__delslice__
import sys
if (sys.platform[:4] != 'java'):
    testme[:42]
    testme[:42] = 'The Answer'
    del testme[:42]
else:
    print '__getitem__: (slice(0, 42, None),)'
    print "__setitem__: (slice(0, 42, None), 'The Answer')"
    print '__delitem__: (slice(0, 42, None),)'
(- testme)
(+ testme)
abs(testme)
int(testme)
long(testme)
float(testme)
oct(testme)
hex(testme)
hash(testme)
repr(testme)
str(testme)
(testme == 1)
(testme < 1)
(testme > 1)
(testme != 1)
(testme != 1)
(1 == testme)
(1 < testme)
(1 > testme)
(1 != testme)
(1 != testme)
del testme
if (sys.platform[:4] == 'java'):
    from test_weakref import extra_collect
    extra_collect()
testme = ExtraTests()
testme.spam
testme.eggs = 'spam, spam, spam and ham'
del testme.cardinal
check_exc('int(BadTypeClass())', TypeError)
check_exc('float(BadTypeClass())', TypeError)
check_exc('long(BadTypeClass())', TypeError)
check_exc('str(BadTypeClass())', TypeError)
check_exc('repr(BadTypeClass())', TypeError)
check_exc('oct(BadTypeClass())', TypeError)
check_exc('hex(BadTypeClass())', TypeError)
try:
    int(IntLongMixClass())
except TypeError:
    raise TestFailed, 'TypeError should not be raised'
try:
    long(IntLongMixClass())
except TypeError:
    raise TestFailed, 'TypeError should not be raised'
hash(C0())
check_exc('hash(C1())', TypeError)
check_exc('hash(C2())', TypeError)
A.__call__ = A()
a = A()
try:
    a()
except RuntimeError:
    pass
else:
    raise TestFailed, 'how could this not have overflowed the stack?'
try:
    A().a
except AttributeError as x:
    if (str(x) != 'booh'):
        print 'attribute error for A().a got masked:', str(x)
(E() == E())
try:
    I()
except AttributeError as x:
    pass
else:
    print 'attribute error for I.__init__ got masked'
a1 = A(1)
a2 = A(2)
assert (a1.f == a1.f)
assert (a1.f != a2.f)
assert (a1.f != a1.g)
assert (a1.f == A(1).f)
assert (hash(a1.f) == hash(a1.f))
assert (hash(a1.f) == hash(A(1).f))
assert (A.f != a1.f)
assert (A.f != A.g)
assert (B.f == A.f)
assert (hash(B.f) == hash(A.f))
a = A((hash(A.f.im_func) ^ (-1)))
hash(a.f)
