def main(tests=None, testdir=None, verbose=0, quiet=False, generate=False, exclude=False, single=False, randomize=False, fromfile=None, findleaks=False, use_resources=None, trace=False, coverdir='coverage', runleaks=False, huntrleaks=False, verbose2=False, expected=False, memo=None, junit_xml=None):
    "Execute a test suite.\n\n    This also parses command-line options and modifies its behavior\n    accordingly.\n\n    tests -- a list of strings containing test names (optional)\n    testdir -- the directory in which to look for tests (optional)\n\n    Users other than the Python test suite will certainly want to\n    specify testdir; if it's omitted, the directory containing the\n    Python test suite is searched for.\n\n    If the tests argument is omitted, the tests listed on the\n    command-line will be used.  If that's empty, too, then all *.py\n    files beginning with test_ will be used.\n\n    The other default arguments (verbose, quiet, generate, exclude, single,\n    randomize, findleaks, use_resources, trace and coverdir) allow programmers\n    calling main() directly to set the values that would normally be set by\n    flags on the command line.\n    "
    test_support.record_original_stdout(sys.stdout)
    try:
        (opts, args) = getopt.getopt(sys.argv[1:], 'hvgqxsrf:lu:t:TD:NLR:wM:em:j:', ['help', 'verbose', 'quiet', 'generate', 'exclude', 'single', 'random', 'fromfile', 'findleaks', 'use=', 'threshold=', 'trace', 'coverdir=', 'nocoverdir', 'runleaks', 'huntrleaks=', 'verbose2', 'memlimit=', 'expected', 'memo'])
    except getopt.error as msg:
        usage(2, msg)
    allran = True
    if (use_resources is None):
        use_resources = []
    for (o, a) in opts:
        if (o in ('-h', '--help')):
            usage(0)
        elif (o in ('-v', '--verbose')):
            verbose += 1
        elif (o in ('-w', '--verbose2')):
            verbose2 = True
        elif (o in ('-q', '--quiet')):
            quiet = True
            verbose = 0
        elif (o in ('-g', '--generate')):
            generate = True
        elif (o in ('-x', '--exclude')):
            exclude = True
            allran = False
        elif (o in ('-e', '--expected')):
            expected = True
            allran = False
        elif (o in ('-s', '--single')):
            single = True
        elif (o in ('-r', '--randomize')):
            randomize = True
        elif (o in ('-f', '--fromfile')):
            fromfile = a
        elif (o in ('-l', '--findleaks')):
            findleaks = True
        elif (o in ('-L', '--runleaks')):
            runleaks = True
        elif (o in ('-m', '--memo')):
            memo = a
        elif (o in ('-j', '--junit-xml')):
            junit_xml = a
        elif (o in ('-t', '--threshold')):
            import gc
            gc.set_threshold(int(a))
        elif (o in ('-T', '--coverage')):
            trace = True
        elif (o in ('-D', '--coverdir')):
            coverdir = os.path.join(os.getcwd(), a)
        elif (o in ('-N', '--nocoverdir')):
            coverdir = None
        elif (o in ('-R', '--huntrleaks')):
            huntrleaks = a.split(':')
            if (len(huntrleaks) != 3):
                print a, huntrleaks
                usage(2, '-R takes three colon-separated arguments')
            if (len(huntrleaks[0]) == 0):
                huntrleaks[0] = 5
            else:
                huntrleaks[0] = int(huntrleaks[0])
            if (len(huntrleaks[1]) == 0):
                huntrleaks[1] = 4
            else:
                huntrleaks[1] = int(huntrleaks[1])
            if (len(huntrleaks[2]) == 0):
                huntrleaks[2] = 'reflog.txt'
        elif (o in ('-M', '--memlimit')):
            test_support.set_memlimit(a)
        elif (o in ('-u', '--use')):
            u = [x.lower() for x in a.split(',')]
            for r in u:
                if (r == 'all'):
                    use_resources[:] = RESOURCE_NAMES
                    continue
                remove = False
                if (r[0] == '-'):
                    remove = True
                    r = r[1:]
                if (r not in RESOURCE_NAMES):
                    usage(1, ('Invalid -u/--use option: ' + a))
                if remove:
                    if (r in use_resources):
                        use_resources.remove(r)
                elif (r not in use_resources):
                    use_resources.append(r)
    if (generate and verbose):
        usage(2, "-g and -v don't go together!")
    if (single and fromfile):
        usage(2, "-s and -f don't go together!")
    good = []
    bad = []
    skipped = []
    resource_denieds = []
    if findleaks:
        try:
            if test_support.is_jython:
                raise ImportError()
            import gc
        except ImportError:
            print 'No GC available, disabling findleaks.'
            findleaks = False
        else:
            found_garbage = []
    if single:
        from tempfile import gettempdir
        filename = os.path.join(gettempdir(), 'pynexttest')
        try:
            fp = open(filename, 'r')
            next = fp.read().strip()
            tests = [next]
            fp.close()
        except IOError:
            pass
    if fromfile:
        tests = []
        fp = open(fromfile)
        for line in fp:
            guts = line.split()
            if (guts and (not guts[0].startswith('#'))):
                tests.extend(guts)
        fp.close()
    if args:
        args = map(removepy, args)
        allran = False
    if tests:
        tests = map(removepy, tests)
    stdtests = STDTESTS[:]
    nottests = NOTTESTS[:]
    if exclude:
        for arg in args:
            if (arg in stdtests):
                stdtests.remove(arg)
        nottests[:0] = args
        args = []
    tests = (tests or args or findtests(testdir, stdtests, nottests))
    if single:
        tests = tests[:1]
    if randomize:
        random.shuffle(tests)
    if trace:
        import trace
        tracer = trace.Trace(ignoredirs=[sys.prefix, sys.exec_prefix], trace=False, count=True)
    test_support.verbose = verbose
    test_support.use_resources = use_resources
    test_support.junit_xml_dir = junit_xml
    save_modules = sys.modules.keys()
    skips = _ExpectedSkips()
    failures = _ExpectedFailures()
    for test in tests:
        if (expected and ((test in skips) or (test in failures))):
            continue
        if (not quiet):
            print test
            sys.stdout.flush()
        if trace:
            tracer.runctx('runtest(test, generate, verbose, quiet, testdir)', globals=globals(), locals=vars())
        else:
            try:
                ok = runtest(test, generate, verbose, quiet, testdir, huntrleaks, junit_xml)
            except KeyboardInterrupt:
                print 
                break
            except:
                raise
            if (ok > 0):
                good.append(test)
            elif (ok == 0):
                bad.append(test)
            else:
                skipped.append(test)
                if (ok == (-2)):
                    resource_denieds.append(test)
        if findleaks:
            gc.collect()
            if gc.garbage:
                print 'Warning: test created', len(gc.garbage),
                print 'uncollectable object(s).'
                found_garbage.extend(gc.garbage)
                del gc.garbage[:]
        for module in sys.modules.keys():
            if ((module not in save_modules) and module.startswith('test.')):
                test_support.unload(module)
                module = module[5:]
                if hasattr(_test, module):
                    delattr(_test, module)
    good.sort()
    bad.sort()
    skipped.sort()
    if (good and (not quiet)):
        if ((not bad) and (not skipped) and (len(good) > 1)):
            print 'All',
        print count(len(good), 'test'), 'OK.'
        if verbose:
            print "CAUTION:  stdout isn't compared in verbose mode:"
            print 'a test that passes in verbose mode may fail without it.'
    surprises = 0
    if (skipped and (not quiet)):
        print count(len(skipped), 'test'), 'skipped:'
        surprises += countsurprises(skips, skipped, 'skip', 'ran', allran, resource_denieds)
    if bad:
        print count(len(bad), 'test'), 'failed:'
        surprises += countsurprises(failures, bad, 'fail', 'passed', allran, resource_denieds)
    if (verbose2 and bad):
        print 'Re-running failed tests in verbose mode'
        for test in bad:
            print ('Re-running test %r in verbose mode' % test)
            sys.stdout.flush()
            try:
                test_support.verbose = 1
                ok = runtest(test, generate, 1, quiet, testdir, huntrleaks)
            except KeyboardInterrupt:
                print 
                break
            except:
                raise
    if single:
        alltests = findtests(testdir, stdtests, nottests)
        for i in range(len(alltests)):
            if (tests[0] == alltests[i]):
                if (i == (len(alltests) - 1)):
                    os.unlink(filename)
                else:
                    fp = open(filename, 'w')
                    fp.write((alltests[(i + 1)] + '\n'))
                    fp.close()
                break
        else:
            os.unlink(filename)
    if trace:
        r = tracer.results()
        r.write_results(show_missing=True, summary=True, coverdir=coverdir)
    if runleaks:
        os.system(('leaks %d' % os.getpid()))
    if memo:
        savememo(memo, good, bad, skipped)
    sys.exit((surprises > 0))
