'Random variable generators.\n\n    integers\n    --------\n           uniform within range\n\n    sequences\n    ---------\n           pick random element\n           generate random permutation\n\n    distributions on the real line:\n    ------------------------------\n           uniform\n           normal (Gaussian)\n           lognormal\n           negative exponential\n           gamma\n           beta\n\n    distributions on the circle (angles 0 to 2pi)\n    ---------------------------------------------\n           circular uniform\n           von Mises\n\nTranslated from anonymously contributed C/C++ source.\n\nMulti-threading note:  the random number generator used here is not thread-\nsafe; it is possible that two calls return the same random value.  However,\nyou can instantiate a different instance of Random() in each thread to get\ngenerators that don\'t share state, then use .setstate() and .jumpahead() to\nmove the generators to disjoint segments of the full period.  For example,\n\ndef create_generators(num, delta, firstseed=None):\n    """Return list of num distinct generators.\n    Each generator has its own unique segment of delta elements from\n    Random.random()\'s full period.\n    Seed the first generator with optional arg firstseed (default is\n    None, to seed from current time).\n    """\n\n    from random import Random\n    g = Random(firstseed)\n    result = [g]\n    for i in range(num - 1):\n        laststate = g.getstate()\n        g = Random()\n        g.setstate(laststate)\n        g.jumpahead(delta)\n        result.append(g)\n    return result\n\ngens = create_generators(10, 1000000)\n\nThat creates 10 distinct generators, which can be passed out to 10 distinct\nthreads.  The generators don\'t share state so can be called safely in\nparallel.  So long as no thread calls its g.random() more than a million\ntimes (the second argument to create_generators), the sequences seen by\neach thread will not overlap.\n\nThe period of the underlying Wichmann-Hill generator is 6,953,607,871,644,\nand that limits how far this technique can be pushed.\n\nJust for fun, note that since we know the period, .jumpahead() can also be\nused to "move backward in time":\n\n>>> g = Random(42)  # arbitrary\n>>> g.random()\n0.25420336316883324\n>>> g.jumpahead(6953607871644L - 1) # move *back* one\n>>> g.random()\n0.25420336316883324\n'
from math import log as _log, exp as _exp, pi as _pi, e as _e
from math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin
from math import floor as _floor
__all__ = ['Random', 'seed', 'random', 'uniform', 'randint', 'choice', 'randrange', 'shuffle', 'normalvariate', 'lognormvariate', 'cunifvariate', 'expovariate', 'vonmisesvariate', 'gammavariate', 'stdgamma', 'gauss', 'betavariate', 'paretovariate', 'weibullvariate', 'getstate', 'setstate', 'jumpahead', 'whseed']
NV_MAGICCONST = ((4 * _exp((-0.5))) / _sqrt(2.0))
_verify('NV_MAGICCONST', NV_MAGICCONST, 1.71552776992141)
TWOPI = (2.0 * _pi)
_verify('TWOPI', TWOPI, 6.28318530718)
LOG4 = _log(4.0)
_verify('LOG4', LOG4, 1.38629436111989)
SG_MAGICCONST = (1.0 + _log(4.5))
_verify('SG_MAGICCONST', SG_MAGICCONST, 2.50407739677627)
del _verify
_inst = Random()
seed = _inst.seed
random = _inst.random
uniform = _inst.uniform
randint = _inst.randint
choice = _inst.choice
randrange = _inst.randrange
shuffle = _inst.shuffle
normalvariate = _inst.normalvariate
lognormvariate = _inst.lognormvariate
cunifvariate = _inst.cunifvariate
expovariate = _inst.expovariate
vonmisesvariate = _inst.vonmisesvariate
gammavariate = _inst.gammavariate
stdgamma = _inst.stdgamma
gauss = _inst.gauss
betavariate = _inst.betavariate
paretovariate = _inst.paretovariate
weibullvariate = _inst.weibullvariate
getstate = _inst.getstate
setstate = _inst.setstate
jumpahead = _inst.jumpahead
whseed = _inst.whseed
if (__name__ == '__main__'):
    _test()
