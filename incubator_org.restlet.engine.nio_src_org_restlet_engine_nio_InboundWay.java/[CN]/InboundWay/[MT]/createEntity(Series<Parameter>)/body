{
  Representation result=null;
  long contentLength=HeaderUtils.getContentLength(headers);
  boolean chunkedEncoding=HeaderUtils.isChunkedEncoding(headers);
  boolean connectionClosed=HeaderUtils.isConnectionClose(headers);
  if ((contentLength != Representation.UNKNOWN_SIZE && contentLength != 0) || chunkedEncoding || connectionClosed) {
    InputStream inboundEntityStream=getEntityStream(contentLength,chunkedEncoding);
    ReadableByteChannel inboundEntityChannel=getEntityChannel(contentLength,chunkedEncoding);
    if (inboundEntityStream != null) {
      result=new InputRepresentation(inboundEntityStream,null,contentLength){
        @Override public String getText() throws IOException {
          try {
            return super.getText();
          }
 catch (          IOException ioe) {
            throw ioe;
          }
 finally {
            release();
          }
        }
        @Override public void release(){
          super.release();
          onCompleted(getMessage());
        }
      }
;
    }
 else     if (inboundEntityChannel != null) {
      result=new ReadableRepresentation(inboundEntityChannel,null,contentLength){
        @Override public void release(){
          super.release();
          onCompleted(getMessage());
        }
      }
;
    }
    result.setSize(contentLength);
  }
 else {
    result=new EmptyRepresentation();
    onCompleted(getMessage());
  }
  if (headers != null) {
    try {
      result=HeaderUtils.copyResponseEntityHeaders(headers,result);
    }
 catch (    Throwable t) {
      getLogger().log(Level.WARNING,"Error while parsing entity headers",t);
    }
  }
  return result;
}
