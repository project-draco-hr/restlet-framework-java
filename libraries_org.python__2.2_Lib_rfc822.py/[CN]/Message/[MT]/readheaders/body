def readheaders(self):
    'Read header lines.\n\n        Read header lines up to the entirely blank line that terminates them.\n        The (normally blank) line that ends the headers is skipped, but not\n        included in the returned list.  If a non-header line ends the headers,\n        (which is an error), an attempt is made to backspace over it; it is\n        never included in the returned list.\n\n        The variable self.status is set to the empty string if all went well,\n        otherwise it is an error message.  The variable self.headers is a\n        completely uninterpreted list of lines contained in the header (so\n        printing them will reproduce the header exactly as it appears in the\n        file).\n        '
    self.dict = {}
    self.unixfrom = ''
    self.headers = list = []
    self.status = ''
    headerseen = ''
    firstline = 1
    startofline = unread = tell = None
    if hasattr(self.fp, 'unread'):
        unread = self.fp.unread
    elif self.seekable:
        tell = self.fp.tell
    while 1:
        if tell:
            try:
                startofline = tell()
            except IOError:
                startofline = tell = None
                self.seekable = 0
        line = self.fp.readline()
        if (not line):
            self.status = 'EOF in headers'
            break
        if (firstline and line.startswith('From ')):
            self.unixfrom = (self.unixfrom + line)
            continue
        firstline = 0
        if (headerseen and (line[0] in ' \t')):
            list.append(line)
            x = ((self.dict[headerseen] + '\n ') + line.strip())
            self.dict[headerseen] = x.strip()
            continue
        elif self.iscomment(line):
            continue
        elif self.islast(line):
            break
        headerseen = self.isheader(line)
        if headerseen:
            list.append(line)
            self.dict[headerseen] = line[(len(headerseen) + 1):].strip()
            continue
        else:
            if (not self.dict):
                self.status = 'No headers'
            else:
                self.status = 'Non-header line where header expected'
            if unread:
                unread(line)
            elif tell:
                self.fp.seek(startofline)
            else:
                self.status = (self.status + '; bad seek')
            break
