'Module doctest -- a framework for running examples in docstrings.\n\nNORMAL USAGE\n\nIn normal use, end each module M with:\n\ndef _test():\n    import doctest, M           # replace M with your module\'s name\n    return doctest.testmod(M)   # ditto\n\nif __name__ == "__main__":\n    _test()\n\nThen running the module as a script will cause the examples in the\ndocstrings to get executed and verified:\n\npython M.py\n\nThis won\'t display anything unless an example fails, in which case the\nfailing example(s) and the cause(s) of the failure(s) are printed to stdout\n(why not stderr? because stderr is a lame hack <0.2 wink>), and the final\nline of output is "Test failed.".\n\nRun it with the -v switch instead:\n\npython M.py -v\n\nand a detailed report of all examples tried is printed to stdout, along\nwith assorted summaries at the end.\n\nYou can force verbose mode by passing "verbose=1" to testmod, or prohibit\nit by passing "verbose=0".  In either of those cases, sys.argv is not\nexamined by testmod.\n\nIn any case, testmod returns a 2-tuple of ints (f, t), where f is the\nnumber of docstring examples that failed and t is the total number of\ndocstring examples attempted.\n\n\nWHICH DOCSTRINGS ARE EXAMINED?\n\n+ M.__doc__.\n\n+ f.__doc__ for all functions f in M.__dict__.values(), except those\n  with private names and those defined in other modules.\n\n+ C.__doc__ for all classes C in M.__dict__.values(), except those with\n  private names and those defined in other modules.\n\n+ If M.__test__ exists and "is true", it must be a dict, and\n  each entry maps a (string) name to a function object, class object, or\n  string.  Function and class object docstrings found from M.__test__\n  are searched even if the name is private, and strings are searched\n  directly as if they were docstrings.  In output, a key K in M.__test__\n  appears with name\n      <name of M>.__test__.K\n\nAny classes found are recursively searched similarly, to test docstrings in\ntheir contained methods and nested classes.  Private names reached from M\'s\nglobals are skipped, but all names reached from M.__test__ are searched.\n\nBy default, a name is considered to be private if it begins with an\nunderscore (like "_my_func") but doesn\'t both begin and end with (at least)\ntwo underscores (like "__init__").  You can change the default by passing\nyour own "isprivate" function to testmod.\n\nIf you want to test docstrings in objects with private names too, stuff\nthem into an M.__test__ dict, or see ADVANCED USAGE below (e.g., pass your\nown isprivate function to Tester\'s constructor, or call the rundoc method\nof a Tester instance).\n\nWHAT\'S THE EXECUTION CONTEXT?\n\nBy default, each time testmod finds a docstring to test, it uses a *copy*\nof M\'s globals (so that running tests on a module doesn\'t change the\nmodule\'s real globals, and so that one test in M can\'t leave behind crumbs\nthat accidentally allow another test to work).  This means examples can\nfreely use any names defined at top-level in M.  It also means that sloppy\nimports (see above) can cause examples in external docstrings to use\nglobals inappropriate for them.\n\nYou can force use of your own dict as the execution context by passing\n"globs=your_dict" to testmod instead.  Presumably this would be a copy of\nM.__dict__ merged with the globals from other imported modules.\n\n\nWHAT IF I WANT TO TEST A WHOLE PACKAGE?\n\nPiece o\' cake, provided the modules do their testing from docstrings.\nHere\'s the test.py I use for the world\'s most elaborate Rational/\nfloating-base-conversion pkg (which I\'ll distribute some day):\n\nfrom Rational import Cvt\nfrom Rational import Format\nfrom Rational import machprec\nfrom Rational import Rat\nfrom Rational import Round\nfrom Rational import utils\n\nmodules = (Cvt,\n           Format,\n           machprec,\n           Rat,\n           Round,\n           utils)\n\ndef _test():\n    import doctest\n    import sys\n    verbose = "-v" in sys.argv\n    for mod in modules:\n        doctest.testmod(mod, verbose=verbose, report=0)\n    doctest.master.summarize()\n\nif __name__ == "__main__":\n    _test()\n\nIOW, it just runs testmod on all the pkg modules.  testmod remembers the\nnames and outcomes (# of failures, # of tries) for each item it\'s seen, and\npassing "report=0" prevents it from printing a summary in verbose mode.\nInstead, the summary is delayed until all modules have been tested, and\nthen "doctest.master.summarize()" forces the summary at the end.\n\nSo this is very nice in practice:  each module can be tested individually\nwith almost no work beyond writing up docstring examples, and collections\nof modules can be tested too as a unit with no more work than the above.\n\n\nWHAT ABOUT EXCEPTIONS?\n\nNo problem, as long as the only output generated by the example is the\ntraceback itself.  For example:\n\n    >>> [1, 2, 3].remove(42)\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in ?\n    ValueError: list.remove(x): x not in list\n    >>>\n\nNote that only the exception type and value are compared (specifically,\nonly the last line in the traceback).\n\n\nADVANCED USAGE\n\ndoctest.testmod() captures the testing policy I find most useful most\noften.  You may want other policies.\n\ntestmod() actually creates a local instance of class doctest.Tester, runs\nappropriate methods of that class, and merges the results into global\nTester instance doctest.master.\n\nYou can create your own instances of doctest.Tester, and so build your own\npolicies, or even run methods of doctest.master directly.  See\ndoctest.Tester.__doc__ for details.\n\n\nSO WHAT DOES A DOCSTRING EXAMPLE LOOK LIKE ALREADY!?\n\nOh ya.  It\'s easy!  In most cases a copy-and-paste of an interactive\nconsole session works fine -- just make sure the leading whitespace is\nrigidly consistent (you can mix tabs and spaces if you\'re too lazy to do it\nright, but doctest is not in the business of guessing what you think a tab\nmeans).\n\n    >>> # comments are ignored\n    >>> x = 12\n    >>> x\n    12\n    >>> if x == 13:\n    ...     print "yes"\n    ... else:\n    ...     print "no"\n    ...     print "NO"\n    ...     print "NO!!!"\n    ...\n    no\n    NO\n    NO!!!\n    >>>\n\nAny expected output must immediately follow the final ">>>" or "..." line\ncontaining the code, and the expected output (if any) extends to the next\n">>>" or all-whitespace line.  That\'s it.\n\nBummers:\n\n+ Expected output cannot contain an all-whitespace line, since such a line\n  is taken to signal the end of expected output.\n\n+ Output to stdout is captured, but not output to stderr (exception\n  tracebacks are captured via a different means).\n\n+ If you continue a line via backslashing in an interactive session, or for\n  any other reason use a backslash, you need to double the backslash in the\n  docstring version.  This is simply because you\'re in a string, and so the\n  backslash must be escaped for it to survive intact.  Like:\n\n>>> if "yes" == \\\n...     "y" +   \\\n...     "es":   # in the source code you\'ll see the doubled backslashes\n...     print \'yes\'\nyes\n\nThe starting column doesn\'t matter:\n\n>>> assert "Easy!"\n     >>> import math\n            >>> math.floor(1.9)\n            1.0\n\nand as many leading whitespace characters are stripped from the expected\noutput as appeared in the initial ">>>" line that triggered it.\n\nIf you execute this very file, the examples above will be found and\nexecuted, leading to this output in verbose mode:\n\nRunning doctest.__doc__\nTrying: [1, 2, 3].remove(42)\nExpecting:\nTraceback (most recent call last):\n  File "<stdin>", line 1, in ?\nValueError: list.remove(x): x not in list\nok\nTrying: x = 12\nExpecting: nothing\nok\nTrying: x\nExpecting: 12\nok\nTrying:\nif x == 13:\n    print "yes"\nelse:\n    print "no"\n    print "NO"\n    print "NO!!!"\nExpecting:\nno\nNO\nNO!!!\nok\n... and a bunch more like that, with this summary at the end:\n\n5 items had no tests:\n    doctest.Tester.__init__\n    doctest.Tester.run__test__\n    doctest.Tester.summarize\n    doctest.run_docstring_examples\n    doctest.testmod\n12 items passed all tests:\n   8 tests in doctest\n   6 tests in doctest.Tester\n  10 tests in doctest.Tester.merge\n  14 tests in doctest.Tester.rundict\n   3 tests in doctest.Tester.rundoc\n   3 tests in doctest.Tester.runstring\n   2 tests in doctest.__test__._TestClass\n   2 tests in doctest.__test__._TestClass.__init__\n   2 tests in doctest.__test__._TestClass.get\n   1 tests in doctest.__test__._TestClass.square\n   2 tests in doctest.__test__.string\n   7 tests in doctest.is_private\n60 tests in 17 items.\n60 passed and 0 failed.\nTest passed.\n'
__all__ = ['testmod', 'run_docstring_examples', 'is_private', 'Tester']
import __future__
import re
PS1 = '>>>'
PS2 = '...'
_isPS1 = re.compile(('(\\s*)' + re.escape(PS1))).match
_isPS2 = re.compile(('(\\s*)' + re.escape(PS2))).match
_isEmpty = re.compile('\\s*$').match
_isComment = re.compile('\\s*#').match
del re
from types import StringTypes as _StringTypes
from inspect import isclass as _isclass
from inspect import isfunction as _isfunction
from inspect import ismodule as _ismodule
from inspect import classify_class_attrs as _classify_class_attrs
master = None
__test__ = {'_TestClass': _TestClass, 'string': '\n                      Example of a string object, searched as-is.\n                      >>> x = 1; y = 2\n                      >>> x + y, x * y\n                      (3, 2)\n                      ', }
if (__name__ == '__main__'):
    _test()
