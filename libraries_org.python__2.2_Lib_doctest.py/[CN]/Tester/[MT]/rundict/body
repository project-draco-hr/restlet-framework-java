def rundict(self, d, name, module=None):
    '\n        d, name, module=None -> search for docstring examples in d.values().\n\n        For k, v in d.items() such that v is a function or class,\n        do self.rundoc(v, name + "." + k).  Whether this includes\n        objects with private names depends on the constructor\'s\n        "isprivate" argument.  If module is specified, functions and\n        classes that are not defined in module are excluded.\n        Return aggregate (#failures, #examples).\n\n        Build and populate two modules with sample functions to test that\n        exclusion of external functions and classes works.\n\n        >>> import new\n        >>> m1 = new.module(\'_m1\')\n        >>> m2 = new.module(\'_m2\')\n        >>> test_data = """\n        ... def _f():\n        ...     \'\'\'>>> assert 1 == 1\n        ...     \'\'\'\n        ... def g():\n        ...    \'\'\'>>> assert 2 != 1\n        ...    \'\'\'\n        ... class H:\n        ...    \'\'\'>>> assert 2 > 1\n        ...    \'\'\'\n        ...    def bar(self):\n        ...        \'\'\'>>> assert 1 < 2\n        ...        \'\'\'\n        ... """\n        >>> exec test_data in m1.__dict__\n        >>> exec test_data in m2.__dict__\n        >>> m1.__dict__.update({"f2": m2._f, "g2": m2.g, "h2": m2.H})\n\n        Tests that objects outside m1 are excluded:\n\n        >>> t = Tester(globs={}, verbose=0)\n        >>> t.rundict(m1.__dict__, "rundict_test", m1)  # _f, f2 and g2 and h2 skipped\n        (0, 3)\n\n        Again, but with a custom isprivate function allowing _f:\n\n        >>> t = Tester(globs={}, verbose=0, isprivate=lambda x,y: 0)\n        >>> t.rundict(m1.__dict__, "rundict_test_pvt", m1)  # Only f2, g2 and h2 skipped\n        (0, 4)\n\n        And once more, not excluding stuff outside m1:\n\n        >>> t = Tester(globs={}, verbose=0, isprivate=lambda x,y: 0)\n        >>> t.rundict(m1.__dict__, "rundict_test_pvt")  # None are skipped.\n        (0, 8)\n\n        The exclusion of objects from outside the designated module is\n        meant to be invoked automagically by testmod.\n\n        >>> testmod(m1)\n        (0, 3)\n\n        '
    if (not hasattr(d, 'items')):
        raise TypeError(('Tester.rundict: d must support .items(); ' + `d`))
    f = t = 0
    names = d.keys()
    names.sort()
    for thisname in names:
        value = d[thisname]
        if (_isfunction(value) or _isclass(value)):
            if (module and (not _from_module(module, value))):
                continue
            (f2, t2) = self.__runone(value, ((name + '.') + thisname))
            f = (f + f2)
            t = (t + t2)
    return (f, t)
