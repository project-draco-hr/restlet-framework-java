'Generic socket server classes.\n\nThis module tries to capture the various aspects of defining a server:\n\nFor socket-based servers:\n\n- address family:\n        - AF_INET{,6}: IP (Internet Protocol) sockets (default)\n        - AF_UNIX: Unix domain sockets\n        - others, e.g. AF_DECNET are conceivable (see <socket.h>\n- socket type:\n        - SOCK_STREAM (reliable stream, e.g. TCP)\n        - SOCK_DGRAM (datagrams, e.g. UDP)\n\nFor request-based servers (including socket-based):\n\n- client address verification before further looking at the request\n        (This is actually a hook for any processing that needs to look\n         at the request before anything else, e.g. logging)\n- how to handle multiple requests:\n        - synchronous (one request is handled at a time)\n        - forking (each request is handled by a new process)\n        - threading (each request is handled by a new thread)\n\nThe classes in this module favor the server type that is simplest to\nwrite: a synchronous TCP/IP server.  This is bad class design, but\nsave some typing.  (There\'s also the issue that a deep class hierarchy\nslows down method lookups.)\n\nThere are five classes in an inheritance diagram, four of which represent\nsynchronous servers of four types:\n\n        +------------+\n        | BaseServer |\n        +------------+\n              |\n              v\n        +-----------+        +------------------+\n        | TCPServer |------->| UnixStreamServer |\n        +-----------+        +------------------+\n              |\n              v\n        +-----------+        +--------------------+\n        | UDPServer |------->| UnixDatagramServer |\n        +-----------+        +--------------------+\n\nNote that UnixDatagramServer derives from UDPServer, not from\nUnixStreamServer -- the only difference between an IP and a Unix\nstream server is the address family, which is simply repeated in both\nunix server classes.\n\nForking and threading versions of each type of server can be created\nusing the ForkingServer and ThreadingServer mix-in classes.  For\ninstance, a threading UDP server class is created as follows:\n\n        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass\n\nThe Mix-in class must come first, since it overrides a method defined\nin UDPServer!\n\nTo implement a service, you must derive a class from\nBaseRequestHandler and redefine its handle() method.  You can then run\nvarious versions of the service by combining one of the server classes\nwith your request handler class.\n\nThe request handler class must be different for datagram or stream\nservices.  This can be hidden by using the mix-in request handler\nclasses StreamRequestHandler or DatagramRequestHandler.\n\nOf course, you still have to use your head!\n\nFor instance, it makes no sense to use a forking server if the service\ncontains state in memory that can be modified by requests (since the\nmodifications in the child process would never reach the initial state\nkept in the parent process and passed to each child).  In this case,\nyou can use a threading server, but you will probably have to use\nlocks to avoid two requests that come in nearly simultaneous to apply\nconflicting changes to the server state.\n\nOn the other hand, if you are building e.g. an HTTP server, where all\ndata is stored externally (e.g. in the file system), a synchronous\nclass will essentially render the service "deaf" while one request is\nbeing handled -- which may be for a very long time if a client is slow\nto reqd all the data it has requested.  Here a threading or forking\nserver is appropriate.\n\nIn some cases, it may be appropriate to process part of a request\nsynchronously, but to finish processing in a forked child depending on\nthe request data.  This can be implemented by using a synchronous\nserver and doing an explicit fork in the request handler class\nhandle() method.\n\nAnother approach to handling multiple simultaneous requests in an\nenvironment that supports neither threads nor fork (or where these are\ntoo expensive or inappropriate for the service) is to maintain an\nexplicit table of partially finished requests and to use select() to\ndecide which request to work on next (or whether to handle a new\nincoming request).  This is particularly important for stream services\nwhere each client can potentially be connected for a long time (if\nthreads or subprocesses cannot be used).\n\nFuture work:\n- Standard classes for Sun RPC (which uses either UDP or TCP)\n- Standard mix-in classes to implement various authentication\n  and encryption schemes\n- Standard framework for select-based multiplexing\n\nXXX Open problems:\n- What to do with out-of-band data?\n\nBaseServer:\n- split generic "request" functionality out into BaseServer class.\n  Copyright (C) 2000  Luke Kenneth Casson Leighton <lkcl@samba.org>\n\n  example: read entries from a SQL database (requires overriding\n  get_request() to return a table entry from the database).\n  entry is processed by a RequestHandlerClass.\n\n'
__version__ = '0.4'
import socket
import sys
import os
__all__ = ['TCPServer', 'UDPServer', 'ForkingUDPServer', 'ForkingTCPServer', 'ThreadingUDPServer', 'ThreadingTCPServer', 'BaseRequestHandler', 'StreamRequestHandler', 'DatagramRequestHandler', 'ThreadingMixIn', 'ForkingMixIn']
if hasattr(socket, 'AF_UNIX'):
    __all__.extend(['UnixStreamServer', 'UnixDatagramServer', 'ThreadingUnixStreamServer', 'ThreadingUnixDatagramServer'])
if hasattr(socket, 'AF_UNIX'):


    class UnixStreamServer(TCPServer):
        address_family = socket.AF_UNIX


    class UnixDatagramServer(UDPServer):
        address_family = socket.AF_UNIX


    class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer):
        pass


    class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer):
        pass
