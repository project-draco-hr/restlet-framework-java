"Doctest for method/function calls.\n\nWe're going the use these types for extra testing\n\n    >>> from UserList import UserList\n    >>> from UserDict import UserDict\n\nWe're defining four helper functions\n\n    >>> def e(a,b):\n    ...     print a, b\n\n    >>> def f(*a, **k):\n    ...     print a, test_support.sortdict(k)\n\n    >>> def g(x, *y, **z):\n    ...     print x, y, test_support.sortdict(z)\n\n    >>> def h(j=1, a=2, h=3):\n    ...     print j, a, h\n\nArgument list examples\n\n    >>> f()\n    () {}\n    >>> f(1)\n    (1,) {}\n    >>> f(1, 2)\n    (1, 2) {}\n    >>> f(1, 2, 3)\n    (1, 2, 3) {}\n    >>> f(1, 2, 3, *(4, 5))\n    (1, 2, 3, 4, 5) {}\n    >>> f(1, 2, 3, *[4, 5])\n    (1, 2, 3, 4, 5) {}\n    >>> f(1, 2, 3, *UserList([4, 5]))\n    (1, 2, 3, 4, 5) {}\n\nHere we add keyword arguments\n\n    >>> f(1, 2, 3, **{'a':4, 'b':5})\n    (1, 2, 3) {'a': 4, 'b': 5}\n    >>> f(1, 2, 3, *[4, 5], **{'a':6, 'b':7})\n    (1, 2, 3, 4, 5) {'a': 6, 'b': 7}\n    >>> f(1, 2, 3, x=4, y=5, *(6, 7), **{'a':8, 'b': 9})\n    (1, 2, 3, 6, 7) {'a': 8, 'b': 9, 'x': 4, 'y': 5}\n\n    >>> f(1, 2, 3, **UserDict(a=4, b=5))\n    (1, 2, 3) {'a': 4, 'b': 5}\n    >>> f(1, 2, 3, *(4, 5), **UserDict(a=6, b=7))\n    (1, 2, 3, 4, 5) {'a': 6, 'b': 7}\n    >>> f(1, 2, 3, x=4, y=5, *(6, 7), **UserDict(a=8, b=9))\n    (1, 2, 3, 6, 7) {'a': 8, 'b': 9, 'x': 4, 'y': 5}\n\nExamples with invalid arguments (TypeErrors). We're also testing the function\nnames in the exception messages.\n\nVerify clearing of SF bug #733667\n\n    >>> e(c=4)\n    Traceback (most recent call last):\n      ...\n    TypeError: e() got an unexpected keyword argument 'c'\n\n    >>> g()\n    Traceback (most recent call last):\n      ...\n    TypeError: g() takes at least 1 argument (0 given)\n\n    >>> g(*())\n    Traceback (most recent call last):\n      ...\n    TypeError: g() takes at least 1 argument (0 given)\n\n    >>> g(*(), **{})\n    Traceback (most recent call last):\n      ...\n    TypeError: g() takes at least 1 argument (0 given)\n\n    >>> g(1)\n    1 () {}\n    >>> g(1, 2)\n    1 (2,) {}\n    >>> g(1, 2, 3)\n    1 (2, 3) {}\n    >>> g(1, 2, 3, *(4, 5))\n    1 (2, 3, 4, 5) {}\n\n    >>> class Nothing: pass\n    ...\n    >>> g(*Nothing())\n    Traceback (most recent call last):\n      ...\n    TypeError: g() argument after * must be a sequence\n\n    >>> class Nothing:\n    ...     def __len__(self): return 5\n    ...\n\n    >>> g(*Nothing())\n    Traceback (most recent call last):\n      ...\n    TypeError: g() argument after * must be a sequence\n\n    >>> class Nothing:\n    ...     def __len__(self): return 5\n    ...     def __getitem__(self, i):\n    ...         if i<3: return i\n    ...         else: raise IndexError(i)\n    ...\n\n    >>> g(*Nothing())\n    0 (1, 2) {}\n\n    >>> class Nothing:\n    ...     def __init__(self): self.c = 0\n    ...     def __iter__(self): return self\n    ...     def next(self):\n    ...         if self.c == 4:\n    ...             raise StopIteration\n    ...         c = self.c\n    ...         self.c += 1\n    ...         return c\n    ...\n\n    >>> g(*Nothing())\n    0 (1, 2, 3) {}\n\nMake sure that the function doesn't stomp the dictionary\n\n    >>> d = {'a': 1, 'b': 2, 'c': 3}\n    >>> d2 = d.copy()\n    >>> g(1, d=4, **d)\n    1 () {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n    >>> d == d2\n    True\n\nWhat about willful misconduct?\n\n    >>> def saboteur(**kw):\n    ...     kw['x'] = 'm'\n    ...     return kw\n\n    >>> d = {}\n    >>> kw = saboteur(a=1, **d)\n    >>> d\n    {}\n\n\n    >>> g(1, 2, 3, **{'x': 4, 'y': 5})\n    Traceback (most recent call last):\n      ...\n    TypeError: g() got multiple values for keyword argument 'x'\n\n    >>> f(**{1:2})\n    Traceback (most recent call last):\n      ...\n    TypeError: f() keywords must be strings\n\n    >>> h(**{'e': 2})\n    Traceback (most recent call last):\n      ...\n    TypeError: h() got an unexpected keyword argument 'e'\n\n    >>> h(*h)\n    Traceback (most recent call last):\n      ...\n    TypeError: h() argument after * must be a sequence\n\n    >>> dir(*h)\n    Traceback (most recent call last):\n      ...\n    TypeError: dir() argument after * must be a sequence\n\n    >>> None(*h)\n    Traceback (most recent call last):\n      ...\n    TypeError: NoneType argument after * must be a sequence\n\n    >>> h(**h)\n    Traceback (most recent call last):\n      ...\n    TypeError: h() argument after ** must be a mapping\n\n    >>> dir(**h)\n    Traceback (most recent call last):\n      ...\n    TypeError: dir() argument after ** must be a mapping\n\n    >>> None(**h)\n    Traceback (most recent call last):\n      ...\n    TypeError: NoneType argument after ** must be a mapping\n\n    >>> dir(b=1, **{'b': 1})\n    Traceback (most recent call last):\n      ...\n    TypeError: dir() got multiple values for keyword argument 'b'\n\nAnother helper function\n\n    >>> def f2(*a, **b):\n    ...     return a, b\n\n\n    >>> d = {}\n    >>> for i in xrange(512):\n    ...     key = 'k%d' % i\n    ...     d[key] = i\n    >>> a, b = f2(1, *(2,3), **d)\n    >>> len(a), len(b), b == d\n    (3, 512, True)\n\n    >>> class Foo:\n    ...     def method(self, arg1, arg2):\n    ...         return arg1+arg2\n\n    >>> x = Foo()\n    >>> Foo.method(*(x, 1, 2))\n    3\n    >>> Foo.method(x, *(1, 2))\n    3\n    >>> Foo.method(*(1, 2, 3))\n    Traceback (most recent call last):\n      ...\n    TypeError: unbound method method() must be called with Foo instance as first argument (got int instance instead)\n\n    >>> Foo.method(1, *[2, 3])\n    Traceback (most recent call last):\n      ...\n    TypeError: unbound method method() must be called with Foo instance as first argument (got int instance instead)\n\nA PyCFunction that takes only positional parameters shoud allow an\nempty keyword dictionary to pass without a complaint, but raise a\nTypeError if te dictionary is not empty\n\n    >>> try:\n    ...     silence = id(1, *{})\n    ...     True\n    ... except:\n    ...     False\n    True\n\n    >>> id(1, **{'foo': 1})\n    Traceback (most recent call last):\n      ...\n    TypeError: id() takes no keyword arguments\n\n"
from test import test_support
if (__name__ == '__main__'):
    test_main()
