def test_open_truncate(self):
    fp = open(self.filename, 'w')
    fp.write('hello')
    fp.close()
    self.assertEquals(os.path.getsize(self.filename), 5)
    self.fd = os.open(self.filename, (os.O_TRUNC | os.O_RDWR))
    self.assertEquals(os.path.getsize(self.filename), 0)
    os.write(self.fd, 'truncated')
    os.lseek(self.fd, 0, 0)
    self.assertEquals(os.read(self.fd, len('truncated')), 'truncated')
    os.close(self.fd)
    self.fd = os.open(self.filename, (os.O_TRUNC | os.O_WRONLY))
    self.assertEquals(os.path.getsize(self.filename), 0)
    os.write(self.fd, 'write only truncated')
    raises(OSError, 9, os.read, self.fd, 99)
    os.close(self.fd)
    fd = open(self.filename)
    self.assertEquals(fd.read(), 'write only truncated')
    fd.close()
    "\n        # falls back to read only without O_WRONLY/O_RDWR, but truncates\n        self.fd = os.open(self.filename, os.O_TRUNC)\n        self.assertEquals(os.path.getsize(self.filename), 0)\n        raises(OSError, 9, os.write, self.fd, 'new')\n        self.assertEquals(os.read(self.fd, 99), '')\n        os.close(self.fd)\n\n        fp = open(self.filename, 'w')\n        fp.write('and ')\n        fp.close()\n        self.assertEquals(os.path.getsize(self.filename), 4)\n\n        # append with no write falls back to read, but still truncates\n        self.fd = os.open(self.filename, os.O_TRUNC | os.O_APPEND)\n        self.assertEquals(os.path.getsize(self.filename), 0)\n        raises(OSError, 9, os.write, self.fd, 'new')\n        os.close(self.fd)\n\n        fp = open(self.filename, 'w')\n        fp.write('and ')\n        fp.close()\n        self.assertEquals(os.path.getsize(self.filename), 4)\n        "
