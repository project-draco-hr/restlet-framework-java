def compile(file, cfile=None, dfile=None, doraise=False):
    "Byte-compile one Python source file to Python bytecode.\n\n    Arguments:\n\n    file:    source filename\n    cfile:   target filename; defaults to source with 'c' or 'o' appended\n             ('c' normally, 'o' in optimizing mode, giving .pyc or .pyo)\n    dfile:   purported filename; defaults to source (this is the filename\n             that will show up in error messages)\n    doraise: flag indicating whether or not an exception should be\n             raised when a compile error is found. If an exception\n             occurs and this flag is set to False, a string\n             indicating the nature of the exception will be printed,\n             and the function will return to the caller. If an\n             exception occurs and this flag is set to True, a\n             PyCompileError exception will be raised.\n\n    Note that it isn't necessary to byte-compile Python modules for\n    execution efficiency -- Python itself byte-compiles a module when\n    it is loaded, and if it can, writes out the bytecode to the\n    corresponding .pyc (or .pyo) file.\n\n    However, if a Python installation is shared between users, it is a\n    good idea to byte-compile all modules upon installation, since\n    other users may not be able to write in the source directories,\n    and thus they won't be able to write the .pyc/.pyo file, and then\n    they would be byte-compiling every module each time it is loaded.\n    This can slow down program start-up considerably.\n\n    See compileall.py for a script/module that uses this module to\n    byte-compile all installed files (or all files in selected\n    directories).\n\n    "
    try:
        _py_compile.compile(file, cfile, dfile)
    except Exception as err:
        py_exc = PyCompileError(err.__class__, err.args, (dfile or file))
        if doraise:
            raise py_exc
        else:
            sys.stderr.write((py_exc.msg + '\n'))
            return
