def multi():
    if verbose:
        print 'Testing multiple inheritance...'


    class C(object):

        def __init__(self):
            self.__state = 0

        def getstate(self):
            return self.__state

        def setstate(self, state):
            self.__state = state
    a = C()
    vereq(a.getstate(), 0)
    a.setstate(10)
    vereq(a.getstate(), 10)


    class D(dict, C):

        def __init__(self):
            type({}).__init__(self)
            C.__init__(self)
    d = D()
    vereq(d.keys(), [])
    d['hello'] = 'world'
    vereq(d.items(), [('hello', 'world')])
    vereq(d['hello'], 'world')
    vereq(d.getstate(), 0)
    d.setstate(10)
    vereq(d.getstate(), 10)
    vereq(D.__mro__, (D, dict, C, object))


    class Node(object):

        def __int__(self):
            return int(self.foo())

        def foo(self):
            return '23'


    class Frag(Node, list):

        def foo(self):
            return '42'
    vereq(Node().__int__(), 23)
    vereq(int(Node()), 23)
    vereq(Frag().__int__(), 42)
    vereq(int(Frag()), 42)


    class A:
        x = 1


    class B(A):
        pass


    class C(A):
        x = 2


    class D(B, C):
        pass
    vereq(D.x, 1)


    class E(D, object):
        pass
    vereq(E.__mro__, (E, D, B, A, C, object))
    vereq(E.x, 1)


    class F(B, C, object):
        pass
    vereq(F.__mro__, (F, B, C, A, object))
    vereq(F.x, 2)


    class C:

        def cmethod(self):
            return 'C a'

        def all_method(self):
            return 'C b'


    class M1(C, object):

        def m1method(self):
            return 'M1 a'

        def all_method(self):
            return 'M1 b'
    vereq(M1.__mro__, (M1, C, object))
    m = M1()
    vereq(m.cmethod(), 'C a')
    vereq(m.m1method(), 'M1 a')
    vereq(m.all_method(), 'M1 b')


    class D(C):

        def dmethod(self):
            return 'D a'

        def all_method(self):
            return 'D b'


    class M2(D, object):

        def m2method(self):
            return 'M2 a'

        def all_method(self):
            return 'M2 b'
    vereq(M2.__mro__, (M2, D, C, object))
    m = M2()
    vereq(m.cmethod(), 'C a')
    vereq(m.dmethod(), 'D a')
    vereq(m.m2method(), 'M2 a')
    vereq(m.all_method(), 'M2 b')


    class M3(M1, M2, object):

        def m3method(self):
            return 'M3 a'

        def all_method(self):
            return 'M3 b'
    vereq(M3.__mro__, (M3, M1, M2, D, C, object))
    m = M3()
    vereq(m.cmethod(), 'C a')
    vereq(m.dmethod(), 'D a')
    vereq(m.m1method(), 'M1 a')
    vereq(m.m2method(), 'M2 a')
    vereq(m.m3method(), 'M3 a')
    vereq(m.all_method(), 'M3 b')


    class Classic:
        pass
    try:


        class New(Classic):
            __metaclass__ = type
    except TypeError:
        pass
    else:
        raise TestFailed, "new class with only classic bases - shouldn't be"
