{
  Status result=null;
  try {
    final String hostDomain=request.getResourceRef().getHostDomain();
    int hostPort=request.getResourceRef().getHostPort();
    if (hostPort == -1) {
      if (request.getResourceRef().getSchemeProtocol() != null) {
        hostPort=request.getResourceRef().getSchemeProtocol().getDefaultPort();
      }
 else {
        hostPort=getProtocol().getDefaultPort();
      }
    }
    this.socket=createSocket(hostDomain,hostPort);
    this.requestStream=new BufferedOutputStream(this.socket.getOutputStream());
    this.responseStream=new BufferedInputStream(this.socket.getInputStream());
    getRequestHeadStream().write(getMethod().getBytes());
    getRequestHeadStream().write(' ');
    getRequestHeadStream().write(getRequestUri().getBytes());
    getRequestHeadStream().write(' ');
    getRequestHeadStream().write(getVersion().getBytes());
    HttpUtils.writeCRLF(getRequestHeadStream());
    if (shouldRequestBeChunked(request)) {
      getRequestHeaders().set(HttpConstants.HEADER_TRANSFER_ENCODING,"chunked",true);
    }
    getRequestHeaders().set(HttpConstants.HEADER_CONNECTION,"close",isClientKeepAlive());
    String host=hostDomain;
    if (request.getResourceRef().getHostPort() != -1) {
      host+=":" + request.getResourceRef().getHostPort();
    }
    getRequestHeaders().set(HttpConstants.HEADER_HOST,host,true);
    for (    final Parameter header : getRequestHeaders()) {
      HttpUtils.writeHeader(header,getRequestHeadStream());
    }
    HttpUtils.writeCRLF(getRequestHeadStream());
    getRequestHeadStream().flush();
    result=super.sendRequest(request);
    if (result.equals(Status.CONNECTOR_ERROR_COMMUNICATION)) {
      return result;
    }
    parseResponse();
    result=new Status(getStatusCode(),null,getReasonPhrase(),null);
  }
 catch (  final IOException ioe) {
    getHelper().getLogger().log(Level.WARNING,"An error occured during the communication with the remote HTTP server.",ioe);
    result=new Status(Status.CONNECTOR_ERROR_COMMUNICATION,ioe);
  }
  return result;
}
