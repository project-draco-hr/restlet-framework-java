def expect(self, list, timeout=None):
    "Read until one from a list of a regular expressions matches.\n\n        The first argument is a list of regular expressions, either\n        compiled (re.RegexObject instances) or uncompiled (strings).\n        The optional second argument is a timeout, in seconds; default\n        is no timeout.\n\n        Return a tuple of three items: the index in the list of the\n        first regular expression that matches; the match object\n        returned; and the text read up till and including the match.\n\n        If EOF is read and no text was read, raise EOFError.\n        Otherwise, when nothing matches, return (-1, None, text) where\n        text is the text received so far (may be the empty string if a\n        timeout happened).\n\n        If a regular expression ends with a greedy match (e.g. '.*')\n        or if more than one expression can match the same input, the\n        results are undeterministic, and may depend on the I/O timing.\n\n        "
    re = None
    list = list[:]
    indices = range(len(list))
    for i in indices:
        if (not hasattr(list[i], 'search')):
            if (not re):
                import re
            list[i] = re.compile(list[i])
    while 1:
        self.process_rawq()
        for i in indices:
            m = list[i].search(self.cookedq)
            if m:
                e = m.end()
                text = self.cookedq[:e]
                self.cookedq = self.cookedq[e:]
                return (i, m, text)
        if self.eof:
            break
        if (timeout is not None):
            (r, w, x) = select([self.fileno()], [], [], timeout)
            if (not r):
                break
        self.fill_rawq()
    text = self.read_very_lazy()
    if ((not text) and self.eof):
        raise EOFError
    return ((-1), None, text)
