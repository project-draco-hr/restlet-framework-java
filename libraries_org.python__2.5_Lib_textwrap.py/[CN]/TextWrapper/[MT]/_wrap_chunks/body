def _wrap_chunks(self, chunks):
    '_wrap_chunks(chunks : [string]) -> [string]\n\n        Wrap a sequence of text chunks and return a list of lines of\n        length \'self.width\' or less.  (If \'break_long_words\' is false,\n        some lines may be longer than this.)  Chunks correspond roughly\n        to words and the whitespace between them: each chunk is\n        indivisible (modulo \'break_long_words\'), but a line break can\n        come between any two chunks.  Chunks should not have internal\n        whitespace; ie. a chunk is either all whitespace or a "word".\n        Whitespace chunks will be removed from the beginning and end of\n        lines, but apart from that whitespace is preserved.\n        '
    lines = []
    if (self.width <= 0):
        raise ValueError(('invalid width %r (must be > 0)' % self.width))
    chunks.reverse()
    while chunks:
        cur_line = []
        cur_len = 0
        if lines:
            indent = self.subsequent_indent
        else:
            indent = self.initial_indent
        width = (self.width - len(indent))
        if ((chunks[(-1)].strip() == '') and lines):
            del chunks[(-1)]
        while chunks:
            l = len(chunks[(-1)])
            if ((cur_len + l) <= width):
                cur_line.append(chunks.pop())
                cur_len += l
            else:
                break
        if (chunks and (len(chunks[(-1)]) > width)):
            self._handle_long_word(chunks, cur_line, cur_len, width)
        if (cur_line and (cur_line[(-1)].strip() == '')):
            del cur_line[(-1)]
        if cur_line:
            lines.append((indent + ''.join(cur_line)))
    return lines
