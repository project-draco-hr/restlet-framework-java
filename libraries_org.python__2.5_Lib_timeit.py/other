"Tool for measuring execution time of small code snippets.\n\nThis module avoids a number of common traps for measuring execution\ntimes.  See also Tim Peters' introduction to the Algorithms chapter in\nthe Python Cookbook, published by O'Reilly.\n\nLibrary usage: see the Timer class.\n\nCommand line usage:\n    python timeit.py [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement]\n\nOptions:\n  -n/--number N: how many times to execute 'statement' (default: see below)\n  -r/--repeat N: how many times to repeat the timer (default 3)\n  -s/--setup S: statement to be executed once initially (default 'pass')\n  -t/--time: use time.time() (default on Unix)\n  -c/--clock: use time.clock() (default on Windows)\n  -v/--verbose: print raw timing results; repeat for more digits precision\n  -h/--help: print this usage message and exit\n  statement: statement to be timed (default 'pass')\n\nA multi-line statement may be given by specifying each line as a\nseparate argument; indented lines are possible by enclosing an\nargument in quotes and using leading spaces.  Multiple -s options are\ntreated similarly.\n\nIf -n is not given, a suitable number of loops is calculated by trying\nsuccessive powers of 10 until the total time is at least 0.2 seconds.\n\nThe difference in default timer function is because on Windows,\nclock() has microsecond granularity but time()'s granularity is 1/60th\nof a second; on Unix, clock() has 1/100th of a second granularity and\ntime() is much more precise.  On either platform, the default timer\nfunctions measure wall clock time, not the CPU time.  This means that\nother processes running on the same computer may interfere with the\ntiming.  The best thing to do when accurate timing is necessary is to\nrepeat the timing a few times and use the best time.  The -r option is\ngood for this; the default of 3 repetitions is probably enough in most\ncases.  On Unix, you can use clock() to measure CPU time.\n\nNote: there is a certain baseline overhead associated with executing a\npass statement.  The code here doesn't try to hide it, but you should\nbe aware of it.  The baseline overhead can be measured by invoking the\nprogram without arguments.\n\nThe baseline overhead differs between Python versions!  Also, to\nfairly compare older Python versions to Python 2.3, you may want to\nuse python -O for the older versions to avoid timing SET_LINENO\ninstructions.\n"
import gc
import sys
import time
try:
    import itertools
except ImportError:
    itertools = None
__all__ = ['Timer']
dummy_src_name = '<timeit-src>'
default_number = 1000000
default_repeat = 3
if (sys.platform == 'win32'):
    default_timer = time.clock
else:
    default_timer = time.time
template = '\ndef inner(_it, _timer):\n    %(setup)s\n    _t0 = _timer()\n    for _i in _it:\n        %(stmt)s\n    _t1 = _timer()\n    return _t1 - _t0\n'
if (__name__ == '__main__'):
    sys.exit(main())
