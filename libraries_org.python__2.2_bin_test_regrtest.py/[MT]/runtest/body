def runtest(test, generate, verbose, quiet, testdir=None):
    "Run a single test.\n    test -- the name of the test\n    generate -- if true, generate output, instead of running the test\n    and comparing it to a previously created output file\n    verbose -- if true, print more messages\n    quiet -- if true, don't print 'skipped' messages (probably redundant)\n    testdir -- test directory\n    "
    test_support.unload(test)
    if (not testdir):
        testdir = findtestdir()
    outputdir = os.path.join(testdir, 'output')
    outputfile = os.path.join(outputdir, test)
    if verbose:
        cfp = None
    else:
        cfp = StringIO.StringIO()
    try:
        save_stdout = sys.stdout
        try:
            if cfp:
                sys.stdout = cfp
                print test
            the_module = __import__(test, globals(), locals(), [])
            indirect_test = getattr(the_module, 'test_main', None)
            if (indirect_test is not None):
                indirect_test()
        finally:
            sys.stdout = save_stdout
    except (ImportError, test_support.TestSkipped) as msg:
        if (not quiet):
            print test, 'skipped --', msg
            sys.stdout.flush()
        return (-1)
    except KeyboardInterrupt:
        raise
    except test_support.TestFailed as msg:
        print 'test', test, 'failed --', msg
        sys.stdout.flush()
        return 0
    except:
        (type, value) = sys.exc_info()[:2]
        print 'test', test, 'crashed --', (str(type) + ':'), value
        sys.stdout.flush()
        if verbose:
            traceback.print_exc(file=sys.stdout)
            sys.stdout.flush()
        return 0
    else:
        if (not cfp):
            return 1
        output = cfp.getvalue()
        if generate:
            if (output == (test + '\n')):
                if os.path.exists(outputfile):
                    print 'output file', outputfile, 'is no longer needed; consider removing it'
                else:
                    return 1
            fp = open(outputfile, 'w')
            fp.write(output)
            fp.close()
            return 1
        if os.path.exists(outputfile):
            fp = open(outputfile, 'r')
            expected = fp.read()
            fp.close()
        else:
            expected = (test + '\n')
        if (output == expected):
            return 1
        print 'test', test, 'produced unexpected output:'
        sys.stdout.flush()
        reportdiff(expected, output)
        sys.stdout.flush()
        return 0
