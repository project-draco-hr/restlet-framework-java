def header_encode(header, charset='iso-8859-1', keep_eols=False, maxlinelen=76, eol=NL):
    'Encode a single header line with Base64 encoding in a given charset.\n\n    Defined in RFC 2045, this Base64 encoding is identical to normal Base64\n    encoding, except that each line must be intelligently wrapped (respecting\n    the Base64 encoding), and subsequent lines must start with a space.\n\n    charset names the character set to use to encode the header.  It defaults\n    to iso-8859-1.\n\n    End-of-line characters (\\r, \\n, \\r\\n) will be automatically converted\n    to the canonical email line separator \\r\\n unless the keep_eols\n    parameter is True (the default is False).\n\n    Each line of the header will be terminated in the value of eol, which\n    defaults to "\\n".  Set this to "\\r\\n" if you are using the result of\n    this function directly in email.\n\n    The resulting string will be in the form:\n\n    "=?charset?b?WW/5ciBtYXp66XLrIHf8eiBhIGhhbXBzdGHuciBBIFlv+XIgbWF6euly?=\\n\n      =?charset?b?6yB3/HogYSBoYW1wc3Rh7nIgQkMgWW/5ciBtYXp66XLrIHf8eiBhIGhh?="\n\n    with each line wrapped at, at most, maxlinelen characters (defaults to 76\n    characters).\n    '
    if (not header):
        return header
    if (not keep_eols):
        header = fix_eols(header)
    base64ed = []
    max_encoded = ((maxlinelen - len(charset)) - MISC_LEN)
    max_unencoded = _floordiv((max_encoded * 3), 4)
    for i in range(0, len(header), max_unencoded):
        base64ed.append(b2a_base64(header[i:(i + max_unencoded)]))
    lines = []
    for line in base64ed:
        if line.endswith(NL):
            line = line[:(-1)]
        lines.append(('=?%s?b?%s?=' % (charset, line)))
    joiner = (eol + ' ')
    return joiner.join(lines)
