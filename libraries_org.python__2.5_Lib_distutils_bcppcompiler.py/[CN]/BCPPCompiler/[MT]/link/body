def link(self, target_desc, objects, output_filename, output_dir=None, libraries=None, library_dirs=None, runtime_library_dirs=None, export_symbols=None, debug=0, extra_preargs=None, extra_postargs=None, build_temp=None, target_lang=None):
    (objects, output_dir) = self._fix_object_args(objects, output_dir)
    (libraries, library_dirs, runtime_library_dirs) = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
    if runtime_library_dirs:
        log.warn("I don't know what to do with 'runtime_library_dirs': %s", str(runtime_library_dirs))
    if (output_dir is not None):
        output_filename = os.path.join(output_dir, output_filename)
    if self._need_link(objects, output_filename):
        if (target_desc == CCompiler.EXECUTABLE):
            startup_obj = 'c0w32'
            if debug:
                ld_args = self.ldflags_exe_debug[:]
            else:
                ld_args = self.ldflags_exe[:]
        else:
            startup_obj = 'c0d32'
            if debug:
                ld_args = self.ldflags_shared_debug[:]
            else:
                ld_args = self.ldflags_shared[:]
        if (export_symbols is None):
            def_file = ''
        else:
            (head, tail) = os.path.split(output_filename)
            (modname, ext) = os.path.splitext(tail)
            temp_dir = os.path.dirname(objects[0])
            def_file = os.path.join(temp_dir, ('%s.def' % modname))
            contents = ['EXPORTS']
            for sym in (export_symbols or []):
                contents.append(('  %s=_%s' % (sym, sym)))
            self.execute(write_file, (def_file, contents), ('writing %s' % def_file))
        objects2 = map(os.path.normpath, objects)
        objects = [startup_obj]
        resources = []
        for file in objects2:
            (base, ext) = os.path.splitext(os.path.normcase(file))
            if (ext == '.res'):
                resources.append(file)
            else:
                objects.append(file)
        for l in library_dirs:
            ld_args.append(('/L%s' % os.path.normpath(l)))
        ld_args.append('/L.')
        ld_args.extend(objects)
        ld_args.extend([',', output_filename])
        ld_args.append(',,')
        for lib in libraries:
            libfile = self.find_library_file(library_dirs, lib, debug)
            if (libfile is None):
                ld_args.append(lib)
            else:
                ld_args.append(libfile)
        ld_args.append('import32')
        ld_args.append('cw32mt')
        ld_args.extend([',', def_file])
        ld_args.append(',')
        ld_args.extend(resources)
        if extra_preargs:
            ld_args[:0] = extra_preargs
        if extra_postargs:
            ld_args.extend(extra_postargs)
        self.mkpath(os.path.dirname(output_filename))
        try:
            self.spawn(([self.linker] + ld_args))
        except DistutilsExecError as msg:
            raise LinkError, msg
    else:
        log.debug('skipping %s (up-to-date)', output_filename)
