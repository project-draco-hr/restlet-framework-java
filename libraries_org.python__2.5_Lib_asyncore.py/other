'Basic infrastructure for asynchronous socket service clients and servers.\n\nThere are only two ways to have a program on a single processor do "more\nthan one thing at a time".  Multi-threaded programming is the simplest and\nmost popular way to do it, but there is another very different technique,\nthat lets you have nearly all the advantages of multi-threading, without\nactually using multiple threads. it\'s really only practical if your program\nis largely I/O bound. If your program is CPU bound, then pre-emptive\nscheduled threads are probably what you really need. Network servers are\nrarely CPU-bound, however.\n\nIf your operating system supports the select() system call in its I/O\nlibrary (and nearly all do), then you can use it to juggle multiple\ncommunication channels at once; doing other work while your I/O is taking\nplace in the "background."  Although this strategy can seem strange and\ncomplex, especially at first, it is in many ways easier to understand and\ncontrol than multi-threaded programming. The module documented here solves\nmany of the difficult problems for you, making the task of building\nsophisticated high-performance network servers and clients a snap.\n'
import select
import socket
import sys
import time
import os
from errno import EALREADY, EINPROGRESS, EWOULDBLOCK, ECONNRESET, ENOTCONN, ESHUTDOWN, EINTR, EISCONN, errorcode
try:
    socket_map
except NameError:
    socket_map = {}
poll3 = poll2
if (os.name == 'posix'):
    import fcntl


    class file_wrapper:

        def __init__(self, fd):
            self.fd = fd

        def recv(self, *args):
            return os.read(self.fd, *args)

        def send(self, *args):
            return os.write(self.fd, *args)
        read = recv
        write = send

        def close(self):
            os.close(self.fd)

        def fileno(self):
            return self.fd


    class file_dispatcher(dispatcher):

        def __init__(self, fd, map=None):
            dispatcher.__init__(self, None, map)
            self.connected = True
            self.set_file(fd)
            flags = fcntl.fcntl(fd, fcntl.F_GETFL, 0)
            flags = (flags | os.O_NONBLOCK)
            fcntl.fcntl(fd, fcntl.F_SETFL, flags)

        def set_file(self, fd):
            self._fileno = fd
            self.socket = file_wrapper(fd)
            self.add_channel()
