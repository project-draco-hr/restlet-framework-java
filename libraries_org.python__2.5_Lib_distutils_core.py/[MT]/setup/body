def setup(**attrs):
    "The gateway to the Distutils: do everything your setup script needs\n    to do, in a highly flexible and user-driven way.  Briefly: create a\n    Distribution instance; find and parse config files; parse the command\n    line; run each Distutils command found there, customized by the options\n    supplied to 'setup()' (as keyword arguments), in config files, and on\n    the command line.\n\n    The Distribution instance might be an instance of a class supplied via\n    the 'distclass' keyword argument to 'setup'; if no such class is\n    supplied, then the Distribution class (in dist.py) is instantiated.\n    All other arguments to 'setup' (except for 'cmdclass') are used to set\n    attributes of the Distribution instance.\n\n    The 'cmdclass' argument, if supplied, is a dictionary mapping command\n    names to command classes.  Each command encountered on the command line\n    will be turned into a command class, which is in turn instantiated; any\n    class found in 'cmdclass' is used in place of the default, which is\n    (for command 'foo_bar') class 'foo_bar' in module\n    'distutils.command.foo_bar'.  The command class must provide a\n    'user_options' attribute which is a list of option specifiers for\n    'distutils.fancy_getopt'.  Any command-line options between the current\n    and the next command are used to set attributes of the current command\n    object.\n\n    When the entire command-line has been successfully parsed, calls the\n    'run()' method on each command object in turn.  This method will be\n    driven entirely by the Distribution object (which each command object\n    has a reference to, thanks to its constructor), and the\n    command-specific options that became attributes of each command\n    object.\n    "
    global _setup_stop_after, _setup_distribution
    klass = attrs.get('distclass')
    if klass:
        del attrs['distclass']
    else:
        klass = Distribution
    if (not attrs.has_key('script_name')):
        attrs['script_name'] = os.path.basename(sys.argv[0])
    if (not attrs.has_key('script_args')):
        attrs['script_args'] = sys.argv[1:]
    try:
        _setup_distribution = dist = klass(attrs)
    except DistutilsSetupError as msg:
        if attrs.has_key('name'):
            raise SystemExit, ('error in %s setup command: %s' % (attrs['name'], msg))
        else:
            raise SystemExit, ('error in setup command: %s' % msg)
    if (_setup_stop_after == 'init'):
        return dist
    dist.parse_config_files()
    if DEBUG:
        print 'options (after parsing config files):'
        dist.dump_option_dicts()
    if (_setup_stop_after == 'config'):
        return dist
    try:
        ok = dist.parse_command_line()
    except DistutilsArgError as msg:
        raise SystemExit, (gen_usage(dist.script_name) + ('\nerror: %s' % msg))
    if DEBUG:
        print 'options (after parsing command line):'
        dist.dump_option_dicts()
    if (_setup_stop_after == 'commandline'):
        return dist
    if ok:
        try:
            dist.run_commands()
        except KeyboardInterrupt:
            raise SystemExit, 'interrupted'
        except (IOError, os.error) as exc:
            error = grok_environment_error(exc)
            if DEBUG:
                sys.stderr.write((error + '\n'))
                raise
            else:
                raise SystemExit, error
        except (DistutilsError, CCompilerError) as msg:
            if DEBUG:
                raise
            else:
                raise SystemExit, ('error: ' + str(msg))
    return dist
