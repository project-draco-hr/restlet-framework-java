def uu_decode(input, errors='strict'):
    " Decodes the object input and returns a tuple (output\n        object, length consumed).\n\n        input must be an object which provides the bf_getreadbuf\n        buffer slot. Python strings, buffer objects and memory\n        mapped files are examples of objects providing this slot.\n\n        errors defines the error handling to apply. It defaults to\n        'strict' handling which is the only currently supported\n        error handling for this codec.\n\n        Note: filename and file mode information in the input data is\n        ignored.\n\n    "
    assert (errors == 'strict')
    from cStringIO import StringIO
    from binascii import a2b_uu
    infile = StringIO(input)
    outfile = StringIO()
    readline = infile.readline
    write = outfile.write
    while 1:
        s = readline()
        if (not s):
            raise ValueError, 'Missing "begin" line in input data'
        if (s[:5] == 'begin'):
            break
    while 1:
        s = readline()
        if ((not s) or (s == 'end\n')):
            break
        try:
            data = a2b_uu(s)
        except binascii.Error as v:
            nbytes = (((((ord(s[0]) - 32) & 63) * 4) + 5) / 3)
            data = a2b_uu(s[:nbytes])
        write(data)
    if (not s):
        raise ValueError, 'Truncated input data'
    return (outfile.getvalue(), len(input))
