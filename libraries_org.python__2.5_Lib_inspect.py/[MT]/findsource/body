def findsource(object):
    'Return the entire source file and starting line number for an object.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of all the lines\n    in the file and the line number indexes a line in that list.  An IOError\n    is raised if the source code cannot be retrieved.'
    file = (getsourcefile(object) or getfile(object))
    module = getmodule(object, file)
    if module:
        lines = linecache.getlines(file, module.__dict__)
    else:
        lines = linecache.getlines(file)
    if (not lines):
        raise IOError('could not get source code')
    if ismodule(object):
        return (lines, 0)
    if isclass(object):
        name = object.__name__
        pat = re.compile((('^(\\s*)class\\s*' + name) + '\\b'))
        candidates = []
        for i in range(len(lines)):
            match = pat.match(lines[i])
            if match:
                if (lines[i][0] == 'c'):
                    return (lines, i)
                candidates.append((match.group(1), i))
        if candidates:
            candidates.sort()
            return (lines, candidates[0][1])
        else:
            raise IOError('could not find class definition')
    if ismethod(object):
        object = object.im_func
    if isfunction(object):
        object = object.func_code
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if (not hasattr(object, 'co_firstlineno')):
            raise IOError('could not find function definition')
        lnum = (object.co_firstlineno - 1)
        pat = re.compile('^(\\s*def\\s)|(.*(?<!\\w)lambda(:|\\s))|^(\\s*@)')
        while (lnum > 0):
            if pat.match(lines[lnum]):
                break
            lnum = (lnum - 1)
        return (lines, lnum)
    raise IOError('could not find code object')
