def _parsebody(self, container, fp, firstbodyline=None):
    boundary = container.get_boundary()
    isdigest = (container.get_content_type() == 'multipart/digest')
    if boundary:
        preamble = epilogue = None
        separator = ('--' + boundary)
        payload = fp.read()
        if (firstbodyline is not None):
            payload = ((firstbodyline + '\n') + payload)
        mo = re.search((('(?P<sep>' + re.escape(separator)) + ')(?P<ws>[ \\t]*)'), payload)
        if (not mo):
            if self._strict:
                raise Errors.BoundaryError(("Couldn't find starting boundary: %s" % boundary))
            container.set_payload(payload)
            return
        start = mo.start()
        if (start > 0):
            preamble = payload[0:start]
        start += (len(mo.group('sep')) + len(mo.group('ws')))
        mo = NLCRE.search(payload, start)
        if mo:
            start += len(mo.group(0))
        cre = re.compile((('(?P<sep>\r\n|\r|\n)' + re.escape(separator)) + '--'))
        mo = cre.search(payload, start)
        if mo:
            terminator = mo.start()
            linesep = mo.group('sep')
            if (mo.end() < len(payload)):
                epilogue = payload[mo.end():]
        elif self._strict:
            raise Errors.BoundaryError(("Couldn't find terminating boundary: %s" % boundary))
        else:
            mo = re.search('(?P<sep>\r\n|\r|\n){2}$', payload)
            if (not mo):
                mo = re.search('(?P<sep>\r\n|\r|\n)$', payload)
                if (not mo):
                    raise Errors.BoundaryError('No terminating boundary and no trailing empty line')
            linesep = mo.group('sep')
            terminator = len(payload)
        parts = re.split((((linesep + re.escape(separator)) + '[ \\t]*') + linesep), payload[start:terminator])
        for part in parts:
            if isdigest:
                if part.startswith(linesep):
                    msgobj = self._class()
                    part = part[len(linesep):]
                else:
                    (parthdrs, part) = part.split((linesep + linesep), 1)
                    msgobj = self.parsestr(parthdrs, headersonly=1)
                msgobj.set_default_type('message/rfc822')
                maintype = msgobj.get_content_maintype()
                if (maintype in ('message', 'multipart')):
                    submsgobj = self.parsestr(part)
                    msgobj.attach(submsgobj)
                else:
                    msgobj.set_payload(part)
            else:
                msgobj = self.parsestr(part)
            container.preamble = preamble
            container.epilogue = epilogue
            container.attach(msgobj)
    elif (container.get_main_type() == 'multipart'):
        raise Errors.BoundaryError('multipart message with no defined boundary')
    elif (container.get_type() == 'message/delivery-status'):
        blocks = []
        while True:
            blockmsg = self._class()
            self._parseheaders(blockmsg, fp)
            if (not len(blockmsg)):
                break
            blocks.append(blockmsg)
        container.set_payload(blocks)
    elif (container.get_main_type() == 'message'):
        try:
            msg = self.parse(fp)
        except Errors.HeaderParseError:
            msg = self._class()
            self._parsebody(msg, fp)
        container.attach(msg)
    else:
        text = fp.read()
        if (firstbodyline is not None):
            text = ((firstbodyline + '\n') + text)
        container.set_payload(text)
