def do_break(self, arg, temporary=0):
    if (not arg):
        if self.breaks:
            print  >> self.stdout, 'Num Type         Disp Enb   Where'
            for bp in bdb.Breakpoint.bpbynumber:
                if bp:
                    bp.bpprint(self.stdout)
        return
    filename = None
    lineno = None
    cond = None
    comma = arg.find(',')
    if (comma > 0):
        cond = arg[(comma + 1):].lstrip()
        arg = arg[:comma].rstrip()
    colon = arg.rfind(':')
    funcname = None
    if (colon >= 0):
        filename = arg[:colon].rstrip()
        f = self.lookupmodule(filename)
        if (not f):
            print  >> self.stdout, '*** ', repr(filename),
            print  >> self.stdout, 'not found from sys.path'
            return
        else:
            filename = f
        arg = arg[(colon + 1):].lstrip()
        try:
            lineno = int(arg)
        except ValueError as msg:
            print  >> self.stdout, '*** Bad lineno:', arg
            return
    else:
        try:
            lineno = int(arg)
        except ValueError:
            try:
                func = eval(arg, self.curframe.f_globals, self.curframe.f_locals)
            except:
                func = arg
            try:
                if hasattr(func, 'im_func'):
                    func = func.im_func
                code = func.func_code
                funcname = code.co_name
                lineno = code.co_firstlineno
                filename = code.co_filename
            except:
                (ok, filename, ln) = self.lineinfo(arg)
                if (not ok):
                    print  >> self.stdout, '*** The specified object',
                    print  >> self.stdout, repr(arg),
                    print  >> self.stdout, 'is not a function'
                    print  >> self.stdout, 'or was not found along sys.path.'
                    return
                funcname = ok
                lineno = int(ln)
    if (not filename):
        filename = self.defaultFile()
    line = self.checkline(filename, lineno)
    if line:
        err = self.set_break(filename, line, temporary, cond, funcname)
        if err:
            print  >> self.stdout, '***', err
        else:
            bp = self.get_breaks(filename, line)[(-1)]
            print  >> self.stdout, ('Breakpoint %d at %s:%d' % (bp.number, bp.file, bp.line))
