{
  final StringBuilder sb=new StringBuilder();
  int next=getResponseStream().read();
  while ((next != -1) && !HeaderUtils.isSpace(next)) {
    sb.append((char)next);
    next=getResponseStream().read();
  }
  if (next == -1) {
    throw new IOException("Unable to parse the response HTTP version. End of stream reached too early.");
  }
  setVersion(sb.toString());
  sb.delete(0,sb.length());
  next=getResponseStream().read();
  while ((next != -1) && !HeaderUtils.isSpace(next)) {
    sb.append((char)next);
    next=getResponseStream().read();
  }
  if (next == -1) {
    throw new IOException("Unable to parse the response status. End of stream reached too early.");
  }
  setStatusCode(Integer.parseInt(sb.toString()));
  sb.delete(0,sb.length());
  next=getResponseStream().read();
  while ((next != -1) && !HeaderUtils.isCarriageReturn(next)) {
    sb.append((char)next);
    next=getResponseStream().read();
  }
  if (next == -1) {
    throw new IOException("Unable to parse the reason phrase. End of stream reached too early.");
  }
  next=getResponseStream().read();
  if (HeaderUtils.isLineFeed(next)) {
    setReasonPhrase(sb.toString());
    sb.delete(0,sb.length());
    Parameter header=HeaderUtils.readHeader(getResponseStream(),sb);
    while (header != null) {
      getResponseHeaders().add(header);
      header=HeaderUtils.readHeader(getResponseStream(),sb);
    }
  }
 else {
    throw new IOException("Unable to parse the reason phrase. The carriage return must be followed by a line feed.");
  }
}
