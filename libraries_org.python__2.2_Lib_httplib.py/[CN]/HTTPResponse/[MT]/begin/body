def begin(self):
    if (self.msg is not None):
        return
    while 1:
        (version, status, reason) = self._read_status()
        if (status != 100):
            break
        while 1:
            skip = self.fp.readline().strip()
            if (not skip):
                break
            if (self.debuglevel > 0):
                print 'header:', skip
    self.status = status
    self.reason = reason.strip()
    if (version == 'HTTP/1.0'):
        self.version = 10
    elif version.startswith('HTTP/1.'):
        self.version = 11
    elif (version == 'HTTP/0.9'):
        self.version = 9
    else:
        raise UnknownProtocol(version)
    if (self.version == 9):
        self.chunked = 0
        self.will_close = 1
        self.msg = HTTPMessage(StringIO())
        return
    self.msg = HTTPMessage(self.fp, 0)
    if (self.debuglevel > 0):
        for hdr in self.msg.headers:
            print 'header:', hdr,
    self.msg.fp = None
    tr_enc = self.msg.getheader('transfer-encoding')
    if (tr_enc and (tr_enc.lower() == 'chunked')):
        self.chunked = 1
        self.chunk_left = None
    else:
        self.chunked = 0
    conn = self.msg.getheader('connection')
    if conn:
        conn = conn.lower()
        self.will_close = ((conn.find('close') != (-1)) or ((self.version != 11) and (not self.msg.getheader('keep-alive'))))
    else:
        self.will_close = ((self.version != 11) and (not self.msg.getheader('keep-alive')))
    length = self.msg.getheader('content-length')
    if (length and (not self.chunked)):
        try:
            self.length = int(length)
        except ValueError:
            self.length = None
    else:
        self.length = None
    if ((status == 204) or (status == 304) or (100 <= status < 200)):
        self.length = 0
    if ((not self.will_close) and (not self.chunked) and (self.length is None)):
        self.will_close = 1
