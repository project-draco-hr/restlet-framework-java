{
  int result=0;
  boolean tryAgain=true;
  while (tryAgain) {
switch (this.chunkState) {
case SIZE:
      if (fillLine()) {
        System.out.print("### New chunk detected. Size: ");
        int length=getLineBuilder().length();
        if (length == 0) {
          throw new IOException("An empty chunk size line was detected");
        }
        int index=(getLineBuilder().indexOf(";"));
        index=(index == -1) ? getLineBuilder().length() : index;
        try {
          this.availableChunkSize=Long.parseLong(getLineBuilder().substring(0,index).trim(),16);
          clearLineBuilder();
          System.out.println(this.availableChunkSize);
        }
 catch (        NumberFormatException ex) {
          throw new IOException("\"" + getLineBuilder() + "\" has an invalid chunk size");
        }
        if (this.availableChunkSize == 0) {
          this.chunkState=ChunkState.TRAILER;
        }
 else {
          this.chunkState=ChunkState.DATA;
        }
      }
 else {
        tryAgain=false;
      }
    break;
case DATA:
  if (this.availableChunkSize > 0) {
    if (this.availableChunkSize < dst.remaining()) {
      dst.limit((int)(this.availableChunkSize + dst.position()));
    }
    result=super.read(dst);
    tryAgain=false;
    if (result > 0) {
      this.availableChunkSize-=result;
    }
 else {
      System.out.println("No chunk data read");
    }
  }
 else   if (this.availableChunkSize == 0) {
    if (fillLine()) {
      clearLineBuilder();
      this.chunkState=ChunkState.SIZE;
    }
 else {
      tryAgain=false;
    }
  }
break;
case TRAILER:
this.chunkState=ChunkState.END;
break;
case END:
result=-1;
tryAgain=false;
break;
}
}
postRead(result);
return result;
}
