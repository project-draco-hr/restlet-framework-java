{
  int result=0;
  boolean tryAgain=true;
  while (tryAgain) {
switch (this.chunkState) {
case STATE_CHUNK_SIZE:
      if (fillLine()) {
        System.out.print("### New chunk detected. Size: ");
        int length=getLineBuilder().length();
        if (length == 0) {
          throw new IOException("An empty chunk size line was detected");
        }
        int index=(getLineBuilder().indexOf(";"));
        index=(index == -1) ? getLineBuilder().length() : index;
        try {
          this.availableChunkSize=Long.parseLong(getLineBuilder().substring(0,index).trim(),16);
          clearLineBuilder();
          System.out.println(this.availableChunkSize);
        }
 catch (        NumberFormatException ex) {
          throw new IOException("\"" + getLineBuilder() + "\" has an invalid chunk size");
        }
        if (this.availableChunkSize == 0) {
          this.chunkState=STATE_CHUNK_TRAILER;
        }
 else {
          this.chunkState=STATE_CHUNK_DATA;
        }
      }
 else {
        tryAgain=false;
      }
    break;
case STATE_CHUNK_DATA:
  if (this.availableChunkSize > 0) {
    if (this.availableChunkSize < dst.remaining()) {
      dst.limit((int)(this.availableChunkSize + dst.position()));
    }
    result=super.read(dst);
    tryAgain=false;
    if (result > 0) {
      this.availableChunkSize-=result;
    }
  }
if (this.availableChunkSize == 0) {
  if (fillLine()) {
    clearLineBuilder();
    this.chunkState=STATE_CHUNK_SIZE;
  }
 else {
    tryAgain=false;
  }
}
break;
case STATE_CHUNK_TRAILER:
this.chunkState=STATE_CHUNK_END;
break;
case STATE_CHUNK_END:
result=-1;
tryAgain=false;
break;
}
}
postRead(result);
return result;
}
