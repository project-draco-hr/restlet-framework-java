'\nThis is a Py2.3 implementation of decimal floating point arithmetic based on\nthe General Decimal Arithmetic Specification:\n\n    www2.hursley.ibm.com/decimal/decarith.html\n\nand IEEE standard 854-1987:\n\n    www.cs.berkeley.edu/~ejr/projects/754/private/drafts/854-1987/dir.html\n\nDecimal floating point has finite precision with arbitrarily large bounds.\n\nThe purpose of this module is to support arithmetic using familiar\n"schoolhouse" rules and to avoid some of the tricky representation\nissues associated with binary floating point.  The package is especially\nuseful for financial applications or for contexts where users have\nexpectations that are at odds with binary floating point (for instance,\nin binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead\nof the expected Decimal("0.00") returned by decimal floating point).\n\nHere are some examples of using the decimal module:\n\n>>> from decimal import *\n>>> setcontext(ExtendedContext)\n>>> Decimal(0)\nDecimal("0")\n>>> Decimal("1")\nDecimal("1")\n>>> Decimal("-.0123")\nDecimal("-0.0123")\n>>> Decimal(123456)\nDecimal("123456")\n>>> Decimal("123.45e12345678901234567890")\nDecimal("1.2345E+12345678901234567892")\n>>> Decimal("1.33") + Decimal("1.27")\nDecimal("2.60")\n>>> Decimal("12.34") + Decimal("3.87") - Decimal("18.41")\nDecimal("-2.20")\n>>> dig = Decimal(1)\n>>> print dig / Decimal(3)\n0.333333333\n>>> getcontext().prec = 18\n>>> print dig / Decimal(3)\n0.333333333333333333\n>>> print dig.sqrt()\n1\n>>> print Decimal(3).sqrt()\n1.73205080756887729\n>>> print Decimal(3) ** 123\n4.85192780976896427E+58\n>>> inf = Decimal(1) / Decimal(0)\n>>> print inf\nInfinity\n>>> neginf = Decimal(-1) / Decimal(0)\n>>> print neginf\n-Infinity\n>>> print neginf + inf\nNaN\n>>> print neginf * inf\n-Infinity\n>>> print dig / 0\nInfinity\n>>> getcontext().traps[DivisionByZero] = 1\n>>> print dig / 0\nTraceback (most recent call last):\n  ...\n  ...\n  ...\nDivisionByZero: x / 0\n>>> c = Context()\n>>> c.traps[InvalidOperation] = 0\n>>> print c.flags[InvalidOperation]\n0\n>>> c.divide(Decimal(0), Decimal(0))\nDecimal("NaN")\n>>> c.traps[InvalidOperation] = 1\n>>> print c.flags[InvalidOperation]\n1\n>>> c.flags[InvalidOperation] = 0\n>>> print c.flags[InvalidOperation]\n0\n>>> print c.divide(Decimal(0), Decimal(0))\nTraceback (most recent call last):\n  ...\n  ...\n  ...\nInvalidOperation: 0 / 0\n>>> print c.flags[InvalidOperation]\n1\n>>> c.flags[InvalidOperation] = 0\n>>> c.traps[InvalidOperation] = 0\n>>> print c.divide(Decimal(0), Decimal(0))\nNaN\n>>> print c.flags[InvalidOperation]\n1\n>>>\n'
__all__ = ['Decimal', 'Context', 'DefaultContext', 'BasicContext', 'ExtendedContext', 'DecimalException', 'Clamped', 'InvalidOperation', 'DivisionByZero', 'Inexact', 'Rounded', 'Subnormal', 'Overflow', 'Underflow', 'ROUND_DOWN', 'ROUND_HALF_UP', 'ROUND_HALF_EVEN', 'ROUND_CEILING', 'ROUND_FLOOR', 'ROUND_UP', 'ROUND_HALF_DOWN', 'ROUND_05UP', 'setcontext', 'getcontext', 'localcontext']
import copy as _copy
ROUND_DOWN = 'ROUND_DOWN'
ROUND_HALF_UP = 'ROUND_HALF_UP'
ROUND_HALF_EVEN = 'ROUND_HALF_EVEN'
ROUND_CEILING = 'ROUND_CEILING'
ROUND_FLOOR = 'ROUND_FLOOR'
ROUND_UP = 'ROUND_UP'
ROUND_HALF_DOWN = 'ROUND_HALF_DOWN'
ROUND_05UP = 'ROUND_05UP'
_signals = [Clamped, DivisionByZero, Inexact, Overflow, Rounded, Underflow, InvalidOperation, Subnormal]
_condition_map = {ConversionSyntax: InvalidOperation, DivisionImpossible: InvalidOperation, DivisionUndefined: InvalidOperation, InvalidContext: InvalidOperation, }
try:
    import threading
except ImportError:
    import sys


    class MockThreading(object):

        def local(self, sys=sys):
            return sys.modules[__name__]
    threading = MockThreading()
    del sys, MockThreading
try:
    threading.local
except AttributeError:
    if hasattr(threading.currentThread(), '__decimal_context__'):
        del threading.currentThread().__decimal_context__

    def setcontext(context):
        "Set this thread's context to context."
        if (context in (DefaultContext, BasicContext, ExtendedContext)):
            context = context.copy()
            context.clear_flags()
        threading.currentThread().__decimal_context__ = context

    def getcontext():
        "Returns this thread's context.\n\n        If this thread does not yet have a context, returns\n        a new context and sets this thread's context.\n        New contexts are copies of DefaultContext.\n        "
        try:
            return threading.currentThread().__decimal_context__
        except AttributeError:
            context = Context()
            threading.currentThread().__decimal_context__ = context
            return context
else:
    local = threading.local()
    if hasattr(local, '__decimal_context__'):
        del local.__decimal_context__

    def getcontext(_local=local):
        "Returns this thread's context.\n\n        If this thread does not yet have a context, returns\n        a new context and sets this thread's context.\n        New contexts are copies of DefaultContext.\n        "
        try:
            return _local.__decimal_context__
        except AttributeError:
            context = Context()
            _local.__decimal_context__ = context
            return context

    def setcontext(context, _local=local):
        "Set this thread's context to context."
        if (context in (DefaultContext, BasicContext, ExtendedContext)):
            context = context.copy()
            context.clear_flags()
        _local.__decimal_context__ = context
    del threading, local
rounding_functions = [name for name in Decimal.__dict__.keys() if name.startswith('_round_')]
for name in rounding_functions:
    globalname = name[1:].upper()
    val = globals()[globalname]
    Decimal._pick_rounding_function[val] = name
del name, val, globalname, rounding_functions
_log10_digits = _Log10Memoize().getdigits
DefaultContext = Context(prec=28, rounding=ROUND_HALF_EVEN, traps=[DivisionByZero, Overflow, InvalidOperation], flags=[], Emax=999999999, Emin=(-999999999), capitals=1)
BasicContext = Context(prec=9, rounding=ROUND_HALF_UP, traps=[DivisionByZero, Overflow, InvalidOperation, Clamped, Underflow], flags=[])
ExtendedContext = Context(prec=9, rounding=ROUND_HALF_EVEN, traps=[], flags=[])
import re
import re
_parser = re.compile('     # A numeric string consists of:\n#    \\s*\n    (?P<sign>[-+])?           # an optional sign, followed by either...\n    (\n        (?=\\d|\\.\\d)           # ...a number (with at least one digit)\n        (?P<int>\\d*)          # consisting of a (possibly empty) integer part\n        (\\.(?P<frac>\\d*))?    # followed by an optional fractional part\n        (E(?P<exp>[-+]?\\d+))? # followed by an optional exponent, or...\n    |\n        Inf(inity)?           # ...an infinity, or...\n    |\n        (?P<signal>s)?        # ...an (optionally signaling)\n        NaN                   # NaN\n        (?P<diag>\\d*)         # with (possibly empty) diagnostic information.\n    )\n#    \\s*\n    $\n', (re.VERBOSE | re.IGNORECASE)).match
_all_zeros = re.compile('0*$').match
_exact_half = re.compile('50*$').match
del re
Inf = Decimal('Inf')
negInf = Decimal('-Inf')
NaN = Decimal('NaN')
Dec_0 = Decimal(0)
Dec_p1 = Decimal(1)
Dec_n1 = Decimal((-1))
Infsign = (Inf, negInf)
if (__name__ == '__main__'):
    import doctest, sys
    doctest.testmod(sys.modules[__name__])
