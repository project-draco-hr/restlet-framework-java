def compare_total(self, other):
    'Compares self to other using the abstract representations.\n\n        This is not like the standard compare, which use their numerical\n        value. Note that a total ordering is defined for all possible abstract\n        representations.\n        '
    if (self._sign and (not other._sign)):
        return Dec_n1
    if ((not self._sign) and other._sign):
        return Dec_p1
    sign = self._sign
    self_nan = self._isnan()
    other_nan = other._isnan()
    if (self_nan or other_nan):
        if (self_nan == other_nan):
            if (self._int < other._int):
                if sign:
                    return Dec_p1
                else:
                    return Dec_n1
            if (self._int > other._int):
                if sign:
                    return Dec_n1
                else:
                    return Dec_p1
            return Dec_0
        if sign:
            if (self_nan == 1):
                return Dec_n1
            if (other_nan == 1):
                return Dec_p1
            if (self_nan == 2):
                return Dec_n1
            if (other_nan == 2):
                return Dec_p1
        else:
            if (self_nan == 1):
                return Dec_p1
            if (other_nan == 1):
                return Dec_n1
            if (self_nan == 2):
                return Dec_p1
            if (other_nan == 2):
                return Dec_n1
    if (self < other):
        return Dec_n1
    if (self > other):
        return Dec_p1
    if (self._exp < other._exp):
        if sign:
            return Dec_p1
        else:
            return Dec_n1
    if (self._exp > other._exp):
        if sign:
            return Dec_n1
        else:
            return Dec_p1
    return Dec_0
