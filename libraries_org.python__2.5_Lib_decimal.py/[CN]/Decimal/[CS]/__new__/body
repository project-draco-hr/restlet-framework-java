def __new__(cls, value='0', context=None):
    'Create a decimal point instance.\n\n        >>> Decimal(\'3.14\')              # string input\n        Decimal("3.14")\n        >>> Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)\n        Decimal("3.14")\n        >>> Decimal(314)                 # int or long\n        Decimal("314")\n        >>> Decimal(Decimal(314))        # another decimal instance\n        Decimal("314")\n        '
    self = object.__new__(cls)
    if isinstance(value, basestring):
        m = _parser(value)
        if (m is None):
            if (context is None):
                context = getcontext()
            return context._raise_error(ConversionSyntax, ('Invalid literal for Decimal: %r' % value))
        if (m.group('sign') == '-'):
            self._sign = 1
        else:
            self._sign = 0
        intpart = m.group('int')
        if (intpart is not None):
            fracpart = m.group('frac')
            exp = int((m.group('exp') or '0'))
            if (fracpart is not None):
                self._int = str(((intpart + fracpart).lstrip('0') or '0'))
                self._exp = (exp - len(fracpart))
            else:
                self._int = str((intpart.lstrip('0') or '0'))
                self._exp = exp
            self._is_special = False
        else:
            diag = m.group('diag')
            if (diag is not None):
                self._int = str(diag.lstrip('0'))
                if m.group('signal'):
                    self._exp = 'N'
                else:
                    self._exp = 'n'
            else:
                self._int = '0'
                self._exp = 'F'
            self._is_special = True
        return self
    if isinstance(value, (int, long)):
        if (value >= 0):
            self._sign = 0
        else:
            self._sign = 1
        self._exp = 0
        self._int = str(abs(value))
        self._is_special = False
        return self
    if isinstance(value, Decimal):
        self._exp = value._exp
        self._sign = value._sign
        self._int = value._int
        self._is_special = value._is_special
        return self
    if isinstance(value, _WorkRep):
        self._sign = value.sign
        self._int = str(value.int)
        self._exp = int(value.exp)
        self._is_special = False
        return self
    if isinstance(value, (list, tuple)):
        if (len(value) != 3):
            raise ValueError('Invalid tuple size in creation of Decimal from list or tuple.  The list or tuple should have exactly three elements.')
        if (not (isinstance(value[0], (int, long)) and (value[0] in (0, 1)))):
            raise ValueError('Invalid sign.  The first value in the tuple should be an integer; either 0 for a positive number or 1 for a negative number.')
        self._sign = value[0]
        if (value[2] == 'F'):
            self._int = '0'
            self._exp = value[2]
            self._is_special = True
        else:
            digits = []
            for digit in value[1]:
                if (isinstance(digit, (int, long)) and (0 <= digit <= 9)):
                    if (digits or (digit != 0)):
                        digits.append(digit)
                else:
                    raise ValueError('The second value in the tuple must be composed of integers in the range 0 through 9.')
            if (value[2] in ('n', 'N')):
                self._int = ''.join(map(str, digits))
                self._exp = value[2]
                self._is_special = True
            elif isinstance(value[2], (int, long)):
                self._int = ''.join(map(str, (digits or [0])))
                self._exp = value[2]
                self._is_special = False
            else:
                raise ValueError("The third value in the tuple must be an integer, or one of the strings 'F', 'n', 'N'.")
        return self
    if isinstance(value, float):
        raise TypeError(('Cannot convert float to Decimal.  ' + 'First convert the float to a string'))
    raise TypeError(('Cannot convert %r to Decimal' % value))
