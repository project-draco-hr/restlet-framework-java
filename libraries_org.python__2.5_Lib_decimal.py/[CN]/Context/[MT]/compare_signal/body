def compare_signal(self, a, b):
    'Compares the values of the two operands numerically.\n\n        It\'s pretty much like compare(), but all NaNs signal, with signaling\n        NaNs taking precedence over quiet NaNs.\n\n        >>> c = ExtendedContext\n        >>> c.compare_signal(Decimal(\'2.1\'), Decimal(\'3\'))\n        Decimal("-1")\n        >>> c.compare_signal(Decimal(\'2.1\'), Decimal(\'2.1\'))\n        Decimal("0")\n        >>> c.flags[InvalidOperation] = 0\n        >>> print c.flags[InvalidOperation]\n        0\n        >>> c.compare_signal(Decimal(\'NaN\'), Decimal(\'2.1\'))\n        Decimal("NaN")\n        >>> print c.flags[InvalidOperation]\n        1\n        >>> c.flags[InvalidOperation] = 0\n        >>> print c.flags[InvalidOperation]\n        0\n        >>> c.compare_signal(Decimal(\'sNaN\'), Decimal(\'2.1\'))\n        Decimal("NaN")\n        >>> print c.flags[InvalidOperation]\n        1\n        '
    return a.compare_signal(b, context=self)
