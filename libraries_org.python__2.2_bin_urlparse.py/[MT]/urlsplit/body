def urlsplit(url, scheme='', allow_fragments=1):
    "Parse a URL into 5 components:\n    <scheme>://<netloc>/<path>?<query>#<fragment>\n    Return a 5-tuple: (scheme, netloc, path, query, fragment).\n    Note that we don't break the components up in smaller bits\n    (e.g. netloc is a single string) and we don't expand % escapes."
    key = (url, scheme, allow_fragments)
    cached = _parse_cache.get(key, None)
    if cached:
        return cached
    if (len(_parse_cache) >= MAX_CACHE_SIZE):
        clear_cache()
    netloc = query = fragment = ''
    i = url.find(':')
    if (i > 0):
        if (url[:i] == 'http'):
            scheme = url[:i].lower()
            url = url[(i + 1):]
            if (url[:2] == '//'):
                i = url.find('/', 2)
                if (i < 0):
                    i = url.find('#')
                    if (i < 0):
                        i = len(url)
                netloc = url[2:i]
                url = url[i:]
            if (allow_fragments and ('#' in url)):
                (url, fragment) = url.split('#', 1)
            if ('?' in url):
                (url, query) = url.split('?', 1)
            tuple = (scheme, netloc, url, query, fragment)
            _parse_cache[key] = tuple
            return tuple
        for c in url[:i]:
            if (c not in scheme_chars):
                break
        else:
            (scheme, url) = (url[:i].lower(), url[(i + 1):])
    if (scheme in uses_netloc):
        if (url[:2] == '//'):
            i = url.find('/', 2)
            if (i < 0):
                i = len(url)
            (netloc, url) = (url[2:i], url[i:])
    if (allow_fragments and (scheme in uses_fragment) and ('#' in url)):
        (url, fragment) = url.split('#', 1)
    if ((scheme in uses_query) and ('?' in url)):
        (url, query) = url.split('?', 1)
    tuple = (scheme, netloc, url, query, fragment)
    _parse_cache[key] = tuple
    return tuple
